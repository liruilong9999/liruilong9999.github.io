<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2026/02/19/hello-world/"/>
    <url>/2026/02/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2026/02/19/ComfyUi%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-controlNet/"/>
    <url>/2026/02/19/ComfyUi%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-controlNet/</url>
    
    <content type="html"><![CDATA[<blockquote><h2 id="Documentation-Index"><a href="#Documentation-Index" class="headerlink" title="Documentation Index"></a>Documentation Index</h2><p>Fetch the complete documentation index at: <a href="https://docs.comfy.org/llms.txt">https://docs.comfy.org/llms.txt</a><br>Use this file to discover all available pages before exploring further.</p></blockquote><h1 id="ComfyUI-ControlNet-使用示例"><a href="#ComfyUI-ControlNet-使用示例" class="headerlink" title="ComfyUI ControlNet 使用示例"></a>ComfyUI ControlNet 使用示例</h1><blockquote><p>本篇将引导了解基础的 ControlNet 概念，并在 ComfyUI 中完成对应的图像生成</p></blockquote><p>在 AI 图像生成过程中，要精确控制图像生成并不是一键容易的事情，通常需要通过许多次的图像生成才可能生成满意的图像，但随着 <strong>ControlNet</strong> 的出现，这个问题得到了很好的解决。</p><p>ControlNet 是一种基于扩散模型（如 Stable Diffusion）的条件控制生成模型，最早由<a href="https://lllyasviel.github.io/">Lvmin Zhang</a>与 Maneesh Agrawala 等人于 2023 年提出<a href="https://arxiv.org/abs/2302.05543">Adding Conditional Control to Text-to-Image Diffusion Models</a></p><p>ControlNet 模型通过引入多模态输入条件（如边缘检测图、深度图、姿势关键点等），显著提升了图像生成的可控性和细节还原能力。<br>使得我们可以进一步开始控制图像的风格、细节、人物姿势、画面结构等等，这些限定条件让图像生成变得更加可控，在绘图过程中也可以同时使用多个 ControlNet 模型，以达到更好的效果。</p><p>在没有 ControlNet 之前，我们每次只能让模型生成图像，直到生成我们满意的图像，充满了随机性。</p><img src="https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/generated_with_random_seed.jpg?fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=81acd50958fd1df511237b3ba90b1b06" alt="ComfyUI 随机种子生成的图片" data-og-width="1024" width="1024" data-og-height="1024" height="1024" data-path="images/tutorial/controlnet/generated_with_random_seed.jpg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/generated_with_random_seed.jpg?w=280&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=ecea01007c3a2d375a0ea70846fcefa0 280w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/generated_with_random_seed.jpg?w=560&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=7225cef825a3c4ff365c741a360ddc0a 560w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/generated_with_random_seed.jpg?w=840&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=1bbe42f0369bfa8d9891671b41979534 840w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/generated_with_random_seed.jpg?w=1100&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=eee86e1fe36b8fe048e43a510e531bcf 1100w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/generated_with_random_seed.jpg?w=1650&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=7d1a369b55b8fcfdd9b1b465e3346c53 1650w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/generated_with_random_seed.jpg?w=2500&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=5a64bd353fbadff7b85acc589e19f8ed 2500w" /><p>但随着 ControlNet 的出现，我们可以通过引入额外的条件，来控制图像的生成，比如我们可以使用一张简单的涂鸦，来控制图像的生成，就可以生成差不多类似的图片。</p><img src="https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/scribble_example.jpg?fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=36c37d9cadfaabb3690404f8828143a7" alt="ComfyUI 涂鸦控制图像生成" data-og-width="1024" width="1024" data-og-height="512" height="512" data-path="images/tutorial/controlnet/scribble_example.jpg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/scribble_example.jpg?w=280&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=c442f3baa2efb48d21d7b037ce97acf1 280w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/scribble_example.jpg?w=560&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=a024658d6d9270ce18185ccaf6fe820b 560w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/scribble_example.jpg?w=840&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=ab4ce66b96385a6f6c07346f39a67f4c 840w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/scribble_example.jpg?w=1100&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=9a2e79c32dfcdb73342e36682e147520 1100w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/scribble_example.jpg?w=1650&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=c03cc09cfcef43cb12dd0d90d8d57026 1650w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/scribble_example.jpg?w=2500&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=c8ae34966713cae3564c467f7ab5e0fe 2500w" /><p>在本示例中，我们将引导你完成在 <a href="https://github.com/comfyanonymous/ComfyUI">ComfyUI</a> 中 ControlNet 模型的安装与使用, 并完成一个涂鸦控制图像生成的示例。</p><p><img src="https://raw.githubusercontent.com/Comfy-Org/example_workflows/main/controlnet/scribble_controlnet.png" alt="ComfyUI ControlNet 工作流"></p><Tip>  ControlNet V1.1 其它类型的 ControlNet 模型的工作流也与都与本篇示例相同，你只需要根据需要选择对应的模型和上传对应的参考图即可。</Tip><h2 id="ControlNet-图片预处理相关说明"><a href="#ControlNet-图片预处理相关说明" class="headerlink" title="ControlNet 图片预处理相关说明"></a>ControlNet 图片预处理相关说明</h2><p>不同类型的 ControlNet 模型，通常需要使用不同类型的参考图：</p><p><img src="https://github.com/Fannovel16/comfyui_controlnet_aux/blob/main/examples/CNAuxBanner.jpg?raw=true" alt="参考图"></p><blockquote><p>图源：<a href="https://github.com/Fannovel16/comfyui_controlnet_aux">ComfyUI ControlNet aux</a></p></blockquote><p>由于目前 <strong>Comfy Core</strong> 节点中，不包含所有类型的 <strong>预处理器</strong> 类型，但在本文档的实际示例中，我们都将提供已经经过处理后的图片，<br>但在实际使用过程中，你可能需要借助一些自定义节点来对图片进行预处理，以满足不同 ControlNet 模型的需求，下面是一些相关的插件</p><ul><li><a href="https://github.com/Kosinkadink/ComfyUI-Advanced-ControlNet">ComfyUI-Advanced-ControlNet</a></li><li><a href="https://github.com/Fannovel16/comfyui_controlnet_aux">ComfyUI ControlNet aux</a></li></ul><h2 id="ComfyUI-ControlNet-工作流示例讲解"><a href="#ComfyUI-ControlNet-工作流示例讲解" class="headerlink" title="ComfyUI ControlNet 工作流示例讲解"></a>ComfyUI ControlNet 工作流示例讲解</h2><h3 id="1-ControlNet-工作流素材"><a href="#1-ControlNet-工作流素材" class="headerlink" title="1. ControlNet 工作流素材"></a>1. ControlNet 工作流素材</h3><p>请下载下面的工作流图片,并拖入 ComfyUI 以加载工作流</p><p><img src="https://raw.githubusercontent.com/Comfy-Org/example_workflows/main/controlnet/scribble_controlnet.png" alt="ComfyUI 工作流 - ControlNet"></p><Tip>  Metadata 中包含工作流 json 的图片可直接拖入 ComfyUI 或使用菜单 `Workflows` -> `Open（ctrl+o）` 来加载对应的工作流。  该图片已包含对应模型的下载链接，直接拖入 ComfyUI 将会自动提示下载。</Tip><p>请下载下面的图片，我们将会将它作为输入</p><p><img src="https://raw.githubusercontent.com/Comfy-Org/example_workflows/main/controlnet/scribble_input.png" alt="ComfyUI 涂鸦图片"></p><h3 id="2-手动模型安装"><a href="#2-手动模型安装" class="headerlink" title="2.  手动模型安装"></a>2.  手动模型安装</h3><Note>  如果你网络无法顺利完成对应模型的自动下载，请尝试手动下载下面的模型，并放置到指定目录中</Note><ul><li><a href="https://civitai.com/api/download/models/731340?type=Model&format=SafeTensor&size=full&fp=fp16">dreamCreationVirtual3DECommerce_v10.safetensors</a></li><li><a href="https://huggingface.co/stabilityai/sd-vae-ft-mse-original/resolve/main/vae-ft-mse-840000-ema-pruned.safetensors?download=true">vae-ft-mse-840000-ema-pruned.safetensors</a></li><li><a href="https://huggingface.co/comfyanonymous/ControlNet-v1-1_fp16_safetensors/resolve/main/control_v11p_sd15_scribble_fp16.safetensors?download=true">control_v11p_sd15_scribble_fp16.safetensors</a></li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">ComfyUI<span class="hljs-symbol">/</span><br>├── models<span class="hljs-symbol">/</span><br>│   ├── checkpoints<span class="hljs-symbol">/</span><br>│   │   └── dreamCreationVirtual3DECommerce_v10.safetensors<br>│   ├── vae<span class="hljs-symbol">/</span><br>│   │   └── vae-ft-mse-<span class="hljs-number">84000</span>0-ema-pruned.safetensors<br>│   └── controlnet<span class="hljs-symbol">/</span><br>│       └── control_v11p_sd15_scribble_fp16.safetensors<br></code></pre></td></tr></table></figure><Note>  本示例中 vae 模型也可以使用 dreamCreationVirtual3DECommerce\_v10.safetensors 模型中的 vae 模型，这里我们遵循模型作者建议使用单独的 vae 模型。</Note><h3 id="3-按步骤完成工作流的运行"><a href="#3-按步骤完成工作流的运行" class="headerlink" title="3. 按步骤完成工作流的运行"></a>3. 按步骤完成工作流的运行</h3><img src="https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/flow_diagram_scribble.png?fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=d26abbfd1993f28b88efcf6231246945" alt="ComfyUI 工作流 - ControlNet 流程图" data-og-width="2000" width="2000" data-og-height="1086" height="1086" data-path="images/tutorial/controlnet/flow_diagram_scribble.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/flow_diagram_scribble.png?w=280&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=08969e36a1eda27b8d60fb77cb41afee 280w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/flow_diagram_scribble.png?w=560&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=94b8fabbcd1f910e52bf9834d3ac5678 560w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/flow_diagram_scribble.png?w=840&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=0e809d2f8d501e7e308408d46a6a8588 840w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/flow_diagram_scribble.png?w=1100&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=6fea2381caed335cac0b7073ef9366e0 1100w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/flow_diagram_scribble.png?w=1650&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=2d8133f58fc8c11cacf2ed11e8c181bd 1650w, https://mintcdn.com/dripart/TwfNQ2dEaWQA7tIL/images/tutorial/controlnet/flow_diagram_scribble.png?w=2500&fit=max&auto=format&n=TwfNQ2dEaWQA7tIL&q=85&s=a1c8aec6bfe0316295dcf600b09cebe2 2500w" /><ol><li>确保<code>Load Checkpoint</code>可以加载 <strong>dreamCreationVirtual3DECommerce_v10.safetensors</strong></li><li>确保<code>Load VAE</code>可以加载 <strong>vae-ft-mse-840000-ema-pruned.safetensors</strong></li><li>在<code>Load Image</code>中点击<code>Upload</code> 上传之前提供的输入图片</li><li>确保<code>Load ControlNet</code>可以加载 <strong>control_v11p_sd15_scribble_fp16.safetensors</strong></li><li>点击 <code>Queue</code> 按钮，或者使用快捷键 <code>Ctrl(cmd) + Enter(回车)</code> 来执行图片的生成</li></ol><h2 id="相关节点讲解"><a href="#相关节点讲解" class="headerlink" title="相关节点讲解"></a>相关节点讲解</h2><h3 id="Load-ControlNet-节点讲解"><a href="#Load-ControlNet-节点讲解" class="headerlink" title="Load ControlNet 节点讲解"></a>Load ControlNet 节点讲解</h3><img src="https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/loaders/load_controlnet_model.jpg?fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=c3a99d9bd08baaedb7a4d426cc930880" alt="load controlnet" data-og-width="807" width="807" data-og-height="294" height="294" data-path="images/comfy_core/loaders/load_controlnet_model.jpg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/loaders/load_controlnet_model.jpg?w=280&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=1d65dc81220e679eb2f17860ffe92562 280w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/loaders/load_controlnet_model.jpg?w=560&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=3d499a7fab5e9656b3043440bb259906 560w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/loaders/load_controlnet_model.jpg?w=840&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=54654343fb221fc3ae377467f2c799a6 840w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/loaders/load_controlnet_model.jpg?w=1100&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=e363dc10dfa46d6f2e26e94018ef47ba 1100w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/loaders/load_controlnet_model.jpg?w=1650&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=4c90104f34b30cc2e7943bc047639345 1650w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/loaders/load_controlnet_model.jpg?w=2500&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=eaa65efbc295ed4f2bd3a8885acc02d0 2500w" /><p>位于<code>ComfyUI\models\controlnet</code> 的模型会被 ComfyUI 检测到，并在这个节点中识别并加载</p><h3 id="Apply-ControlNet-节点讲解"><a href="#Apply-ControlNet-节点讲解" class="headerlink" title="Apply ControlNet 节点讲解"></a>Apply ControlNet 节点讲解</h3><img src="https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet.jpg?fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=de9e90df2dcfe5cc7020a8c9cdb40a65" alt="apply controlnet " data-og-width="778" width="778" data-og-height="547" height="547" data-path="images/comfy_core/conditioning/controlnet/apply_controlnet.jpg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet.jpg?w=280&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=d2589a80afb77a1dd0d7fa12ae34142c 280w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet.jpg?w=560&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=25ed3a4735b06b267519ac4313bcbaca 560w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet.jpg?w=840&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=0b18dfc1c8fdd26f07a00c4d5e422f16 840w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet.jpg?w=1100&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=984444ad3f286a57a48cad3e9d30cb59 1100w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet.jpg?w=1650&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=adbb7c39e09866c7c85fc9bbb59c9ebc 1650w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet.jpg?w=2500&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=c1257bb2026d9ef99421d5474e1dea23 2500w" /><p>这个节点接受 <code>load controlnet</code> 加载的 ControlNet 模型，并根据输入的图片，生成对应的控制条件。</p><p><strong>输入类型</strong></p><table><thead><tr><th>参数名称</th><th>作用</th></tr></thead><tbody><tr><td><code>positive</code></td><td>正向条件</td></tr><tr><td><code>negative</code></td><td>负向条件</td></tr><tr><td><code>control_net</code></td><td>要应用的controlNet模型</td></tr><tr><td><code>image</code></td><td>用于 controlNet 应用参考的预处理器处理图片</td></tr><tr><td><code>vae</code></td><td>Vae模型输入</td></tr><tr><td><code>strength</code></td><td>应用 ControlNet 的强度，越大则 ControlNet 对生成图像的影响越大</td></tr><tr><td><code>start_percent</code></td><td>确定开始应用controlNet的百分比，比如取值0.2，意味着ControlNet的引导将在扩散过程完成20%时开始影响图像生成</td></tr><tr><td><code>end_percent</code></td><td>确定结束应用controlNet的百分比，比如取值0.8，意味着ControlNet的引导将在扩散过程完成80%时停止影响图像生成</td></tr></tbody></table><p><strong>输出类型</strong></p><table><thead><tr><th>参数名称</th><th>作用</th></tr></thead><tbody><tr><td><code>positive</code></td><td>应用了 ControlNet 处理后的正向条件数据</td></tr><tr><td><code>negative</code></td><td>应用了 ControlNet 处理后的负向条件数据</td></tr></tbody></table><p>你可以使用链式链接来应用多个 ControlNet 模型，如下图所示，你也可以参考 <a href="/zh-CN/tutorials/controlnet/mixing-controlnets">混合 ControlNet 模型</a> 部分的指南来了解更多关于混合 ControlNet 模型的使用<br><img src="https://mintcdn.com/dripart/OltlUSVBSNcJsDMs/images/tutorial/controlnet/apply_controlnet_chain_link.jpg?fit=max&auto=format&n=OltlUSVBSNcJsDMs&q=85&s=6fc3e75414f05e6c62062b4b746dc855" alt="apply controlnet chain link" data-og-width="1500" width="1500" data-og-height="1050" height="1050" data-path="images/tutorial/controlnet/apply_controlnet_chain_link.jpg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/OltlUSVBSNcJsDMs/images/tutorial/controlnet/apply_controlnet_chain_link.jpg?w=280&fit=max&auto=format&n=OltlUSVBSNcJsDMs&q=85&s=da6928840e7317cf4c0cc56cddd3bef9 280w, https://mintcdn.com/dripart/OltlUSVBSNcJsDMs/images/tutorial/controlnet/apply_controlnet_chain_link.jpg?w=560&fit=max&auto=format&n=OltlUSVBSNcJsDMs&q=85&s=be2b48a1a8c3f852ffbc1e0e7fa06f54 560w, https://mintcdn.com/dripart/OltlUSVBSNcJsDMs/images/tutorial/controlnet/apply_controlnet_chain_link.jpg?w=840&fit=max&auto=format&n=OltlUSVBSNcJsDMs&q=85&s=8488372f56c5d9e7a4f95574094bcd25 840w, https://mintcdn.com/dripart/OltlUSVBSNcJsDMs/images/tutorial/controlnet/apply_controlnet_chain_link.jpg?w=1100&fit=max&auto=format&n=OltlUSVBSNcJsDMs&q=85&s=3893bbb66fd156f76713a5d51623cd12 1100w, https://mintcdn.com/dripart/OltlUSVBSNcJsDMs/images/tutorial/controlnet/apply_controlnet_chain_link.jpg?w=1650&fit=max&auto=format&n=OltlUSVBSNcJsDMs&q=85&s=aab42fb6856dc99be46f00bb333e8a6f 1650w, https://mintcdn.com/dripart/OltlUSVBSNcJsDMs/images/tutorial/controlnet/apply_controlnet_chain_link.jpg?w=2500&fit=max&auto=format&n=OltlUSVBSNcJsDMs&q=85&s=c8dee2a84c69fc57166788cae6387f17 2500w" /></p><Note>  你也许会在有些早期的工作流中看到如下的`Apply ControlNet(Old)` 节点，这个节点是早期 ControlNet 的节点，目前已弃用状态，默认在搜索和节点列表不可见  <img src="https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg?fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=eaf2f8df7456df845f7408495d19b9e8" alt="apply controlnet old" data-og-width="778" width="778" data-og-height="370" height="370" data-path="images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg?w=280&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=d1b70261b17b6e3b46c4ed91e1be1fd4 280w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg?w=560&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=9f81de62d9574bcb8b0519488cdc4195 560w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg?w=840&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=b0878d93dea28563986e3a1e2c77450b 840w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg?w=1100&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=a5d3fdd9887f00d55fc68161fbed2ca6 1100w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg?w=1650&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=e34942778977bc4a0898c09123123b26 1650w, https://mintcdn.com/dripart/Rig0_LOInmwVbVSB/images/comfy_core/conditioning/controlnet/apply_controlnet_old.jpg?w=2500&fit=max&auto=format&n=Rig0_LOInmwVbVSB&q=85&s=11a8f3eb731d988689ce245a0a327d8d 2500w" />  如需启用，请在**设置**--> **comfy** --> **Node** 中，启用`Show deprecated nodes in search` 选项，推荐使用新节点</Note><h2 id="开始你的尝试"><a href="#开始你的尝试" class="headerlink" title="开始你的尝试"></a>开始你的尝试</h2><ol><li>试着制作类似的涂鸦图片，甚至自己手绘，并使用 ControlNet 模型生成图像，体验 ControlNet 带来的乐趣</li><li>调整 Apply ControlNet 节点的 <code>Control Strength</code> 参数，来控制 ControlNet 模型对生成图像的影响</li><li>访问 <a href="https://huggingface.co/comfyanonymous/ControlNet-v1-1_fp16_safetensors/tree/main">ControlNet-v1-1_fp16_safetensors</a>  仓库下载其它类型的 ControlNet 模型，并尝试使用它们生成图像</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker安装</title>
    <link href="/2024/11/07/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2024/11/07/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><h2 id="一、文件检查"><a href="#一、文件检查" class="headerlink" title="一、文件检查"></a>一、文件检查</h2><ul><li>docker-18.09.9.tgz (docker安装包linux(x86_64))</li><li>ubuntu14qt5.tar（含Qt5.12.6的镜像文件）</li></ul><h2 id="二、环境检查"><a href="#二、环境检查" class="headerlink" title="二、环境检查"></a>二、环境检查</h2><ul><li>linux x86_64(含麒麟)</li></ul><h2 id="三、安装步骤"><a href="#三、安装步骤" class="headerlink" title="三、安装步骤"></a>三、安装步骤</h2><p>为了方便一些操作，建议直接使用管理员权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo su<br></code></pre></td></tr></table></figure><p>输入密码</p><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1.安装docker"></a>1.安装docker</h3><h4 id="1-1-解压docker"><a href="#1-1-解压docker" class="headerlink" title="1.1 解压docker"></a>1.1 解压docker</h4><p>在docker-18.09.9.tgz所在文件夹下，右键选择打开终端，输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">tar -zxvf docker-18.09.9.tgz<br></code></pre></td></tr></table></figure><h4 id="1-2-将解压之后的docker文件移到-usr-bin目录下"><a href="#1-2-将解压之后的docker文件移到-usr-bin目录下" class="headerlink" title="1.2 将解压之后的docker文件移到 &#x2F;usr&#x2F;bin目录下"></a>1.2 将解压之后的docker文件移到 &#x2F;usr&#x2F;bin目录下</h4><p>这里要将文件复制到<code>/usr/bin/</code>目录下，需要管理员权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp docker/* /usr/bin/<br></code></pre></td></tr></table></figure><h4 id="1-3-将docker注册成系统服务"><a href="#1-3-将docker注册成系统服务" class="headerlink" title="1.3 将docker注册成系统服务"></a>1.3 将docker注册成系统服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/systemd/system/docker.service<br></code></pre></td></tr></table></figure><p>然后在文件中添加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=Docker Application Container Engine<br>Documentation=https://docs.docker.com<br>After=network-online.target firewalld.service<br>Wants=network-online.target<br><br>[Service]<br>Type=notify<br>ExecStart=/usr/bin/dockerd<br>ExecReload=/bin/kill -s HUP $MAINPID<br>LimitNOFILE=infinity<br>LimitNPROC=infinity<br>TimeoutStartSec=0<br>Delegate=yes<br>KillMode=process<br>Restart=on-failure<br>StartLimitBurst=3<br>StartLimitInterval=60s<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><h4 id="1-4-给文件增加可执行权限"><a href="#1-4-给文件增加可执行权限" class="headerlink" title="1.4 给文件增加可执行权限"></a>1.4 给文件增加可执行权限</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x /etc/systemd/system/docker.service<br>systemctl daemon-reload <br></code></pre></td></tr></table></figure><h4 id="1-5-设置开机自启动"><a href="#1-5-设置开机自启动" class="headerlink" title="1.5 设置开机自启动"></a>1.5 设置开机自启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable docker.service<br></code></pre></td></tr></table></figure><h4 id="1-6-启动docker"><a href="#1-6-启动docker" class="headerlink" title="1.6 启动docker"></a>1.6 启动docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start docker<br></code></pre></td></tr></table></figure><h4 id="1-7-查看docker的运行状态"><a href="#1-7-查看docker的运行状态" class="headerlink" title="1.7 查看docker的运行状态"></a>1.7 查看docker的运行状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status docker<br></code></pre></td></tr></table></figure><p>当出现active(running)，表示docker安装成功，并且成功运行<br><img src="/images/image-20241107092716798.png" alt="image-20241107092716798"></p><h3 id="2、导入镜像文件"><a href="#2、导入镜像文件" class="headerlink" title="2、导入镜像文件"></a>2、导入镜像文件</h3><h4 id="2-1-检查文件目录"><a href="#2-1-检查文件目录" class="headerlink" title="2.1 检查文件目录"></a>2.1 检查文件目录</h4><p>检查是否在镜像文件所在目录，不在就通过<code>cd</code>命令切换目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls<br></code></pre></td></tr></table></figure><p><img src="/images/image-20241107093358006.png" alt="image-20241107093358006"> </p><h4 id="2-2-载入镜像文件"><a href="#2-2-载入镜像文件" class="headerlink" title="2.2 载入镜像文件"></a>2.2 载入镜像文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load &lt; ubuntu14qt5.tar<br></code></pre></td></tr></table></figure><p><img src="/images/image-20241107093539735.png" alt="image-20241107093539735"> </p><h4 id="2-3-检查当前镜像是否载入成功"><a href="#2-3-检查当前镜像是否载入成功" class="headerlink" title="2.3 检查当前镜像是否载入成功"></a>2.3 检查当前镜像是否载入成功</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">docker images<br></code></pre></td></tr></table></figure><ul><li>REPOSITORY：镜像名称</li><li>TAG：版本号</li><li>IMAGEID：镜像编号</li><li>CREATE：镜像的创建时间</li><li>SIZE：镜像的大小<br><img src="/images/image-20241107093704693.png" alt="image-20241107093704693"></li></ul><h4 id="2-4-创建并运行容器"><a href="#2-4-创建并运行容器" class="headerlink" title="2.4 创建并运行容器"></a>2.4 创建并运行容器</h4><p>这个命令会以 ID 为 <code>205c2917b8cc</code>(按照实际情况来填写) 的镜像创建并运行一个容器，并将该容器命名为 <code>UbuntuName</code>(按照需要来填写) 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -i -t --name UbuntuName 205c2917b8cc <br></code></pre></td></tr></table></figure><ul><li><p><strong><code>docker run</code></strong>：用于 <strong>创建并启动一个新容器</strong>。<code>docker run</code> 会根据指定的镜像创建一个新的容器，并立即启动该容器。</p></li><li><p><strong><code>-i</code></strong> (interactive)：这个选项用于保持容器的 <strong>标准输入</strong> 打开，允许用户与容器进行交互。通常与 <code>-t</code> 一起使用，以便启动一个交互式会话。</p></li><li><p><strong><code>-t</code></strong> (tty)：分配一个 <strong>伪终端</strong>（TTY），让容器的输出能够显示在终端中。这样，就能看到容器的输出并与它交互。</p></li><li><p><strong><code>--name UbuntuName</code></strong>：为容器指定一个 <strong>名称</strong>，在这里容器的名称是 <code>UbuntuName</code>。如果不使用 <code>--name</code>，Docker 会自动为容器分配一个随机名称。使用 <code>--name</code> 可以方便地管理容器。</p></li><li><p><strong><code>205c2917b8cc</code></strong>：这是 <strong>镜像 ID</strong>，它标识了用于创建容器的镜像。此处的 <code>205c2917b8cc</code> 是某个已存在镜像的 ID，通常也可以使用镜像的名称（如 <code>ubuntu</code>）代替这个 ID。</p></li></ul><p><em><strong>注：如果需要端口映射和挂载等其它创建方式，请看后面docker详解</strong></em></p><h4 id="2-5-进入容器后"><a href="#2-5-进入容器后" class="headerlink" title="2.5 进入容器后"></a>2.5 进入容器后</h4><p>Qt环境目录（&#x2F;home&#x2F;qt）</p><p><img src="/images/image-20241107102524565.png" alt="image-20241107102524565"> </p><p>当前QT暂时只支持运行命令栏，不支持运行GUI界面程序</p><p>demo文件夹下有个demo，是一个简单的Qt程序，可直接运行</p><p><img src="/images/image-20241107102918327.png" alt="image-20241107102918327"> </p><h4 id="2-6-复制主机文件（夹）到容器中"><a href="#2-6-复制主机文件（夹）到容器中" class="headerlink" title="2.6 复制主机文件（夹）到容器中"></a>2.6 复制主机文件（夹）到容器中</h4><p>docker cp &#x2F;home&#x2F;user&#x2F;testdemo  &lt;容器ID&gt;:&#x2F;home&#x2F;demo&#x2F;tesodemo</p><p>​  源路径                                                 目标路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /home/user/testdemo  84d78c364d5c:/home/demo/tesodemo <br>docker cp 84d78c364d5c::/home/demo/tesodemo /home/user/testdemo<br></code></pre></td></tr></table></figure><h4 id="2-7-退出容器"><a href="#2-7-退出容器" class="headerlink" title="2.7 退出容器"></a>2.7 退出容器</h4><p><code>exit</code></p><h4 id="2-8-启动容器"><a href="#2-8-启动容器" class="headerlink" title="2.8 启动容器"></a>2.8 启动容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 84d78c364d5c<br></code></pre></td></tr></table></figure><h4 id="2-9-进入容器"><a href="#2-9-进入容器" class="headerlink" title="2.9 进入容器"></a>2.9 进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 84d78c364d5c bash<br></code></pre></td></tr></table></figure><h4 id="2-10-Qt环境变量说明"><a href="#2-10-Qt环境变量说明" class="headerlink" title="2.10 Qt环境变量说明"></a>2.10 Qt环境变量说明</h4><p>关于当前镜像文件的Qt环境变量说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export QTDIR=/home/qt5.12/Qt5.12.6/5.12.6/gcc_64/<br>export PATH=$QTDIR/bin:$PATH<br>export MANPATH=$QTDIR/man:$MANPATH<br>export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH<br></code></pre></td></tr></table></figure><p>环境变量已加入开机启动项，开机环境变量生效，qt程序可直接在容器任意文件路径运行</p><h2 id="四、docker详解"><a href="#四、docker详解" class="headerlink" title="四、docker详解"></a>四、docker详解</h2><p>只阐述离线情况下的docker用法，在线的不做特殊说明</p><h3 id="1-docker概念"><a href="#1-docker概念" class="headerlink" title="1  docker概念"></a>1  docker概念</h3><ul><li><p>Docker 是一个开源的应用容器引擎</p></li><li><p>诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc）</p></li><li><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。</p></li><li><p>容器是完全使用沙箱机制，相互隔离</p></li><li><p>容器性能开销极低。</p></li><li><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p></li></ul><h3 id="2-docker架构"><a href="#2-docker架构" class="headerlink" title="2 docker架构"></a>2 docker架构</h3><p><img src="/images/image-20241107105026490.png" alt="image-20241107105026490"> </p><ul><li><p>**镜像（Image）：**Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p></li><li><p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></li><li><p><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</p></li></ul><h3 id="3-安装docker"><a href="#3-安装docker" class="headerlink" title="3 安装docker"></a>3 安装docker</h3><p>见 第三章 第一点</p><h3 id="4-docker进程相关的命令"><a href="#4-docker进程相关的命令" class="headerlink" title="4 docker进程相关的命令"></a>4 docker进程相关的命令</h3><ul><li>启动docker服务:   <strong>systemctl start docker</strong> </li><li>停止docker服务:   <strong>systemctl stop docker</strong> </li><li>重启docker服务:   <strong>systemctl restart docker</strong></li><li>查看docker服务状态:     <strong>systemctl status docker</strong> </li><li>设置开机启动docker服务:    <strong>systemctl enable docker</strong></li></ul><h3 id="5-docker-镜像相关命令"><a href="#5-docker-镜像相关命令" class="headerlink" title="5 docker 镜像相关命令"></a>5 <strong>docker</strong> <strong>镜像相关命令</strong></h3><ul><li>从文件导入镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load &lt; 镜像文件名<br></code></pre></td></tr></table></figure><ul><li>查看镜像: 查看本地所有的镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br>docker images -q # 查看所用镜像的id,注意：这里用英文的短破折号，不然显示不了镜像id<br></code></pre></td></tr></table></figure><ul><li><del>搜索镜像:从网络中查找需要的镜像(暂时不用)</del></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search 镜像名称<br></code></pre></td></tr></table></figure><ul><li><p><del>拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。</del></p><p>  <del>如果不知道镜像版本，可以去docker hub 搜索对应镜像查看(暂时不用)</del></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 镜像名称<br></code></pre></td></tr></table></figure><ul><li>删除镜像: 删除本地镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi 镜像id # 删除指定本地镜像<br>docker rmi `docker images -q`  # 删除所有本地镜像<br></code></pre></td></tr></table></figure><ul><li>制作镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit 容器id 镜像名称:版本号  # 通过容器制作镜像<br>docker save -o 压缩文件名称 镜像名称:版本号 # 通过镜像制作镜像文件<br></code></pre></td></tr></table></figure><h3 id="6-docker容器相关命令"><a href="#6-docker容器相关命令" class="headerlink" title="6 docker容器相关命令"></a>6 docker容器相关命令</h3><ul><li>查看容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps # 查看正在运行的容器<br>docker ps –a # 查看所有容器<br></code></pre></td></tr></table></figure><ul><li>创建并启动容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run 参数<br></code></pre></td></tr></table></figure><p>参数说明：</p><p>**-i：**保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</p><p>**-t：**为容器重新分配一个伪输入终端，通常与 -i 同时使用。</p><p>**-d：**以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</p><p><strong>-it</strong> 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</p><p><strong>-p &lt;宿主机端口&gt;:&lt;容器端口&gt;</strong>    用于端口映射，可加多个参数，如：<code>-p &lt;宿主机端口1&gt;:&lt;容器端口1&gt;  -p &lt;宿主机端口2&gt;:&lt;容器端口2&gt;</code></p><p>**–name：**为创建的容器命名。</p><ul><li>进入容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec 参数 # 退出容器，容器不会关闭<br></code></pre></td></tr></table></figure><ul><li>停止容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop 容器名称<br></code></pre></td></tr></table></figure><ul><li>启动容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器名称<br></code></pre></td></tr></table></figure><ul><li>删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器名称<br></code></pre></td></tr></table></figure><ul><li>查看容器信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 容器名称<br></code></pre></td></tr></table></figure><h3 id="7-Docker-容器的数据卷"><a href="#7-Docker-容器的数据卷" class="headerlink" title="7 Docker 容器的数据卷"></a>7 <strong>Docker</strong> 容器的数据卷</h3><h4 id="7-1-数据卷"><a href="#7-1-数据卷" class="headerlink" title="7.1 数据卷"></a>7.1 数据卷</h4><p>数据卷是 Docker 提供的一种机制，用于在容器之间共享和持久化数据。它是一个独立于容器生命周期的特殊目录，存储在宿主机上。数据卷可以被多个容器挂载，并在容器之间共享数据。(会读写冲突)</p><p><strong>数据卷</strong></p><ul><li><p>数据卷是宿主机中的一个目录或文件</p></li><li><p>当容器目录和数据卷目录绑定后，对方的修改会立即同步</p></li><li><p>一个数据卷可以被多个容器同时挂载</p></li><li><p>一个容器也可以被挂载多个数据卷</p></li></ul><p><strong>数据卷作用</strong></p><ul><li><p>容器数据持久化</p></li><li><p>外部机器和容器间接通信</p></li><li><p>容器之间数据交换</p></li></ul><p><strong>配置数据卷</strong></p><ul><li>创建启动容器时，使用 –v 参数 设置数据卷</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run ... –v 宿主机目录(文件):容器内目录(文件) ... <br></code></pre></td></tr></table></figure><ul><li>注意事项：<ol><li>目录必须是绝对路径</li><li>如果目录不存在，会自动创建</li><li>可以挂载多个数据卷</li></ol></li></ul><p><img src="/images/image-20241107111739809.png" alt="image-20241107111739809"> </p><h4 id="7-2-数据卷容器"><a href="#7-2-数据卷容器" class="headerlink" title="7.2 数据卷容器"></a>7.2 <strong>数据卷容器</strong></h4><p>数据卷容器是一个特殊的容器，它只用于管理数据卷，并且不运行任何应用程序。它的主要作用是 <strong>持有</strong> 数据卷并作为数据卷的管理者，其他容器通过挂载到数据卷容器来访问数据卷。（也不能解决读写冲突）</p><p><img src="/images/image-20241107112333414.png" alt="image-20241107112333414"> </p><ul><li><p><strong>配置数据卷容器</strong></p><ol><li>创建启动c3数据卷容器，使用 –v 参数 设置数据卷</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run –it --name=c3 –v /volume centos:7 /bin/bash<br></code></pre></td></tr></table></figure><ol start="2"><li>创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷(继承)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash<br>docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash  <br></code></pre></td></tr></table></figure></li></ul><h3 id="8-dockerfile"><a href="#8-dockerfile" class="headerlink" title="8 dockerfile"></a>8 dockerfile</h3><h4 id="8-1-docker-镜像原理"><a href="#8-1-docker-镜像原理" class="headerlink" title="8.1 docker 镜像原理"></a>8.1 <strong>docker</strong> <strong>镜像原理</strong></h4><p>操作系统组成部分：</p><ul><li><p>进程调度子系统</p></li><li><p>进程通信子系统</p></li><li><p>内存管理子系统</p></li><li><p>设备管理子系统</p></li><li><p>文件管理子系统</p></li><li><p>网络通信子系统</p></li><li><p>作业控制子系统</p></li></ul><p>Linux文件系统由bootfs和rootfs两部分组成</p><ul><li><p>bootfs：包含bootloader（引导加载程序）和 kernel（内核）</p></li><li><p>rootfs： root文件系统，包含的就是典型 Linux 系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件</p></li><li><p>不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等</p></li></ul><p><img src="/images/image-20241107113015782.png" alt="image-20241107113015782"> </p><ul><li><p>Docker镜像是由特殊的文件系统叠加而成</p></li><li><p>最底端是 bootfs，并使用宿主机的bootfs </p></li><li><p>第二层是 root文件系统rootfs,称为base image</p></li><li><p>然后再往上可以叠加其他的镜像文件</p></li><li><p>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</p></li><li><p>一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。</p></li><li><p>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</p></li></ul><p><img src="/images/image-20241107113304607.png" alt="image-20241107113304607"> </p><ul><li><p>Docker 镜像本质是什么？</p><ul><li>是一个分层文件系统</li></ul></li><li><p>Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？</p><ul><li>是一个分层文件系统</li></ul></li><li><p>Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？</p><ul><li>由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小500多MB</li></ul></li></ul><h4 id="8-2-dockerfile-概念"><a href="#8-2-dockerfile-概念" class="headerlink" title="8.2 dockerfile 概念"></a>8.2 <strong>dockerfile</strong> <strong>概念</strong></h4><ul><li><p>Dockerfile 是一个文本文件</p></li><li><p>包含了一条条的指令</p></li><li><p>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</p></li><li><p>对于开发人员：可以为开发团队提供一个完全一致的开发环境</p></li><li><p>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了</p></li><li><p>对于运维人员：在部署时，可以实现应用的无缝移植</p></li></ul><h4 id="8-3-Dockerfile-关键字"><a href="#8-3-Dockerfile-关键字" class="headerlink" title="8.3 Dockerfile 关键字"></a>8.3 <strong>Dockerfile</strong> <strong>关键字</strong></h4><table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是&#x2F;bin&#x2F;sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name&#x3D;value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080&#x2F;udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F; 使用的是绝对地址 如果不是&#x2F;开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table><h4 id="8-4-dockfle例子"><a href="#8-4-dockfle例子" class="headerlink" title="8.4 dockfle例子"></a>8.4 dockfle例子</h4><h5 id="8-4-1-例子"><a href="#8-4-1-例子" class="headerlink" title="8.4.1 例子"></a>8.4.1 例子</h5><p>下面是一个基于 <strong>MySQL</strong> 镜像的 Dockerfile 示例，演示了如何使用 MySQL 镜像并配置数据库。(只作为参考)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用官方的 MySQL 镜像作为基础镜像</span><br>FROM mysql:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置环境变量，初始化数据库时设置 root 用户的密码</span><br>ENV MYSQL_ROOT_PASSWORD=rootpassword<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个自定义的数据库（可选）</span><br>ENV MYSQL_DATABASE=mydatabase<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以设置默认的数据库用户和密码（可选）</span><br>ENV MYSQL_USER=myuser<br>ENV MYSQL_PASSWORD=mypassword<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">暴露容器的 3306 端口，MySQL 默认使用该端口</span><br>EXPOSE 3306<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用默认的 MySQL 启动命令，无需指定，官方镜像会自动启动</span><br>CMD [&quot;mysqld&quot;]<br></code></pre></td></tr></table></figure><h5 id="8-4-2-使用例子"><a href="#8-4-2-使用例子" class="headerlink" title="8.4.2 使用例子"></a>8.4.2 使用例子</h5><p><strong>构建和运行镜像</strong></p><ul><li>构建镜像</li></ul><p>在包含 Dockerfile 的目录中运行以下命令来构建 MySQL 镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t my-mysql-image .<br></code></pre></td></tr></table></figure><p>这将构建一个名为 <code>my-mysql-image</code> 的 MySQL 镜像。</p><ul><li>运行容器</li></ul><p>使用以下命令来运行 MySQL 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 3306:3306 --name my-mysql-container my-mysql-image<br></code></pre></td></tr></table></figure><p><code>-d</code>：在后台运行容器。</p><p><code>-p 3306:3306</code>：将宿主机的 <code>3306</code> 端口映射到容器的 <code>3306</code> 端口。</p><p><code>--name my-mysql-container</code>：为容器指定一个名字。</p><p><code>my-mysql-image</code>：运行我们刚刚构建的镜像。</p><ul><li>连接 MySQL</li></ul><p>容器启动后，可以通过以下命令连接到 MySQL 数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it my-mysql-container mysql -u root -p<br><br></code></pre></td></tr></table></figure><p>然后输入在 <code>MYSQL_ROOT_PASSWORD</code> 中设置的密码（在这个示例中是 <code>rootpassword</code>）。</p><h2 id="五、部分常见错误"><a href="#五、部分常见错误" class="headerlink" title="五、部分常见错误"></a>五、部分常见错误</h2><p>无权限，需要切换到管理员权限再执行命令：<code>sudo su</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/json: dial unix /var/run/docker.sock: connect: permission denied<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 23 种 设计模式</title>
    <link href="/2024/10/26/C++23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/10/26/C++23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-23-种-设计模式"><a href="#C-23-种-设计模式" class="headerlink" title="C++ 23 种 设计模式"></a>C++ 23 种 设计模式</h1><h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><p>创建型模式关注对象的创建过程，旨在将对象的创建与使用解耦。</p><h3 id="1-单例模式（Singleton）"><a href="#1-单例模式（Singleton）" class="headerlink" title="1.单例模式（Singleton）"></a>1.单例模式（Singleton）</h3><p>确保一个类只有一个实例，并提供全局访问点。</p><p>单例模式（Singleton Pattern）是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点来获取该实例。这种模式通常用于需要<strong>全局共享资源</strong>或<strong>唯一实例</strong>的场景，比如配置管理类、日志记录类、连接池等。</p><h4 id="1-1-单例模式的核心要点"><a href="#1-1-单例模式的核心要点" class="headerlink" title="1.1 单例模式的核心要点"></a>1.1 单例模式的核心要点</h4><ul><li><strong>唯一性</strong>：确保某个类只能有一个实例。</li><li><strong>全局访问点</strong>：提供一个全局方法获取该实例。</li><li><strong>延迟实例化</strong>：实例在首次使用时创建，避免不必要的资源开销。</li></ul><h4 id="1-2-单例模式的实现方式"><a href="#1-2-单例模式的实现方式" class="headerlink" title="1.2 单例模式的实现方式"></a>1.2 单例模式的实现方式</h4><p>在C++中，单例模式实现可以用多种方法，下面主要介绍最常见的几种实现方式。</p><h5 id="1-2-1-饿汉式单例（Eager-Initialization）"><a href="#1-2-1-饿汉式单例（Eager-Initialization）" class="headerlink" title="1.2.1 饿汉式单例（Eager Initialization）"></a>1.2.1 饿汉式单例（Eager Initialization）</h5><p>在类加载时直接创建实例，线程安全，但是可能会造成资源浪费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">// 私有构造函数，防止外部实例化</span><br><br>    <span class="hljs-type">static</span> Singleton instance; <span class="hljs-comment">// 静态实例，程序启动时创建</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;)             = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁止拷贝构造</span><br>    Singleton &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 禁止赋值</span><br><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton &amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 执行单例类的一些操作</span><br>    &#125;<br>&#125;;<br><br>Singleton Singleton::instance; <span class="hljs-comment">// 静态实例定义</span><br></code></pre></td></tr></table></figure><p><strong>优点</strong>：实现简单，线程安全。<br><strong>缺点</strong>：类加载时即创建实例，即使不使用也会占用资源。</p><h5 id="1-2-2-懒汉式单例（Lazy-Initialization）"><a href="#1-2-2-懒汉式单例（Lazy-Initialization）" class="headerlink" title="1.2.2 懒汉式单例（Lazy Initialization）"></a>1.2.2 懒汉式单例（Lazy Initialization）</h5><p>实例在首次使用时创建，节省资源，但需要处理多线程并发访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-type">static</span> Singleton * instance;<br>    <span class="hljs-type">static</span> std::mutex  mtx;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;)             = <span class="hljs-keyword">delete</span>;<br>    Singleton &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton * <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!instance)<br>        &#123; <span class="hljs-comment">// 第一次检测</span><br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>            <span class="hljs-keyword">if</span> (!instance)<br>            &#123; <span class="hljs-comment">// 第二次检测</span><br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br><br>Singleton * Singleton::instance = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 静态成员定义</span><br>std::mutex  Singleton::mtx;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：实例按需创建，节省资源。<br><strong>缺点</strong>：实现稍复杂，多线程下需要双重检查锁机制确保线程安全。</p><h5 id="1-2-3-使用C-11标准的线程安全局部静态变量"><a href="#1-2-3-使用C-11标准的线程安全局部静态变量" class="headerlink" title="1.2.3 使用C++11标准的线程安全局部静态变量"></a>1.2.3 使用C++11标准的线程安全局部静态变量</h5><p>C++11引入了<strong>线程安全的局部静态变量</strong>，可以简化懒汉式单例的实现，无需手动加锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;)             = <span class="hljs-keyword">delete</span>;<br>    Singleton &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton &amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：实现简单、线程安全、支持懒加载。<br><strong>缺点</strong>：依赖C++11标准</p><h5 id="1-2-4-单例模式的析构问题"><a href="#1-2-4-单例模式的析构问题" class="headerlink" title="1.2.4 单例模式的析构问题"></a>1.2.4 单例模式的析构问题</h5><p>单例类的实例通常设计为在程序结束时自动释放。常见方法是定义一个静态成员对象，确保在程序退出时释放单例实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;)             = <span class="hljs-keyword">delete</span>;<br>    Singleton &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton &amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h4><ul><li><strong>配置管理类</strong>：系统级配置信息通常需要全局访问和唯一性。</li><li><strong>日志管理类</strong>：集中化的日志记录，通过单例模式确保所有模块的日志输出一致。</li><li><strong>资源管理类</strong>：连接池、线程池等需要统一管理的资源。</li><li><strong>计数器类</strong>：全局计数器或统计类确保在不同模块间共享数据。</li></ul><h4 id="1-4-单例模式的优缺点"><a href="#1-4-单例模式的优缺点" class="headerlink" title="1.4 单例模式的优缺点"></a>1.4 单例模式的优缺点</h4><p><strong>优点</strong>：</p><ul><li>提供全局访问点，减少全局变量的使用。</li><li>控制实例创建的数量，节省系统资源。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不支持多态</strong>：单例模式限制了继承的灵活性，难以支持多态。</li><li><strong>隐藏依赖关系</strong>：过多的单例会使模块间依赖变得复杂且难以检测，影响代码的维护和测试。</li></ul><h3 id="2-工厂方法（Factory-Method）"><a href="#2-工厂方法（Factory-Method）" class="headerlink" title="2.工厂方法（Factory Method）"></a>2.工厂方法（Factory Method）</h3><p>定义一个用于创建对象的接口，但由子类决定实例化的类。</p><p>工厂方法模式（Factory Method Pattern）是一种<strong>创建型设计模式</strong>，用于定义一个创建对象的接口，但让子类决定实例化哪一个具体类。工厂方法将对象的创建逻辑延迟到子类，符合<strong>开闭原则</strong>（对扩展开放，对修改封闭），能够更灵活地管理和扩展代码。</p><h4 id="2-1-工厂方法模式的组成"><a href="#2-1-工厂方法模式的组成" class="headerlink" title="2.1 工厂方法模式的组成"></a>2.1 工厂方法模式的组成</h4><p>工厂方法模式通常由以下几部分组成：</p><ol><li><strong>产品接口（Product）</strong>：定义了所有产品的共有接口，这样可以让工厂方法创建的对象具有一致的接口。</li><li><strong>具体产品（Concrete Product）</strong>：实现产品接口的类，代表具体的产品。</li><li><strong>工厂接口（Creator）</strong>：声明了一个工厂方法用于创建产品对象。工厂方法的返回类型通常是产品接口类型。</li><li><strong>具体工厂（Concrete Creator）</strong>：实现工厂接口，并定义具体产品的实例化方法。</li></ol><h4 id="2-2-工厂方法模式示例"><a href="#2-2-工厂方法模式示例" class="headerlink" title="2.2 工厂方法模式示例"></a>2.2 工厂方法模式示例</h4><p>假设我们有一个应用程序，需要根据不同的需求创建不同类型的日志记录器（如文件日志记录器和控制台日志记录器），可以使用工厂方法模式来实现。</p><h5 id="2-2-1-定义产品接口"><a href="#2-2-1-定义产品接口" class="headerlink" title="2.2.1 定义产品接口"></a>2.2.1 定义产品接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; message)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Logger</span>()                             = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2-2-2-实现具体产品"><a href="#2-2-2-实现具体产品" class="headerlink" title="2.2.2 实现具体产品"></a>2.2.2 实现具体产品</h5><p>实现两种具体的日志记录器：<code>FileLogger</code> 和 <code>ConsoleLogger</code>，它们都实现了 <code>Logger</code> 接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> : <span class="hljs-keyword">public</span> Logger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟写入文件日志</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging to a file: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> : <span class="hljs-keyword">public</span> Logger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟输出到控制台</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Logging to console: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="2-2-3-定义工厂接口"><a href="#2-2-3-定义工厂接口" class="headerlink" title="2.2.3 定义工厂接口"></a>2.2.3 定义工厂接口</h5><p>定义一个工厂类，声明创建日志记录器的接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Logger* <span class="hljs-title">createLogger</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 工厂方法</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">LoggerFactory</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="2-2-4-实现具体工厂"><a href="#2-2-4-实现具体工厂" class="headerlink" title="2.2.4 实现具体工厂"></a>2.2.4 实现具体工厂</h5><p>具体工厂类分别创建不同类型的日志记录器实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLoggerFactory</span> : <span class="hljs-keyword">public</span> LoggerFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Logger* <span class="hljs-title">createLogger</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileLogger</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLoggerFactory</span> : <span class="hljs-keyword">public</span> LoggerFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Logger* <span class="hljs-title">createLogger</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConsoleLogger</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="2-2-5-客户端代码"><a href="#2-2-5-客户端代码" class="headerlink" title="2.2.5 客户端代码"></a>2.2.5 客户端代码</h5><p>客户端使用工厂类来创建特定的日志记录器，而不需要直接依赖具体的日志记录器类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clientCode</span><span class="hljs-params">(LoggerFactory&amp; factory)</span> </span>&#123;<br>    Logger* logger = factory.<span class="hljs-built_in">createLogger</span>(); <span class="hljs-comment">// 获取特定的 Logger</span><br>    logger-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;This is a test log message.&quot;</span>);<br>    <span class="hljs-keyword">delete</span> logger;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    FileLoggerFactory fileLoggerFactory;<br>    ConsoleLoggerFactory consoleLoggerFactory;<br><br>    <span class="hljs-built_in">clientCode</span>(fileLoggerFactory);      <span class="hljs-comment">// 使用文件日志记录器</span><br>    <span class="hljs-built_in">clientCode</span>(consoleLoggerFactory);    <span class="hljs-comment">// 使用控制台日志记录器</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-3-工厂方法模式的优缺点"><a href="#2-3-工厂方法模式的优缺点" class="headerlink" title="2.3 工厂方法模式的优缺点"></a>2.3 工厂方法模式的优缺点</h4><p><strong>优点</strong>：</p><ul><li><strong>符合开闭原则</strong>：通过引入新产品子类和对应的具体工厂类，可以在不修改现有代码的情况下添加新功能。</li><li><strong>减少耦合</strong>：客户端代码通过工厂接口创建产品对象，而不是依赖于具体产品类。</li><li><strong>增强扩展性</strong>：可以通过创建新的工厂类和产品类，轻松添加新的产品类型。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>增加类的数量</strong>：每增加一种新的产品类型，就需要添加一个具体产品类和对应的工厂类。</li><li><strong>系统复杂度增加</strong>：因为每个具体工厂仅负责一个具体产品的创建，类的数量增多，增加了系统维护成本。</li></ul><h4 id="2-4-工厂方法模式的适用场景"><a href="#2-4-工厂方法模式的适用场景" class="headerlink" title="2.4 工厂方法模式的适用场景"></a>2.4 工厂方法模式的适用场景</h4><ul><li><strong>需要创建复杂对象</strong>：当对象的创建逻辑复杂且需要复用时。</li><li><strong>增加灵活性</strong>：不想让客户端代码依赖于具体类，避免代码频繁修改。</li><li><strong>希望根据条件创建不同对象</strong>：例如根据配置、参数等条件动态决定实例化哪种对象。</li></ul><h3 id="3-抽象工厂（Abstract-Factory）"><a href="#3-抽象工厂（Abstract-Factory）" class="headerlink" title="3.抽象工厂（Abstract Factory）"></a>3.抽象工厂（Abstract Factory）</h3><p>提供一个接口，用于创建一系列相关或依赖的对象，而无需指定具体类。</p><p>抽象工厂模式（Abstract Factory Pattern）是一种<strong>创建型设计模式</strong>，用于创建一组相关或相互依赖的对象，而不指定它们的具体类。抽象工厂模式提供了一个接口来创建<strong>系列相关的对象</strong>，让客户端代码能够使用这些对象而不必关心具体的实现细节。</p><h4 id="3-1-抽象工厂模式的组成"><a href="#3-1-抽象工厂模式的组成" class="headerlink" title="3.1 抽象工厂模式的组成"></a>3.1 抽象工厂模式的组成</h4><p>抽象工厂模式包含以下几个主要部分：</p><ol><li><strong>抽象工厂（Abstract Factory）</strong>：声明了一组用于创建不同系列产品的接口。</li><li><strong>具体工厂（Concrete Factory）</strong>：实现抽象工厂接口，定义创建特定系列产品的方法。</li><li><strong>抽象产品（Abstract Product）</strong>：为产品对象声明接口，使不同的产品实现具有一致性。</li><li><strong>具体产品（Concrete Product）</strong>：实现抽象产品接口，由具体工厂创建，形成同一系列的对象。</li><li><strong>客户端（Client）</strong>：使用抽象工厂和抽象产品接口来生成具体产品对象，无需关心具体工厂和具体产品的实现细节。</li></ol><h4 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h4><p>假设我们要设计一个 UI 工具包，它可以在不同平台上（如 Windows 和 MacOS）创建不同的 UI 元素（如按钮和文本框）。使用抽象工厂模式来创建不同平台的 UI 控件，可以确保在某个平台的控件风格保持一致。</p><h5 id="3-2-1-定义抽象产品接口"><a href="#3-2-1-定义抽象产品接口" class="headerlink" title="3.2.1 定义抽象产品接口"></a>3.2.1 定义抽象产品接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 抽象产品 - 按钮接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Button</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 抽象产品 - 文本框接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TextBox</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="3-2-2-定义具体产品"><a href="#3-2-2-定义具体产品" class="headerlink" title="3.2.2 定义具体产品"></a>3.2.2 定义具体产品</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Windows 平台的具体产品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsButton</span> : <span class="hljs-keyword">public</span> Button &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Render a button in Windows style.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsTextBox</span> : <span class="hljs-keyword">public</span> TextBox &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Render a text box in Windows style.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// MacOS 平台的具体产品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacOSButton</span> : <span class="hljs-keyword">public</span> Button &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Render a button in MacOS style.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacOSTextBox</span> : <span class="hljs-keyword">public</span> TextBox &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Render a text box in MacOS style.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="3-2-3-定义抽象工厂"><a href="#3-2-3-定义抽象工厂" class="headerlink" title="3.2.3 定义抽象工厂"></a>3.2.3 定义抽象工厂</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GUIFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Button* <span class="hljs-title">createButton</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> TextBox* <span class="hljs-title">createTextBox</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">GUIFactory</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="3-2-4-定义具体工厂"><a href="#3-2-4-定义具体工厂" class="headerlink" title="3.2.4 定义具体工厂"></a>3.2.4 定义具体工厂</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsFactory</span> : <span class="hljs-keyword">public</span> GUIFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Button* <span class="hljs-title">createButton</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">WindowsButton</span>();<br>    &#125;<br><br>    <span class="hljs-function">TextBox* <span class="hljs-title">createTextBox</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">WindowsTextBox</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacOSFactory</span> : <span class="hljs-keyword">public</span> GUIFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Button* <span class="hljs-title">createButton</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">MacOSButton</span>();<br>    &#125;<br><br>    <span class="hljs-function">TextBox* <span class="hljs-title">createTextBox</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">MacOSTextBox</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="3-2-5-客户端代码"><a href="#3-2-5-客户端代码" class="headerlink" title="3.2.5 客户端代码"></a>3.2.5 客户端代码</h5><p>客户端代码通过抽象工厂接口创建具体产品，但并不直接依赖于某一平台的具体产品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> GUIFactory&amp; factory)</span> </span>&#123;<br>    Button* button = factory.<span class="hljs-built_in">createButton</span>();<br>    TextBox* textBox = factory.<span class="hljs-built_in">createTextBox</span>();<br><br>    button-&gt;<span class="hljs-built_in">paint</span>();<br>    textBox-&gt;<span class="hljs-built_in">render</span>();<br><br>    <span class="hljs-keyword">delete</span> button;<br>    <span class="hljs-keyword">delete</span> textBox;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 假设当前运行在 Windows 环境</span><br>    WindowsFactory windowsFactory;<br>    <span class="hljs-built_in">clientCode</span>(windowsFactory);<br><br>    <span class="hljs-comment">// 假设当前运行在 MacOS 环境</span><br>    MacOSFactory macFactory;<br>    <span class="hljs-built_in">clientCode</span>(macFactory);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-3-抽象工厂模式的优缺点"><a href="#3-3-抽象工厂模式的优缺点" class="headerlink" title="3.3 抽象工厂模式的优缺点"></a>3.3 抽象工厂模式的优缺点</h4><p><strong>优点</strong>：</p><ul><li><strong>符合开闭原则</strong>：可以在不修改客户端代码的情况下，添加新的产品族或平台。</li><li><strong>保证产品族的一致性</strong>：适用于要求一组对象（产品族）在一起使用，确保相同风格或一致性的场景。</li><li><strong>简化客户端代码</strong>：客户端代码不直接依赖具体产品类，仅依赖抽象工厂和抽象产品接口，减少耦合。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>复杂性增加</strong>：增加了类的数量，可能会让系统结构复杂。</li><li><strong>难以支持新产品</strong>：如果需要向现有的产品族中添加新的产品（如新的控件类型），则需要修改所有的具体工厂类，违反开闭原则。</li></ul><h4 id="3-4-适用场景"><a href="#3-4-适用场景" class="headerlink" title="3.4 适用场景"></a>3.4 适用场景</h4><ul><li><strong>需要创建一系列相互关联的对象</strong>：如不同平台的 UI 控件、不同数据库的访问对象等。</li><li><strong>需要保证产品的一致性</strong>：确保客户端始终使用同一产品族，避免跨平台或产品间的兼容性问题。</li></ul><h3 id="4-建造者（Builder）"><a href="#4-建造者（Builder）" class="headerlink" title="4.建造者（Builder）"></a>4.建造者（Builder）</h3><p>分步骤构造复杂对象，将构造与表示分离。</p><p>建造者模式（Builder Pattern）是一种<strong>创建型设计模式</strong>，用于分步骤构建一个复杂对象。建造者模式将对象的构建过程与表示分离，使得相同的构建过程可以创建不同的对象。它特别适合需要按照一系列步骤来创建复杂对象的场景，并且这些对象在创建过程中可能具有不同的表现或配置。</p><h4 id="4-1-建造者模式的组成"><a href="#4-1-建造者模式的组成" class="headerlink" title="4.1 建造者模式的组成"></a>4.1 建造者模式的组成</h4><p>建造者模式由以下几个部分组成：</p><ol><li><strong>产品（Product）</strong>：表示要创建的复杂对象。通常包含多个部件，可以通过建造者逐步构建。</li><li><strong>抽象建造者（Builder）</strong>：定义构建产品各部件的接口，具体部件由其子类实现。</li><li><strong>具体建造者（Concrete Builder）</strong>：实现抽象建造者接口，负责创建和装配具体产品的各个部件。</li><li><strong>指挥者（Director）</strong>：负责按照特定顺序调用建造者的方法，以构建产品。它只关注如何构建产品，而不涉及产品的具体组成细节。</li></ol><h4 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h4><p>假设我们要创建一个包含多个组件的电脑对象（<code>Computer</code>），每个电脑可以由 CPU、GPU、存储设备等组成，不同配置的电脑可能由不同的建造者来构造。</p><h5 id="4-2-1-定义产品类"><a href="#4-2-1-定义产品类" class="headerlink" title="4.2.1 定义产品类"></a>4.2.1 定义产品类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCPU</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; cpu)</span> </span>&#123; CPU = cpu; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGPU</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; gpu)</span> </span>&#123; GPU = gpu; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setStorage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; storage)</span> </span>&#123; Storage = storage; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showSpecs</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Computer specs: CPU = &quot;</span> &lt;&lt; CPU <br>                  &lt;&lt; <span class="hljs-string">&quot;, GPU = &quot;</span> &lt;&lt; GPU <br>                  &lt;&lt; <span class="hljs-string">&quot;, Storage = &quot;</span> &lt;&lt; Storage &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string CPU;<br>    std::string GPU;<br>    std::string Storage;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="4-2-2-定义抽象建造者"><a href="#4-2-2-定义抽象建造者" class="headerlink" title="4.2.2 定义抽象建造者"></a>4.2.2 定义抽象建造者</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputerBuilder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ComputerBuilder</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">buildCPU</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">buildGPU</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">buildStorage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Computer* <span class="hljs-title">getComputer</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="4-2-3-定义具体建造者"><a href="#4-2-3-定义具体建造者" class="headerlink" title="4.2.3 定义具体建造者"></a>4.2.3 定义具体建造者</h5><p>定义具体建造者类，负责创建特定配置的电脑（例如，游戏电脑和办公电脑）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamingComputerBuilder</span> : <span class="hljs-keyword">public</span> ComputerBuilder &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GamingComputerBuilder</span>() &#123; computer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(); &#125;<br>    ~<span class="hljs-built_in">GamingComputerBuilder</span>() &#123; <span class="hljs-keyword">delete</span> computer; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildCPU</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; computer-&gt;<span class="hljs-built_in">setCPU</span>(<span class="hljs-string">&quot;High-end CPU&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGPU</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; computer-&gt;<span class="hljs-built_in">setGPU</span>(<span class="hljs-string">&quot;High-end GPU&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildStorage</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; computer-&gt;<span class="hljs-built_in">setStorage</span>(<span class="hljs-string">&quot;1TB SSD&quot;</span>); &#125;<br><br>    <span class="hljs-function">Computer* <span class="hljs-title">getComputer</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> computer; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Computer* computer;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OfficeComputerBuilder</span> : <span class="hljs-keyword">public</span> ComputerBuilder &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">OfficeComputerBuilder</span>() &#123; computer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(); &#125;<br>    ~<span class="hljs-built_in">OfficeComputerBuilder</span>() &#123; <span class="hljs-keyword">delete</span> computer; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildCPU</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; computer-&gt;<span class="hljs-built_in">setCPU</span>(<span class="hljs-string">&quot;Mid-range CPU&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildGPU</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; computer-&gt;<span class="hljs-built_in">setGPU</span>(<span class="hljs-string">&quot;Integrated GPU&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildStorage</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; computer-&gt;<span class="hljs-built_in">setStorage</span>(<span class="hljs-string">&quot;512GB SSD&quot;</span>); &#125;<br><br>    <span class="hljs-function">Computer* <span class="hljs-title">getComputer</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> computer; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Computer* computer;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="4-2-4-定义指挥者"><a href="#4-2-4-定义指挥者" class="headerlink" title="4.2.4 定义指挥者"></a>4.2.4 定义指挥者</h5><p>指挥者通过调用建造者的方法，按照特定顺序来构造产品。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBuilder</span><span class="hljs-params">(ComputerBuilder* builder)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;builder = builder; &#125;<br><br>    <span class="hljs-function">Computer* <span class="hljs-title">buildComputer</span><span class="hljs-params">()</span> </span>&#123;<br>        builder-&gt;<span class="hljs-built_in">buildCPU</span>();<br>        builder-&gt;<span class="hljs-built_in">buildGPU</span>();<br>        builder-&gt;<span class="hljs-built_in">buildStorage</span>();<br>        <span class="hljs-keyword">return</span> builder-&gt;<span class="hljs-built_in">getComputer</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ComputerBuilder* builder;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="4-2-5-客户端代码"><a href="#4-2-5-客户端代码" class="headerlink" title="4.2.5 客户端代码"></a>4.2.5 客户端代码</h5><p>在客户端代码中，创建不同的建造者，通过指挥者来构造不同配置的电脑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Director director;<br><br>    GamingComputerBuilder gamingBuilder;<br>    director.<span class="hljs-built_in">setBuilder</span>(&amp;gamingBuilder);<br>    Computer* gamingComputer = director.<span class="hljs-built_in">buildComputer</span>();<br>    gamingComputer-&gt;<span class="hljs-built_in">showSpecs</span>();<br>    <span class="hljs-keyword">delete</span> gamingComputer;<br><br>    OfficeComputerBuilder officeBuilder;<br>    director.<span class="hljs-built_in">setBuilder</span>(&amp;officeBuilder);<br>    Computer* officeComputer = director.<span class="hljs-built_in">buildComputer</span>();<br>    officeComputer-&gt;<span class="hljs-built_in">showSpecs</span>();<br>    <span class="hljs-keyword">delete</span> officeComputer;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="4-3-建造者模式的优缺点"><a href="#4-3-建造者模式的优缺点" class="headerlink" title="4.3 建造者模式的优缺点"></a>4.3 建造者模式的优缺点</h4><p><strong>优点</strong>：</p><ul><li><strong>控制构造过程</strong>：可以分步骤创建复杂对象。</li><li><strong>易于扩展</strong>：可以在不修改客户端代码的情况下，创建不同种类的复杂对象。</li><li><strong>解耦构造和表示</strong>：客户端无需关心对象的具体构造细节。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>增加代码复杂度</strong>：需要创建多个具体建造者类，每个建造者负责一种特定的对象创建过程。</li></ul><h4 id="4-4-适用场景"><a href="#4-4-适用场景" class="headerlink" title="4.4 适用场景"></a>4.4 适用场景</h4><ul><li><strong>需要创建复杂对象</strong>：对象的构建过程涉及多个步骤，且这些步骤可以灵活组合。</li><li><strong>需要多种表现形式</strong>：相同的构建过程可以生成不同的表示（不同配置的对象）。</li></ul><h3 id="5-原型（Prototype）"><a href="#5-原型（Prototype）" class="headerlink" title="5.原型（Prototype）"></a>5.原型（Prototype）</h3><p>使用一个现有实例作为原型，复制这个实例生成新对象。</p><p>原型模式（Prototype Pattern）是一种<strong>创建型设计模式</strong>，通过复制（克隆）现有的对象来生成新对象，而不是通过实例化类来创建新对象。原型模式适用于对象的创建成本较高或较复杂的情况，因为它通过复制已有对象的方式快速生成新的实例，避免了反复的初始化操作。</p><h4 id="5-1-原型模式的组成"><a href="#5-1-原型模式的组成" class="headerlink" title="5.1 原型模式的组成"></a>5.1 原型模式的组成</h4><p>原型模式的核心在于复制自身的能力，因此主要包含以下角色：</p><ol><li><strong>原型接口（Prototype Interface）</strong>：定义了克隆自身的方法（通常称为 <code>clone</code>）。</li><li><strong>具体原型（Concrete Prototype）</strong>：实现原型接口，提供复制自身的方法（具体类的克隆逻辑）。</li><li><strong>客户端（Client）</strong>：通过原型接口复制对象，而不是直接调用构造函数来实例化新对象。</li></ol><h4 id="5-2-原型模式的实现"><a href="#5-2-原型模式的实现" class="headerlink" title="5.2 原型模式的实现"></a>5.2 原型模式的实现</h4><p>假设我们有一个“形状”类层次结构，每种形状（如圆形和矩形）都有自己的特性。我们希望能够快速复制这些形状，而不需要从头进行构造。</p><h5 id="5-2-1-定义原型接口"><a href="#5-2-1-定义原型接口" class="headerlink" title="5.2.1 定义原型接口"></a>5.2.1 定义原型接口</h5><p>首先，定义一个原型接口类，并定义一个纯虚函数 <code>clone()</code>，返回类型是当前类的指针，代表生成的克隆对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;Shape&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 克隆方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 具体行为</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="5-2-2-定义具体原型"><a href="#5-2-2-定义具体原型" class="headerlink" title="5.2.2 定义具体原型"></a>5.2.2 定义具体原型</h5><p>继承 <code>Shape</code> 接口，并实现 <code>clone()</code> 方法。在这个方法中创建当前对象的深拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> radius) : <span class="hljs-built_in">radius</span>(radius) &#123;&#125;<br><br>    <span class="hljs-comment">// 实现克隆方法</span><br>    <span class="hljs-function">std::unique_ptr&lt;Shape&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Circle&gt;(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing a Circle with radius &quot;</span> &lt;&lt; radius &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">double</span> width, <span class="hljs-type">double</span> height) : <span class="hljs-built_in">width</span>(width), <span class="hljs-built_in">height</span>(height) &#123;&#125;<br><br>    <span class="hljs-comment">// 实现克隆方法</span><br>    <span class="hljs-function">std::unique_ptr&lt;Shape&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Rectangle&gt;(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing a Rectangle with width &quot;</span> &lt;&lt; width &lt;&lt; <span class="hljs-string">&quot; and height &quot;</span> &lt;&lt; height &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> width;<br>    <span class="hljs-type">double</span> height;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><em>注：<code>std::make_unique</code> 是 C++14 引入的一个函数模板，用于创建一个 <code>std::unique_ptr</code> 对象。<code>std::unique_ptr</code> 是一种智能指针，它管理一个动态分配的对象的生命周期，确保对象在不再使用时自动释放内存，从而避免内存泄漏</em></p><h5 id="5-2-3-客户端代码"><a href="#5-2-3-客户端代码" class="headerlink" title="5.2.3 客户端代码"></a>5.2.3 客户端代码</h5><p>在客户端代码中，可以利用 <code>clone()</code> 方法复制形状对象，而无需了解具体形状的内部实现细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clientCode</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;Shape&gt; circle = std::<span class="hljs-built_in">make_unique</span>&lt;Circle&gt;(<span class="hljs-number">5.0</span>);<br>    std::unique_ptr&lt;Shape&gt; rectangle = std::<span class="hljs-built_in">make_unique</span>&lt;Rectangle&gt;(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>);<br><br>    <span class="hljs-comment">// 克隆对象</span><br>    std::unique_ptr&lt;Shape&gt; anotherCircle = circle-&gt;<span class="hljs-built_in">clone</span>();<br>    std::unique_ptr&lt;Shape&gt; anotherRectangle = rectangle-&gt;<span class="hljs-built_in">clone</span>();<br><br>    <span class="hljs-comment">// 打印输出</span><br>    circle-&gt;<span class="hljs-built_in">draw</span>();<br>    anotherCircle-&gt;<span class="hljs-built_in">draw</span>();<br>    rectangle-&gt;<span class="hljs-built_in">draw</span>();<br>    anotherRectangle-&gt;<span class="hljs-built_in">draw</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">clientCode</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-原型模式的优缺点"><a href="#5-3-原型模式的优缺点" class="headerlink" title="5.3 原型模式的优缺点"></a>5.3 原型模式的优缺点</h4><p><strong>优点</strong>：</p><ul><li><strong>克隆比实例化更高效</strong>：适合用于创建成本高的复杂对象。</li><li><strong>减少子类数量</strong>：可以通过克隆现有对象并修改其属性来创建新对象，而不需要为每种配置创建新子类。</li><li><strong>简化创建过程</strong>：可以在运行时动态决定创建哪些对象的副本。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>深拷贝和浅拷贝问题</strong>：实现 <code>clone()</code> 方法时需要考虑对象的深拷贝或浅拷贝问题，尤其是当对象中包含复杂的动态成员时。</li><li><strong>实现难度较高</strong>：对某些对象，特别是涉及多层嵌套或指针的对象，克隆的实现较为复杂。</li></ul><h4 id="5-4-适用场景"><a href="#5-4-适用场景" class="headerlink" title="5.4 适用场景"></a>5.4 适用场景</h4><ul><li><strong>需要大量相似对象</strong>：如在游戏中生成大量相似的 NPC。</li><li><strong>创建成本较高的对象</strong>：比如数据库连接、复杂图形或计算成本较高的对象。</li></ul><h2 id="二-结构型设计模式"><a href="#二-结构型设计模式" class="headerlink" title="二.结构型设计模式"></a>二.结构型设计模式</h2><p>结构型模式关注如何将对象和类组装成更大的结构。</p><h3 id="6-适配器（Adapter）"><a href="#6-适配器（Adapter）" class="headerlink" title="6.适配器（Adapter）"></a>6.适配器（Adapter）</h3><p>将不兼容的接口转换为兼容接口，使得原本不能在一起工作的类可以协同工作。</p><p>适配器模式（Adapter Pattern）是一种结构型设计模式，它通过将一个接口转换成客户端所期望的另一个接口，使得原本因接口不兼容而无法一起工作的类可以协同工作。适配器模式通常用于以下情况：</p><ul><li>当你想要使用一些现有的类，但它们的接口不符合你的需求时。</li><li>当你需要创建一个可以与其他类一起使用的新类，但该新类不能直接使用这些类的接口时。</li></ul><h4 id="6-1-适配器模式的组成"><a href="#6-1-适配器模式的组成" class="headerlink" title="6.1 适配器模式的组成"></a>6.1 适配器模式的组成</h4><p>适配器模式通常包含以下几个角色：</p><ol><li><strong>目标接口（Target Interface）</strong>：定义客户端所需的接口。</li><li><strong>适配者（Adaptee）</strong>：需要被适配的类，其接口不符合客户端的需求。</li><li><strong>适配器（Adapter）</strong>：实现目标接口并持有适配者的引用，负责将客户端请求转发到适配者对象。</li></ol><h4 id="6-2-适配器模式的实现"><a href="#6-2-适配器模式的实现" class="headerlink" title="6.2 适配器模式的实现"></a>6.2 适配器模式的实现</h4><p>下面通过一个简单的例子来演示适配器模式的工作原理。假设我们有一个游戏应用程序，需要让一个 <code>Duck</code> 类（鸭子）和一个 <code>Turkey</code> 类（火鸡）可以在相同的上下文中使用。</p><h5 id="6-2-1-定义目标接口"><a href="#6-2-1-定义目标接口" class="headerlink" title="6.2.1  定义目标接口"></a>6.2.1  定义目标接口</h5><p>我们首先定义一个 <code>Duck</code> 接口，作为目标接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;   <span class="hljs-comment">// 鸭子的叫声</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 鸭子的飞行</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="6-2-2-定义适配者"><a href="#6-2-2-定义适配者" class="headerlink" title="6.2.2 定义适配者"></a>6.2.2 定义适配者</h5><p>接下来，定义一个 <code>Turkey</code> 类，作为需要被适配的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Turkey</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gobble</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Gobble gobble!&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 火鸡的叫声</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m flying a short distance!&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 火鸡的飞行</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="6-2-3-实现适配器"><a href="#6-2-3-实现适配器" class="headerlink" title="6.2.3 实现适配器"></a>6.2.3 实现适配器</h5><p>实现一个 <code>TurkeyAdapter</code> 类，将 <code>Turkey</code> 类适配到 <code>Duck</code> 接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurkeyAdapter</span> : <span class="hljs-keyword">public</span> Duck &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TurkeyAdapter</span>(Turkey* turkey) : <span class="hljs-built_in">turkey</span>(turkey) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        turkey-&gt;<span class="hljs-built_in">gobble</span>(); <span class="hljs-comment">// 将火鸡的叫声映射到鸭子的叫声</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        turkey-&gt;<span class="hljs-built_in">fly</span>(); <span class="hljs-comment">// 直接使用火鸡的飞行</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Turkey* turkey; <span class="hljs-comment">// 持有一个火鸡的引用</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="6-3-4-客户端代码"><a href="#6-3-4-客户端代码" class="headerlink" title="6.3.4 客户端代码"></a>6.3.4 客户端代码</h5><p>客户端代码使用 <code>Duck</code> 接口，与 <code>TurkeyAdapter</code> 进行交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testDuck</span><span class="hljs-params">(Duck* duck)</span> </span>&#123;<br>    duck-&gt;<span class="hljs-built_in">quack</span>();<br>    duck-&gt;<span class="hljs-built_in">fly</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Turkey* turkey = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Turkey</span>();<br>    Duck* turkeyAdapter = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TurkeyAdapter</span>(turkey);<br><br>    <span class="hljs-comment">// 测试火鸡适配器作为鸭子</span><br>    <span class="hljs-built_in">testDuck</span>(turkeyAdapter);<br><br>    <span class="hljs-comment">// 清理内存</span><br>    <span class="hljs-keyword">delete</span> turkeyAdapter;<br>    <span class="hljs-keyword">delete</span> turkey;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="6-3-适配器模式的优缺点"><a href="#6-3-适配器模式的优缺点" class="headerlink" title="6.3 适配器模式的优缺点"></a>6.3 适配器模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>接口兼容</strong>：可以使不兼容的接口相互协作，增强了代码的可复用性。</li><li><strong>松耦合</strong>：客户端与适配者之间是松耦合的，改变适配者的实现不会影响客户端。</li><li><strong>可扩展性</strong>：可以很容易地添加新的适配者，而不需要修改现有的代码。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>增加了复杂性</strong>：适配器模式可能会导致系统的复杂性增加，因为引入了额外的类和层次结构。</li><li><strong>可能影响性能</strong>：在某些情况下，使用适配器可能会对性能产生影响，特别是在调用频繁时，因为它增加了方法调用的开销。</li></ol><h4 id="6-4-适用场景"><a href="#6-4-适用场景" class="headerlink" title="6.4 适用场景"></a>6.4 适用场景</h4><ul><li>当你需要使用一些现有的类，但它们的接口不符合你的需求。</li><li>当你希望创建一个可以与多个不同类一起工作的新类，而不需要修改它们的代码。</li><li>当你想要使用一些第三方库或类时，而它们与系统中的接口不兼容。</li></ul><p>适配器模式是一种灵活且广泛应用的设计模式，可以帮助开发者在不改变现有代码的情况下，轻松实现接口的转换。</p><h3 id="7-桥接（Bridge）"><a href="#7-桥接（Bridge）" class="headerlink" title="7.桥接（Bridge）"></a>7.桥接（Bridge）</h3><p>将抽象部分与其实现部分分离，使它们可以独立变化。</p><p>桥接模式（Bridge Pattern）是一种结构型设计模式，旨在将抽象与实现分离，使它们可以独立变化。这个模式通过引入一个桥接接口，允许在运行时切换实现。桥接模式的主要目的是降低系统的复杂度，提高灵活性和可扩展性。</p><h4 id="7-1-组成部分"><a href="#7-1-组成部分" class="headerlink" title="7.1 组成部分"></a>7.1 组成部分</h4><p>桥接模式通常包含以下几个角色：</p><ol><li><strong>抽象类（Abstraction）</strong>：定义抽象接口，并包含一个对实现部分的引用。</li><li><strong>扩展抽象类（Refined Abstraction）</strong>：继承自抽象类，提供更具体的实现。</li><li><strong>实现接口（Implementor）</strong>：定义实现类的接口，不一定与抽象类的接口完全一致。</li><li><strong>具体实现类（Concrete Implementor）</strong>：实现实现接口，提供具体的功能。</li></ol><h4 id="7-2-桥接模式的实现"><a href="#7-2-桥接模式的实现" class="headerlink" title="7.2 桥接模式的实现"></a>7.2 桥接模式的实现</h4><p>通过一个简单的示例来演示桥接模式。假设我们要创建一个绘图工具，支持不同的形状（如圆形和正方形）以及不同的颜色（如红色和蓝色）。</p><h5 id="7-2-1-定义实现接口"><a href="#7-2-1-定义实现接口" class="headerlink" title="7.2.1  定义实现接口"></a>7.2.1  定义实现接口</h5><p>首先定义一个颜色实现接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">applyColor</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 应用颜色</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> : <span class="hljs-keyword">public</span> Color &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">applyColor</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Applying red color.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> : <span class="hljs-keyword">public</span> Color &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">applyColor</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Applying blue color.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="7-2-2-定义抽象类"><a href="#7-2-2-定义抽象类" class="headerlink" title="7.2.2 定义抽象类"></a>7.2.2 定义抽象类</h5><p>接下来，定义一个形状抽象类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    Color* color; <span class="hljs-comment">// 持有一个颜色实现的引用</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Shape</span>(Color* c) : <span class="hljs-built_in">color</span>(c) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 抽象方法</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="7-2-3-扩展抽象类"><a href="#7-2-3-扩展抽象类" class="headerlink" title="7.2.3 扩展抽象类"></a>7.2.3 扩展抽象类</h5><p>然后实现具体的形状类，如圆形和正方形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(Color* c) : <span class="hljs-built_in">Shape</span>(c) &#123;&#125; <span class="hljs-comment">// 通过构造函数传入颜色实现</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Circle.&quot;</span> &lt;&lt; std::endl;<br>        color-&gt;<span class="hljs-built_in">applyColor</span>(); <span class="hljs-comment">// 应用颜色</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Square</span>(Color* c) : <span class="hljs-built_in">Shape</span>(c) &#123;&#125; <span class="hljs-comment">// 通过构造函数传入颜色实现</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Square.&quot;</span> &lt;&lt; std::endl;<br>        color-&gt;<span class="hljs-built_in">applyColor</span>(); <span class="hljs-comment">// 应用颜色</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="7-3-4-客户端代码"><a href="#7-3-4-客户端代码" class="headerlink" title="7.3.4 客户端代码"></a>7.3.4 客户端代码</h5><p>在客户端代码中，可以灵活地创建不同的形状和颜色的组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color* red = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Red</span>();<br>    Color* blue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Blue</span>();<br><br>    Shape* circle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>(red);<br>    Shape* square = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Square</span>(blue);<br><br>    <span class="hljs-comment">// 绘制形状</span><br>    circle-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// 输出: Drawing Circle. Applying red color.</span><br>    square-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// 输出: Drawing Square. Applying blue color.</span><br><br>    <span class="hljs-comment">// 清理内存</span><br>    <span class="hljs-keyword">delete</span> circle;<br>    <span class="hljs-keyword">delete</span> square;<br>    <span class="hljs-keyword">delete</span> red;<br>    <span class="hljs-keyword">delete</span> blue;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="7-3-桥接模式的优缺点"><a href="#7-3-桥接模式的优缺点" class="headerlink" title="7.3 桥接模式的优缺点"></a>7.3 桥接模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>分离抽象与实现</strong>：可以独立扩展抽象和实现部分，从而提高了系统的灵活性和可扩展性。</li><li><strong>避免了多重继承的复杂性</strong>：通过组合而不是继承来实现不同的实现部分，避免了因多重继承而导致的复杂性。</li><li><strong>易于扩展</strong>：可以轻松添加新的实现或抽象，而不需要修改现有的代码。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>增加了系统复杂性</strong>：由于引入了更多的类，桥接模式可能会导致系统的复杂性增加。</li><li><strong>需要对两个层次的设计</strong>：设计时需要考虑抽象和实现两部分，可能会增加设计的难度。</li></ol><h4 id="7-4-适用场景"><a href="#7-4-适用场景" class="headerlink" title="7.4 适用场景"></a>7.4 适用场景</h4><ul><li>当你需要在多个维度上进行扩展时，比如图形库中的形状和颜色。</li><li>当你想要避免使用多重继承来组合不同的类时。</li><li>当你希望通过组合而不是继承来实现灵活的系统设计时。</li></ul><h4 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h4><p>桥接模式通过将抽象与实现分离，提供了一种灵活的解决方案，使得系统可以在不增加复杂性的情况下进行扩展。这种模式特别适合需要处理多个维度的系统，如图形、形状和颜色等，使得代码更加模块化和可维护。</p><p><em>注：桥接模式主要关注于将抽象与实现分离，而工厂模式则专注于对象的创建和管理。</em></p><h3 id="8-组合（Composite）"><a href="#8-组合（Composite）" class="headerlink" title="8.组合（Composite）"></a>8.组合（Composite）</h3><p>将对象组合成树形结构，表示“部分-整体”层次结构，使得客户端可以统一对待单个对象和组合对象。</p><p>组合模式（Composite Pattern）是一种结构型设计模式，旨在将对象组合成树形结构以表示“部分-整体”的层次关系。组合模式允许客户以一致的方式处理单个对象和对象集合，使得客户端可以统一处理复杂的树形结构，简化代码的复杂性。</p><h4 id="8-1-主要角色"><a href="#8-1-主要角色" class="headerlink" title="8.1 主要角色"></a>8.1 主要角色</h4><p>组合模式通常包含以下几个角色：</p><ol><li><strong>组件接口（Component）</strong>：<ul><li>声明所有的具体组件（叶子节点和组合节点）所共有的接口，可能包含一些方法，如 <code>add()</code>、<code>remove()</code> 和 <code>display()</code> 等。</li></ul></li><li><strong>叶子节点（Leaf）</strong>：<ul><li>实现组件接口，代表树的叶子节点。叶子节点不再有子节点，因此在这里实现具体的行为。</li></ul></li><li><strong>组合节点（Composite）</strong>：<ul><li>也实现组件接口，代表树的组合节点，可以包含叶子节点或其他组合节点。组合节点负责管理子节点并实现相关的行为。</li></ul></li></ol><h4 id="8-2-示例"><a href="#8-2-示例" class="headerlink" title="8.2 示例"></a>8.2 示例</h4><p>以下是一个简单的组合模式示例，模拟一个文件系统的结构，支持文件（叶子节点）和文件夹（组合节点）。</p><h5 id="8-2-1-定义组件接口"><a href="#8-2-1-定义组件接口" class="headerlink" title="8.2.1 定义组件接口"></a>8.2.1 定义组件接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 组件接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemComponent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 显示信息</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">FileSystemComponent</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="8-2-2-实现叶子节点（文件）"><a href="#8-2-2-实现叶子节点（文件）" class="headerlink" title="8.2.2 实现叶子节点（文件）"></a>8.2.2 实现叶子节点（文件）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> : <span class="hljs-keyword">public</span> FileSystemComponent &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name; <span class="hljs-comment">// 文件名</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">File</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name</span>(name) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;File: &quot;</span> &lt;&lt; name &lt;&lt; std::endl; <span class="hljs-comment">// 显示文件信息</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="8-2-3-实现组合节点（文件夹）"><a href="#8-2-3-实现组合节点（文件夹）" class="headerlink" title="8.2.3 实现组合节点（文件夹）"></a>8.2.3 实现组合节点（文件夹）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Folder</span> : <span class="hljs-keyword">public</span> FileSystemComponent &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name; <span class="hljs-comment">// 文件夹名</span><br>    std::vector&lt;FileSystemComponent*&gt; children; <span class="hljs-comment">// 存储子节点</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Folder</span>(<span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">name</span>(name) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(FileSystemComponent* component)</span> </span>&#123;<br>        children.<span class="hljs-built_in">push_back</span>(component); <span class="hljs-comment">// 添加子节点</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(FileSystemComponent* component)</span> </span>&#123;<br>        <span class="hljs-comment">// 从子节点中移除</span><br>        children.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(children.<span class="hljs-built_in">begin</span>(), children.<span class="hljs-built_in">end</span>(), component), children.<span class="hljs-built_in">end</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Folder: &quot;</span> &lt;&lt; name &lt;&lt; std::endl; <span class="hljs-comment">// 显示文件夹信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; child : children) &#123;<br>            child-&gt;<span class="hljs-built_in">showInfo</span>(); <span class="hljs-comment">// 递归显示子节点信息</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="8-2-4-客户端代码"><a href="#8-2-4-客户端代码" class="headerlink" title="8.2.4 客户端代码"></a>8.2.4 客户端代码</h5><p>在客户端代码中，可以创建文件和文件夹，并显示它们的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    FileSystemComponent* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Folder</span>(<span class="hljs-string">&quot;Root Folder&quot;</span>);<br>    FileSystemComponent* folder1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Folder</span>(<span class="hljs-string">&quot;Folder 1&quot;</span>);<br>    FileSystemComponent* folder2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Folder</span>(<span class="hljs-string">&quot;Folder 2&quot;</span>);<br>    <br>    FileSystemComponent* file1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(<span class="hljs-string">&quot;File 1.txt&quot;</span>);<br>    FileSystemComponent* file2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(<span class="hljs-string">&quot;File 2.txt&quot;</span>);<br>    FileSystemComponent* file3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(<span class="hljs-string">&quot;File 3.txt&quot;</span>);<br><br>    <span class="hljs-comment">// 构建文件系统结构</span><br>    folder1-&gt;<span class="hljs-built_in">add</span>(file1);<br>    folder1-&gt;<span class="hljs-built_in">add</span>(file2);<br>    root-&gt;<span class="hljs-built_in">add</span>(folder1);<br>    root-&gt;<span class="hljs-built_in">add</span>(folder2);<br>    folder2-&gt;<span class="hljs-built_in">add</span>(file3);<br><br>    <span class="hljs-comment">// 显示文件系统信息</span><br>    root-&gt;<span class="hljs-built_in">showInfo</span>();<br><br>    <span class="hljs-comment">// 清理内存</span><br>    <span class="hljs-keyword">delete</span> file1;<br>    <span class="hljs-keyword">delete</span> file2;<br>    <span class="hljs-keyword">delete</span> file3;<br>    <span class="hljs-keyword">delete</span> folder1;<br>    <span class="hljs-keyword">delete</span> folder2;<br>    <span class="hljs-keyword">delete</span> root;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="8-3-组合模式的优缺点"><a href="#8-3-组合模式的优缺点" class="headerlink" title="8.3 组合模式的优缺点"></a>8.3 组合模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>简化客户端代码</strong>：客户端可以统一处理单个对象和组合对象，简化了代码结构。</li><li><strong>树形结构的灵活性</strong>：可以自由组合和嵌套对象，支持复杂的层次结构。</li><li><strong>易于扩展</strong>：可以添加新的叶子节点和组合节点，系统的扩展性强。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>过度使用组合模式</strong>：可能导致系统的设计变得过于复杂，尤其是在组件接口过于庞大的情况下。</li><li><strong>性能开销</strong>：如果组合结构过于复杂，可能会对性能产生一定影响。</li></ol><h4 id="8-4-适用场景"><a href="#8-4-适用场景" class="headerlink" title="8.4 适用场景"></a>8.4 适用场景</h4><ul><li>需要表示“部分-整体”层次结构的场景，例如文件系统、图形界面组件、组织结构等。</li><li>希望客户端能够以统一的方式处理单个对象和对象集合的场景。</li><li>在需要对组合对象进行递归操作时，如遍历树形结构。</li></ul><h4 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h4><p>组合模式通过将对象组合成树形结构，使得客户端可以以一致的方式处理单个对象和对象集合。它适用于需要表示“部分-整体”关系的场景，提高了代码的可维护性和扩展性。</p><h3 id="9-装饰器（Decorator）"><a href="#9-装饰器（Decorator）" class="headerlink" title="9.装饰器（Decorator）"></a>9.装饰器（Decorator）</h3><p>动态地给对象添加新的功能。与继承不同，装饰器可以在运行时选择性地添加行为。</p><p>装饰器模式（Decorator Pattern）是一种结构型设计模式，用于动态地给对象添加额外的功能。装饰器模式通过将对象包装在一个或多个装饰类中，以增加其功能，而无需修改原始对象的结构。这种模式非常灵活，允许用户在运行时选择要添加的装饰，从而实现功能的扩展。</p><h4 id="9-1-主要角色"><a href="#9-1-主要角色" class="headerlink" title="9.1 主要角色"></a>9.1 主要角色</h4><p>装饰器模式通常包含以下几个角色：</p><ol><li><strong>组件接口（Component）</strong>：<ul><li>定义一个接口，用于描述被装饰的对象的行为。</li></ul></li><li><strong>具体组件（Concrete Component）</strong>：<ul><li>实现组件接口，表示需要被装饰的对象。可以有多个具体组件。</li></ul></li><li><strong>装饰器基类（Decorator）</strong>：<ul><li>实现组件接口，持有一个组件对象的引用，并定义与具体组件相同的接口。装饰器可以扩展功能。</li></ul></li><li><strong>具体装饰器（Concrete Decorator）</strong>：<ul><li>继承自装饰器基类，添加具体的功能或行为。可以有多个具体装饰器，每个装饰器都可以添加不同的功能。</li></ul></li></ol><h4 id="9-2-示例"><a href="#9-2-示例" class="headerlink" title="9.2 示例"></a>9.2 示例</h4><p>以下是一个简单的装饰器模式示例，模拟一个文本消息的装饰器，可以给文本添加不同的样式。</p><h5 id="9-2-1-定义组件接口"><a href="#9-2-1-定义组件接口" class="headerlink" title="9.2.1 定义组件接口"></a>9.2.1 定义组件接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 组件接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">getContent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 获取内容</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Message</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="9-2-2-实现具体组件"><a href="#9-2-2-实现具体组件" class="headerlink" title="9.2.2 实现具体组件"></a>9.2.2 实现具体组件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMessage</span> : <span class="hljs-keyword">public</span> Message &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string content; <span class="hljs-comment">// 消息内容</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SimpleMessage</span>(<span class="hljs-type">const</span> std::string&amp; msg) : <span class="hljs-built_in">content</span>(msg) &#123;&#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">getContent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> content; <span class="hljs-comment">// 返回简单消息内容</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="9-2-3-实现装饰器基类"><a href="#9-2-3-实现装饰器基类" class="headerlink" title="9.2.3 实现装饰器基类"></a>9.2.3 实现装饰器基类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageDecorator</span> : <span class="hljs-keyword">public</span> Message &#123;<br><span class="hljs-keyword">protected</span>:<br>    Message* message; <span class="hljs-comment">// 持有一个消息对象的引用</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MessageDecorator</span>(Message* msg) : <span class="hljs-built_in">message</span>(msg) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">getContent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message-&gt;<span class="hljs-built_in">getContent</span>(); <span class="hljs-comment">// 调用被装饰对象的内容</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="9-2-4-实现具体装饰器"><a href="#9-2-4-实现具体装饰器" class="headerlink" title="9.2.4 实现具体装饰器"></a>9.2.4 实现具体装饰器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HtmlMessage</span> : <span class="hljs-keyword">public</span> MessageDecorator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HtmlMessage</span>(Message* msg) : <span class="hljs-built_in">MessageDecorator</span>(msg) &#123;&#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">getContent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + message-&gt;<span class="hljs-built_in">getContent</span>() + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>; <span class="hljs-comment">// 添加HTML标签</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptedMessage</span> : <span class="hljs-keyword">public</span> MessageDecorator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EncryptedMessage</span>(Message* msg) : <span class="hljs-built_in">MessageDecorator</span>(msg) &#123;&#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">getContent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Encrypted: &quot;</span> + message-&gt;<span class="hljs-built_in">getContent</span>(); <span class="hljs-comment">// 添加加密标识</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="9-2-5-客户端代码"><a href="#9-2-5-客户端代码" class="headerlink" title="9.2.5 客户端代码"></a>9.2.5 客户端代码</h5><p>在客户端代码中，可以创建消息对象，并使用装饰器添加不同的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Message* message = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SimpleMessage</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>); <span class="hljs-comment">// 创建简单消息</span><br><br>    <span class="hljs-comment">// 添加HTML装饰</span><br>    Message* htmlMessage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HtmlMessage</span>(message);<br>    std::cout &lt;&lt; htmlMessage-&gt;<span class="hljs-built_in">getContent</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: &lt;html&gt;Hello, World!&lt;/html&gt;</span><br><br>    <span class="hljs-comment">// 添加加密装饰</span><br>    Message* encryptedMessage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EncryptedMessage</span>(htmlMessage);<br>    std::cout &lt;&lt; encryptedMessage-&gt;<span class="hljs-built_in">getContent</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Encrypted: &lt;html&gt;Hello, World!&lt;/html&gt;</span><br><br>    <span class="hljs-comment">// 清理内存</span><br>    <span class="hljs-keyword">delete</span> encryptedMessage; <span class="hljs-comment">// 先删除最外层的装饰器</span><br>    <span class="hljs-keyword">delete</span> htmlMessage;      <span class="hljs-comment">// 然后删除HTML装饰</span><br>    <span class="hljs-keyword">delete</span> message;          <span class="hljs-comment">// 最后删除简单消息</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="9-3-装饰器模式的优缺点"><a href="#9-3-装饰器模式的优缺点" class="headerlink" title="9.3 装饰器模式的优缺点"></a>9.3 装饰器模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>灵活性</strong>：可以动态添加和组合功能，不需要修改原始对象的代码。</li><li><strong>扩展性</strong>：可以通过增加新的装饰类来扩展功能，遵循开闭原则（对扩展开放，对修改封闭）。</li><li><strong>清晰的责任分离</strong>：每个装饰器可以负责一项功能，责任明确，便于管理。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>复杂性</strong>：增加了系统的复杂性，特别是当装饰类较多时，可能导致代码难以理解。</li><li><strong>性能开销</strong>：每个装饰器会增加额外的调用开销，影响性能。</li></ol><h4 id="9-4-适用场景"><a href="#9-4-适用场景" class="headerlink" title="9.4 适用场景"></a>9.4 适用场景</h4><ul><li>需要在不修改对象的情况下，动态添加或修改对象的功能。</li><li>需要通过组合方式为对象增加功能，而不影响其他对象。</li><li>在需要扩展类的功能时，尤其是在类的层次结构中，增加了额外的类或功能。</li></ul><h4 id="9-5-总结"><a href="#9-5-总结" class="headerlink" title="9.5 总结"></a>9.5 总结</h4><p>装饰器模式通过引入装饰器类，为对象提供动态的功能扩展。它使得功能的添加变得灵活且可组合，从而实现了更好的代码复用和维护性。适用于需要对对象进行多种功能扩展的场景，能够在运行时决定所需的功能组合。</p><h3 id="10-外观（Facade）"><a href="#10-外观（Facade）" class="headerlink" title="10.外观（Facade）"></a>10.外观（Facade）</h3><p>为一组接口提供一个简单的统一接口，使子系统更加易用。</p><p>外观模式（Facade Pattern）是一种结构型设计模式，旨在为复杂的子系统提供一个简化的接口。通过外观模式，用户可以通过一个统一的接口与复杂的系统交互，而无需了解系统的内部细节。这种模式有助于减少系统的复杂性，提高代码的可维护性和可理解性。</p><h4 id="10-1-主要角色"><a href="#10-1-主要角色" class="headerlink" title="10.1 主要角色"></a>10.1 主要角色</h4><p>外观模式通常包含以下几个角色：</p><ol><li><strong>外观类（Facade）</strong>：<ul><li>提供简化的接口，封装复杂子系统的功能。</li></ul></li><li><strong>子系统类（Subsystem）</strong>：<ul><li>实现系统的核心功能，外观类通过它们提供服务。</li></ul></li><li><strong>客户端（Client）</strong>：<ul><li>通过外观类与复杂子系统进行交互。</li></ul></li></ol><h4 id="10-2-示例"><a href="#10-2-示例" class="headerlink" title="10.2 示例"></a>10.2 示例</h4><p>以下是一个使用外观模式的简单示例，模拟一个音响系统的使用场景。</p><h5 id="10-2-1-定义子系统类"><a href="#10-2-1-定义子系统类" class="headerlink" title="10.2.1  定义子系统类"></a>10.2.1  定义子系统类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 子系统类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Amplifier</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Amplifier is on.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Amplifier is off.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 子系统类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DVDPlayer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;DVD Player is on.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;DVD is playing.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;DVD is stopped.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;DVD Player is off.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 子系统类C</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Projector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Projector is on.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Projector is off.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="10-2-2-实现外观类"><a href="#10-2-2-实现外观类" class="headerlink" title="10.2.2 实现外观类"></a>10.2.2 实现外观类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 外观类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeTheaterFacade</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Amplifier amplifier;<br>    DVDPlayer dvdPlayer;<br>    Projector projector;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeTheaterFacade</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">watchMovie</span><span class="hljs-params">()</span> </span>&#123;<br>        projector.<span class="hljs-built_in">on</span>();<br>        amplifier.<span class="hljs-built_in">on</span>();<br>        dvdPlayer.<span class="hljs-built_in">on</span>();<br>        dvdPlayer.<span class="hljs-built_in">play</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">endMovie</span><span class="hljs-params">()</span> </span>&#123;<br>        dvdPlayer.<span class="hljs-built_in">stop</span>();<br>        amplifier.<span class="hljs-built_in">off</span>();<br>        projector.<span class="hljs-built_in">off</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="10-2-3-客户端代码"><a href="#10-2-3-客户端代码" class="headerlink" title="10.2.3 客户端代码"></a>10.2.3 客户端代码</h5><p>在客户端代码中，通过外观类与复杂的子系统交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    HomeTheaterFacade homeTheater; <span class="hljs-comment">// 创建外观对象</span><br><br>    homeTheater.<span class="hljs-built_in">watchMovie</span>(); <span class="hljs-comment">// 启动观影模式</span><br>    std::cout &lt;&lt; std::endl;<br>    homeTheater.<span class="hljs-built_in">endMovie</span>(); <span class="hljs-comment">// 结束观影模式</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="10-3-外观模式的优缺点"><a href="#10-3-外观模式的优缺点" class="headerlink" title="10.3 外观模式的优缺点"></a>10.3 外观模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>简化接口</strong>：外观模式提供了一个简单的接口，减少了系统的复杂性，用户无需了解系统的内部实现。</li><li><strong>解耦</strong>：客户端与子系统之间的依赖关系减少，降低了模块之间的耦合度。</li><li><strong>提升可维护性</strong>：由于外观类封装了复杂的子系统，修改子系统的实现时只需关注外观类，不会影响客户端。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>不适合所有场景</strong>：外观模式可能会限制系统的扩展性，某些特定的操作可能需要直接与子系统交互。</li><li><strong>可能引入冗余</strong>：外观类可能会成为一个“胖类”，承担过多的责任，导致维护困难。</li></ol><h4 id="10-4-适用场景"><a href="#10-4-适用场景" class="headerlink" title="10.4 适用场景"></a>10.4 适用场景</h4><ul><li>当需要为复杂子系统提供一个统一的接口时。</li><li>当要简化客户端与子系统之间的交互时。</li><li>在开发大型系统时，有助于隐藏系统的复杂性并降低耦合度。</li></ul><h4 id="10-5-总结"><a href="#10-5-总结" class="headerlink" title="10.5 总结"></a>10.5 总结</h4><p>外观模式通过引入一个统一的接口，使得复杂子系统的使用变得简单和直观。它提高了代码的可维护性和可理解性，同时降低了模块间的耦合。外观模式在构建大型系统、库或框架时非常有用，能够有效管理和简化系统的复杂性。</p><h3 id="11-享元（Flyweight）"><a href="#11-享元（Flyweight）" class="headerlink" title="11.享元（Flyweight）"></a>11.享元（Flyweight）</h3><p>通过共享对象减少内存使用。适用于大量相似对象的情况。</p><p>享元模式（Flyweight Pattern）是一种结构型设计模式，旨在通过共享对象来减少内存使用和提高性能。享元模式特别适用于需要大量相似对象的场景。通过重用现有对象，享元模式可以显著减少系统所需的内存空间和对象创建的开销。</p><h4 id="11-1-主要角色"><a href="#11-1-主要角色" class="headerlink" title="11.1 主要角色"></a>11.1 主要角色</h4><p>享元模式通常包含以下几个角色：</p><ol><li><strong>享元接口（Flyweight）</strong>：<ul><li>定义享元对象的接口，通常包含一些可共享的方法。</li></ul></li><li><strong>具体享元（Concrete Flyweight）</strong>：<ul><li>实现享元接口，表示可共享的对象。具体享元对象应该是不可变的（或只读的），以便在共享时不会发生状态变化。</li></ul></li><li><strong>享元工厂（Flyweight Factory）</strong>：<ul><li>负责创建和管理享元对象。它确保在需要时返回相同的享元实例，而不是每次都创建新的实例。</li></ul></li><li><strong>外部状态（External State）</strong>：<ul><li>由于享元模式的对象通常是不可变的，所以需要将对象的可变状态提取到外部，以确保多个对象共享同一状态。</li></ul></li></ol><h4 id="11-2-示例"><a href="#11-2-示例" class="headerlink" title="11.2 示例"></a>11.2 示例</h4><p>以下是一个使用享元模式的简单示例，模拟一个文本编辑器中的字符对象的共享。</p><h5 id="11-2-1-定义享元接口"><a href="#11-2-1-定义享元接口" class="headerlink" title="11.2.1  定义享元接口"></a>11.2.1  定义享元接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 享元接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> fontSize)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 显示字符的方法</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Character</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="11-2-2-实现具体享元"><a href="#11-2-2-实现具体享元" class="headerlink" title="11.2.2  实现具体享元"></a>11.2.2  实现具体享元</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 具体享元</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCharacter</span> : <span class="hljs-keyword">public</span> Character &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> symbol; <span class="hljs-comment">// 字符</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCharacter</span>(<span class="hljs-type">char</span> s) : <span class="hljs-built_in">symbol</span>(s) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> fontSize)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Character: &quot;</span> &lt;&lt; symbol &lt;&lt; <span class="hljs-string">&quot;, Font size: &quot;</span> &lt;&lt; fontSize &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="11-2-3-实现享元工厂"><a href="#11-2-3-实现享元工厂" class="headerlink" title="11.2.3 实现享元工厂"></a>11.2.3 实现享元工厂</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 享元工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterFactory</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unordered_map&lt;<span class="hljs-type">char</span>, std::shared_ptr&lt;Character&gt;&gt; characters; <span class="hljs-comment">// 字符缓存</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;Character&gt; <span class="hljs-title">getCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>        <span class="hljs-comment">// 检查缓存中是否存在字符</span><br>        <span class="hljs-keyword">if</span> (characters.<span class="hljs-built_in">find</span>(c) == characters.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// 如果不存在，创建新的具体享元并缓存</span><br>            characters[c] = std::<span class="hljs-built_in">make_shared</span>&lt;ConcreteCharacter&gt;(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> characters[c]; <span class="hljs-comment">// 返回共享的字符</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="11-2-4-客户端代码"><a href="#11-2-4-客户端代码" class="headerlink" title="11.2.4 客户端代码"></a>11.2.4 客户端代码</h5><p>在客户端代码中，可以使用享元工厂创建字符对象，并在需要时进行共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    CharacterFactory factory; <span class="hljs-comment">// 创建享元工厂</span><br><br>    <span class="hljs-comment">// 通过工厂获取字符对象</span><br>    <span class="hljs-keyword">auto</span> characterA = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> characterB = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> characterC = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> characterA2 = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;A&#x27;</span>); <span class="hljs-comment">// 重用字符A</span><br><br>    <span class="hljs-comment">// 使用字符对象</span><br>    characterA-&gt;<span class="hljs-built_in">display</span>(<span class="hljs-number">12</span>);<br>    characterB-&gt;<span class="hljs-built_in">display</span>(<span class="hljs-number">14</span>);<br>    characterC-&gt;<span class="hljs-built_in">display</span>(<span class="hljs-number">16</span>);<br>    characterA2-&gt;<span class="hljs-built_in">display</span>(<span class="hljs-number">18</span>); <span class="hljs-comment">// 使用重用的字符A</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="11-3-享元模式的优缺点"><a href="#11-3-享元模式的优缺点" class="headerlink" title="11.3 享元模式的优缺点"></a>11.3 享元模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>节省内存</strong>：通过共享对象，显著减少内存占用，尤其是在创建大量相似对象的情况下。</li><li><strong>提高性能</strong>：减少了对象的创建和销毁次数，提高了程序的性能。</li><li><strong>符合开闭原则</strong>：可以通过增加新的享元类而不影响已有的代码。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>复杂性</strong>：引入了额外的复杂性，特别是在管理共享对象时。</li><li><strong>维护外部状态</strong>：外部状态的管理可能会使代码更加复杂，可能会影响可读性。</li></ol><h4 id="11-4-适用场景"><a href="#11-4-适用场景" class="headerlink" title="11.4 适用场景"></a>11.4 适用场景</h4><ul><li>当需要大量相似对象时，尤其是对象状态大部分是相同的。</li><li>当对象的创建和销毁成本较高时，享元模式可以显著提高性能。</li><li>在需要节省内存的场景，尤其是内存资源有限的应用程序。</li></ul><h4 id="11-5-总结"><a href="#11-5-总结" class="headerlink" title="11.5 总结"></a>11.5 总结</h4><p>享元模式通过共享对象来减少内存占用和提高性能，特别适合于需要大量相似对象的场景。它通过分离对象的内部状态和外部状态，优化了对象的管理和使用。尽管享元模式增加了一定的复杂性，但在资源受限或性能敏感的应用中，它仍然是一种非常有效的设计模式。</p><h3 id="12-代理（Proxy）"><a href="#12-代理（Proxy）" class="headerlink" title="12.代理（Proxy）"></a>12.代理（Proxy）</h3><p>为其他对象提供代理，控制对该对象的访问。代理模式常用于懒加载、访问控制等场景。</p><p>代理模式（Proxy Pattern）是一种结构型设计模式，提供了一个代理对象，以控制对另一个对象的访问。通过代理模式，可以在不改变原始对象的情况下，增加对该对象的控制和功能。代理模式通常用于以下几种场景：</p><ul><li><strong>延迟加载（Lazy Loading）</strong>：在实际需要时才创建对象，节省资源。</li><li><strong>访问控制（Access Control）</strong>：控制对原始对象的访问权限。</li><li><strong>日志记录（Logging）</strong>：在对原始对象的方法调用前后添加日志记录。</li><li><strong>远程代理（Remote Proxy）</strong>：为远程对象提供本地代理。</li></ul><h4 id="12-1-主要角色"><a href="#12-1-主要角色" class="headerlink" title="12.1 主要角色"></a>12.1 主要角色</h4><p>代理模式通常包含以下几个角色：</p><ol><li><strong>抽象主题（Subject）</strong>：<ul><li>定义了代理和真实对象的共同接口。</li></ul></li><li><strong>真实主题（Real Subject）</strong>：<ul><li>实现了抽象主题接口，表示被代理的对象。</li></ul></li><li><strong>代理（Proxy）</strong>：<ul><li>维护对真实主题对象的引用，并实现抽象主题接口。代理可以在调用真实对象的方法时添加额外的功能。</li></ul></li></ol><h4 id="12-2-示例"><a href="#12-2-示例" class="headerlink" title="12.2 示例"></a>12.2 示例</h4><p>以下是一个使用代理模式的简单示例，模拟图像加载的场景。</p><h5 id="12-2-1-定义抽象主题"><a href="#12-2-1-定义抽象主题" class="headerlink" title="12.2.1  定义抽象主题"></a>12.2.1  定义抽象主题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 抽象主题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Image</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 显示图像的方法</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Image</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="12-2-2-实现真实主题"><a href="#12-2-2-实现真实主题" class="headerlink" title="12.2.2 实现真实主题"></a>12.2.2 实现真实主题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 真实主题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealImage</span> : <span class="hljs-keyword">public</span> Image &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string filename; <span class="hljs-comment">// 图像文件名</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RealImage</span>(<span class="hljs-type">const</span> std::string&amp; file) : <span class="hljs-built_in">filename</span>(file) &#123;<br>        <span class="hljs-built_in">loadImageFromDisk</span>(); <span class="hljs-comment">// 加载图像</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadImageFromDisk</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Loading &quot;</span> &lt;&lt; filename &lt;&lt; std::endl; <span class="hljs-comment">// 模拟加载</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="12-2-3-实现代理"><a href="#12-2-3-实现代理" class="headerlink" title="12.2.3  实现代理"></a>12.2.3  实现代理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 代理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyImage</span> : <span class="hljs-keyword">public</span> Image &#123;<br><span class="hljs-keyword">private</span>:<br>    RealImage* realImage; <span class="hljs-comment">// 指向真实主题的指针</span><br>    std::string filename; <span class="hljs-comment">// 图像文件名</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ProxyImage</span>(<span class="hljs-type">const</span> std::string&amp; file) : <span class="hljs-built_in">realImage</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">filename</span>(file) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 延迟加载</span><br>        <span class="hljs-keyword">if</span> (!realImage) &#123;<br>            realImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RealImage</span>(filename); <span class="hljs-comment">// 只在需要时加载图像</span><br>        &#125;<br>        realImage-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 调用真实主题的显示方法</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">ProxyImage</span>() &#123;<br>        <span class="hljs-keyword">delete</span> realImage; <span class="hljs-comment">// 释放资源</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="12-2-4-客户端代码"><a href="#12-2-4-客户端代码" class="headerlink" title="12.2.4 客户端代码"></a>12.2.4 客户端代码</h5><p>在客户端代码中，可以使用代理对象来代替真实对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Image* image = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProxyImage</span>(<span class="hljs-string">&quot;test.jpg&quot;</span>); <span class="hljs-comment">// 创建代理对象</span><br><br>    image-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 第一次调用，加载图像</span><br>    std::cout &lt;&lt; std::endl;<br>    image-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 第二次调用，不再加载</span><br><br>    <span class="hljs-keyword">delete</span> image; <span class="hljs-comment">// 释放代理对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="12-3-代理模式的优缺点"><a href="#12-3-代理模式的优缺点" class="headerlink" title="12.3 代理模式的优缺点"></a>12.3 代理模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>控制访问</strong>：可以通过代理控制对真实对象的访问，增加安全性。</li><li><strong>延迟加载</strong>：在需要时才创建真实对象，节省资源。</li><li><strong>附加功能</strong>：可以在代理中增加附加的功能，如日志、缓存等。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>性能开销</strong>：代理可能会增加调用的开销，尤其是在代理逻辑复杂的情况下。</li><li><strong>增加复杂性</strong>：引入代理对象会增加代码的复杂性。</li></ol><h4 id="12-4-适用场景"><a href="#12-4-适用场景" class="headerlink" title="12.4 适用场景"></a>12.4 适用场景</h4><ul><li>当需要控制对某个对象的访问时。</li><li>当想要为某个对象添加额外的功能而不改变其实现时。</li><li>当需要实现延迟加载的场景时。</li></ul><h4 id="12-5-总结"><a href="#12-5-总结" class="headerlink" title="12.5 总结"></a>12.5 总结</h4><p>代理模式通过引入代理对象来控制对真实对象的访问，提供了灵活性和额外功能，尤其适用于访问控制、延迟加载和附加功能等场景。尽管代理模式增加了一定的复杂性，但在需要优化资源使用和保护真实对象的情况下，它仍然是一种非常有效的设计模式。</p><h2 id="三-行为型设计模式"><a href="#三-行为型设计模式" class="headerlink" title="三.行为型设计模式"></a>三.行为型设计模式</h2><p>行为型模式关注对象如何协作完成任务，封装和管理对象之间的通信。</p><h3 id="13-责任链（Chain-of-Responsibility）"><a href="#13-责任链（Chain-of-Responsibility）" class="headerlink" title="13.责任链（Chain of Responsibility）"></a>13.责任链（Chain of Responsibility）</h3><p>将请求沿着一条链传递，链上的每个处理者可以选择处理请求或传递给下一个处理者。</p><p>责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，用于避免请求发送者与多个请求处理者之间的耦合关系。该模式通过将请求沿着处理链传递，让多个处理者都有机会处理请求，从而将请求的处理责任分散到多个对象中。每个处理者决定是否处理请求，或者将请求转发给下一个处理者。</p><h4 id="13-1-主要角色"><a href="#13-1-主要角色" class="headerlink" title="13.1 主要角色"></a>13.1 主要角色</h4><p>责任链模式通常包含以下几个角色：</p><ol><li><strong>处理者（Handler）</strong>：<ul><li>定义处理请求的接口，并包含一个指向下一个处理者的引用。每个处理者负责处理特定类型的请求。</li></ul></li><li><strong>具体处理者（Concrete Handler）</strong>：<ul><li>实现处理请求的逻辑，如果该处理者可以处理请求，则执行相应操作；否则，将请求转发给下一个处理者。</li></ul></li><li><strong>客户端（Client）</strong>：<ul><li>发送请求的对象，通常会创建处理链并设置请求的起始处理者。</li></ul></li></ol><h4 id="13-2-示例"><a href="#13-2-示例" class="headerlink" title="13.2 示例"></a>13.2 示例</h4><p>以下是一个使用责任链模式的简单示例，模拟一个支持不同级别请求的审批系统。</p><h5 id="13-2-1-定义处理者接口"><a href="#13-2-1-定义处理者接口" class="headerlink" title="13.2.1 定义处理者接口"></a>13.2.1 定义处理者接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 抽象处理者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Approver</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Approver* next)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置下一个处理者</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; request, <span class="hljs-type">int</span> amount)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 处理请求</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Approver</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="13-2-2-实现具体处理者"><a href="#13-2-2-实现具体处理者" class="headerlink" title="13.2.2 实现具体处理者"></a>13.2.2 实现具体处理者</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 具体处理者 - 经理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Approver &#123;<br><span class="hljs-keyword">private</span>:<br>    Approver* next; <span class="hljs-comment">// 指向下一个处理者</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Approver* next)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; request, <span class="hljs-type">int</span> amount)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">1000</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Manager approved &quot;</span> &lt;&lt; request &lt;&lt; <span class="hljs-string">&quot; of amount &quot;</span> &lt;&lt; amount &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next) &#123;<br>            next-&gt;<span class="hljs-built_in">processRequest</span>(request, amount); <span class="hljs-comment">// 转发请求</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体处理者 - 总监</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> : <span class="hljs-keyword">public</span> Approver &#123;<br><span class="hljs-keyword">private</span>:<br>    Approver* next;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Approver* next)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; request, <span class="hljs-type">int</span> amount)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">5000</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Director approved &quot;</span> &lt;&lt; request &lt;&lt; <span class="hljs-string">&quot; of amount &quot;</span> &lt;&lt; amount &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next) &#123;<br>            next-&gt;<span class="hljs-built_in">processRequest</span>(request, amount);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体处理者 - CEO</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CEO</span> : <span class="hljs-keyword">public</span> Approver &#123;<br><span class="hljs-keyword">private</span>:<br>    Approver* next;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Approver* next)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; request, <span class="hljs-type">int</span> amount)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;CEO approved &quot;</span> &lt;&lt; request &lt;&lt; <span class="hljs-string">&quot; of amount &quot;</span> &lt;&lt; amount &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="13-2-3-客户端代码"><a href="#13-2-3-客户端代码" class="headerlink" title="13.2.3 客户端代码"></a>13.2.3 客户端代码</h5><p>在客户端代码中，可以构建处理链并发送请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建处理者</span><br>    Manager* manager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Manager</span>();<br>    Director* director = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Director</span>();<br>    CEO* ceo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CEO</span>();<br><br>    <span class="hljs-comment">// 建立责任链</span><br>    manager-&gt;<span class="hljs-built_in">setNext</span>(director);<br>    director-&gt;<span class="hljs-built_in">setNext</span>(ceo);<br><br>    <span class="hljs-comment">// 发送请求</span><br>    manager-&gt;<span class="hljs-built_in">processRequest</span>(<span class="hljs-string">&quot;Purchase Request&quot;</span>, <span class="hljs-number">500</span>);    <span class="hljs-comment">// 经理处理</span><br>    manager-&gt;<span class="hljs-built_in">processRequest</span>(<span class="hljs-string">&quot;Purchase Request&quot;</span>, <span class="hljs-number">3000</span>);   <span class="hljs-comment">// 总监处理</span><br>    manager-&gt;<span class="hljs-built_in">processRequest</span>(<span class="hljs-string">&quot;Purchase Request&quot;</span>, <span class="hljs-number">10000</span>);  <span class="hljs-comment">// CEO处理</span><br><br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-keyword">delete</span> manager;<br>    <span class="hljs-keyword">delete</span> director;<br>    <span class="hljs-keyword">delete</span> ceo;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="13-3-责任链模式的优缺点"><a href="#13-3-责任链模式的优缺点" class="headerlink" title="13.3 责任链模式的优缺点"></a>13.3 责任链模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>解耦合</strong>：请求发送者和处理者之间不需要直接耦合，增加了系统的灵活性。</li><li><strong>动态改变处理链</strong>：可以在运行时动态地改变处理链，增加或删除处理者。</li><li><strong>职责分配</strong>：可以将请求处理的责任分配给多个对象，简化了请求处理逻辑。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>无法保证请求被处理</strong>：由于请求可能在链中被丢弃，客户端可能无法得知请求的处理状态。</li><li><strong>调试困难</strong>：由于请求在多个处理者之间传递，调试时可能会比较困难。</li><li><strong>性能开销</strong>：链的长度过长可能会导致性能问题，特别是处理复杂请求时。</li></ol><h4 id="13-4-适用场景"><a href="#13-4-适用场景" class="headerlink" title="13.4 适用场景"></a>13.4 适用场景</h4><ul><li>需要处理的请求在多个对象之间有多个处理者，且每个处理者可以选择是否处理该请求。</li><li>希望将请求处理的责任解耦，并提供动态的处理链。</li><li>需要实现多个对象之间的分配责任。</li></ul><h4 id="13-5-总结"><a href="#13-5-总结" class="headerlink" title="13.5 总结"></a>13.5 总结</h4><p>责任链模式通过将请求在多个处理者之间传递，使得请求的处理责任可以灵活地分配，增加了系统的灵活性和可扩展性。它适用于请求处理逻辑复杂且需要多个处理者的场景，能够有效地解耦请求发送者和处理者之间的关系。</p><h3 id="14-命令（Command）"><a href="#14-命令（Command）" class="headerlink" title="14.命令（Command）"></a>14.命令（Command）</h3><p>将请求封装成对象，解耦请求发送者与执行者。</p><p>命令模式（Command Pattern）是一种行为型设计模式，它将请求封装为对象，从而使您可以用不同的请求对客户端进行参数化、排队或记录请求日志。它还支持可撤销的操作。命令模式涉及几个主要角色：</p><h4 id="14-1-主要角色"><a href="#14-1-主要角色" class="headerlink" title="14.1 主要角色"></a>14.1 主要角色</h4><ol><li><strong>命令接口（Command）</strong>：<ul><li>声明了执行操作的接口。</li></ul></li><li><strong>具体命令（Concrete Command）</strong>：<ul><li>实现命令接口，并定义与接收者之间的绑定关系。它调用接收者的方法以实现请求。</li></ul></li><li><strong>接收者（Receiver）</strong>：<ul><li>负责实际执行与请求相关的操作。</li></ul></li><li><strong>调用者（Invoker）</strong>：<ul><li>请求的发起者，持有命令对象并调用命令对象的 <code>execute</code> 方法。</li></ul></li><li><strong>客户端（Client）</strong>：<ul><li>创建具体命令对象并设置其接收者。</li></ul></li></ol><h4 id="14-2-示例"><a href="#14-2-示例" class="headerlink" title="14.2 示例"></a>14.2 示例</h4><p>以下是一个使用命令模式的简单示例，模拟一个遥控器控制家用电器的场景。</p><h5 id="14-2-1-定义命令接口"><a href="#14-2-1-定义命令接口" class="headerlink" title="14.2.1  定义命令接口"></a>14.2.1  定义命令接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 命令接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 执行命令</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Command</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="14-2-2-定义接收者"><a href="#14-2-2-定义接收者" class="headerlink" title="14.2.2 定义接收者"></a>14.2.2 定义接收者</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 接收者 - 灯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">turnOn</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The light is on.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">turnOff</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The light is off.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="14-2-3-实现具体命令"><a href="#14-2-3-实现具体命令" class="headerlink" title="14.2.3 实现具体命令"></a>14.2.3 实现具体命令</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 具体命令 - 打开灯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span> : <span class="hljs-keyword">public</span> Command &#123;<br><span class="hljs-keyword">private</span>:<br>    Light* light; <span class="hljs-comment">// 持有接收者的引用</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LightOnCommand</span>(Light* light) : <span class="hljs-built_in">light</span>(light) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        light-&gt;<span class="hljs-built_in">turnOn</span>(); <span class="hljs-comment">// 调用接收者的方法</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体命令 - 关闭灯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOffCommand</span> : <span class="hljs-keyword">public</span> Command &#123;<br><span class="hljs-keyword">private</span>:<br>    Light* light;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LightOffCommand</span>(Light* light) : <span class="hljs-built_in">light</span>(light) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        light-&gt;<span class="hljs-built_in">turnOff</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="14-2-4-定义调用者"><a href="#14-2-4-定义调用者" class="headerlink" title="14.2.4 定义调用者"></a>14.2.4 定义调用者</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 调用者 - 遥控器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Command* command; <span class="hljs-comment">// 持有命令的引用</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command* command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;command = command; <span class="hljs-comment">// 设置命令</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pressButton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (command) &#123;<br>            command-&gt;<span class="hljs-built_in">execute</span>(); <span class="hljs-comment">// 执行命令</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="14-2-5-客户端代码"><a href="#14-2-5-客户端代码" class="headerlink" title="14.2.5 客户端代码"></a>14.2.5 客户端代码</h5><p>在客户端代码中，您可以创建命令、接收者和调用者，并通过调用者执行命令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Light* light = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Light</span>(); <span class="hljs-comment">// 创建接收者</span><br>    Command* lightOn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LightOnCommand</span>(light); <span class="hljs-comment">// 创建打开灯的命令</span><br>    Command* lightOff = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LightOffCommand</span>(light); <span class="hljs-comment">// 创建关闭灯的命令</span><br><br>    RemoteControl* remote = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RemoteControl</span>(); <span class="hljs-comment">// 创建遥控器</span><br><br>    <span class="hljs-comment">// 打开灯</span><br>    remote-&gt;<span class="hljs-built_in">setCommand</span>(lightOn);<br>    remote-&gt;<span class="hljs-built_in">pressButton</span>();<br><br>    <span class="hljs-comment">// 关闭灯</span><br>    remote-&gt;<span class="hljs-built_in">setCommand</span>(lightOff);<br>    remote-&gt;<span class="hljs-built_in">pressButton</span>();<br><br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-keyword">delete</span> lightOn;<br>    <span class="hljs-keyword">delete</span> lightOff;<br>    <span class="hljs-keyword">delete</span> remote;<br>    <span class="hljs-keyword">delete</span> light;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="14-3-命令模式的优缺点"><a href="#14-3-命令模式的优缺点" class="headerlink" title="14.3 命令模式的优缺点"></a>14.3 命令模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>解耦请求发起者和请求接收者</strong>：命令模式将请求的发送者与接收者解耦，使它们可以独立变化。</li><li><strong>支持撤销和重做操作</strong>：命令对象可以存储状态，允许实现撤销和重做的功能。</li><li><strong>易于扩展</strong>：添加新命令只需实现新的命令类，而无需更改现有代码。</li><li><strong>可以支持日志记录</strong>：可以记录请求以支持操作的日志功能。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>增加系统复杂性</strong>：命令模式引入了许多类，可能导致系统结构变得复杂。</li><li><strong>可能会导致类膨胀</strong>：每个命令都需要一个类，如果命令种类繁多，可能会导致大量类的生成。</li></ol><h4 id="14-4-适用场景"><a href="#14-4-适用场景" class="headerlink" title="14.4 适用场景"></a>14.4 适用场景</h4><ul><li>需要将请求调用的发起者和接收者解耦。</li><li>希望支持撤销和重做操作。</li><li>需要记录请求的日志或实现宏命令（将多个命令组合成一个命令）。</li><li>希望使用不同的请求对客户端进行参数化。</li></ul><h4 id="14-5-总结"><a href="#14-5-总结" class="headerlink" title="14.5 总结"></a>14.5 总结</h4><p>命令模式通过将请求封装为对象，使得请求的发送者与接收者解耦，增加了系统的灵活性和可扩展性。它适用于需要记录操作、支持撤销&#x2F;重做和希望将请求处理逻辑与请求发起者分离的场景。</p><h3 id="15-解释器（Interpreter）"><a href="#15-解释器（Interpreter）" class="headerlink" title="15.解释器（Interpreter）"></a>15.解释器（Interpreter）</h3><p>为语言创建解释器，定义语言的语法表示和解释器。适合用于构建简单的脚本或规则引擎。</p><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，用于定义一种语言的文法表示，并提供一个解释器来处理该文法。这个模式的主要目的是将某种特定的语言表达式转化为可执行的操作，常用于需要处理特定语法或格式的应用场景，比如编程语言、数据库查询、表达式求值等。</p><h4 id="15-1-主要角色"><a href="#15-1-主要角色" class="headerlink" title="15.1 主要角色"></a>15.1 主要角色</h4><ol><li><strong>抽象表达式（Abstract Expression）</strong>：<ul><li>声明一个用于解释的接口。</li></ul></li><li><strong>终结符表达式（Terminal Expression）</strong>：<ul><li>实现了抽象表达式接口，表示文法的基本元素。终结符表达式通常对应于文法中的叶子节点。</li></ul></li><li><strong>非终结符表达式（Non-terminal Expression）</strong>：<ul><li>也实现了抽象表达式接口，表示文法中的组合规则。它通常由其他表达式组成。</li></ul></li><li><strong>上下文（Context）</strong>：<ul><li>包含解释器所需的信息，通常用于存储输入数据。</li></ul></li></ol><h4 id="15-2-示例"><a href="#15-2-示例" class="headerlink" title="15.2 示例"></a>15.2 示例</h4><p>以下是一个使用解释器模式的简单示例，模拟对基本数学表达式的解析和计算。</p><h5 id="15-2-1-定义抽象表达式"><a href="#15-2-1-定义抽象表达式" class="headerlink" title="15.2.1 定义抽象表达式"></a>15.2.1 定义抽象表达式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Expression</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 解释接口</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Expression</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="15-2-2-实现终结符表达式"><a href="#15-2-2-实现终结符表达式" class="headerlink" title="15.2.2 实现终结符表达式"></a>15.2.2 实现终结符表达式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-comment">// 终结符表达式 - 变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableExpression</span> : <span class="hljs-keyword">public</span> Expression &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string name; <span class="hljs-comment">// 变量名</span><br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt;&amp; context; <span class="hljs-comment">// 上下文引用</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">VariableExpression</span>(<span class="hljs-type">const</span> std::string&amp; name, std::map&lt;std::string, <span class="hljs-type">int</span>&gt;&amp; context)<br>        : <span class="hljs-built_in">name</span>(name), <span class="hljs-built_in">context</span>(context) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 根据上下文返回变量的值</span><br>        <span class="hljs-keyword">return</span> context[name];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="15-2-3-实现非终结符表达式"><a href="#15-2-3-实现非终结符表达式" class="headerlink" title="15.2.3 实现非终结符表达式"></a>15.2.3 实现非终结符表达式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 非终结符表达式 - 加法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddExpression</span> : <span class="hljs-keyword">public</span> Expression &#123;<br><span class="hljs-keyword">private</span>:<br>    Expression* left; <span class="hljs-comment">// 左操作数</span><br>    Expression* right; <span class="hljs-comment">// 右操作数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AddExpression</span>(Expression* left, Expression* right)<br>        : <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpret</span>() + right-&gt;<span class="hljs-built_in">interpret</span>(); <span class="hljs-comment">// 执行加法</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">AddExpression</span>() &#123;<br>        <span class="hljs-keyword">delete</span> left; <span class="hljs-comment">// 清理内存</span><br>        <span class="hljs-keyword">delete</span> right;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 非终结符表达式 - 减法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractExpression</span> : <span class="hljs-keyword">public</span> Expression &#123;<br><span class="hljs-keyword">private</span>:<br>    Expression* left;<br>    Expression* right;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SubtractExpression</span>(Expression* left, Expression* right)<br>        : <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpret</span>() - right-&gt;<span class="hljs-built_in">interpret</span>(); <span class="hljs-comment">// 执行减法</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">SubtractExpression</span>() &#123;<br>        <span class="hljs-keyword">delete</span> left;<br>        <span class="hljs-keyword">delete</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="15-2-4-客户端代码"><a href="#15-2-4-客户端代码" class="headerlink" title="15.2.4 客户端代码"></a>15.2.4 客户端代码</h5><p>在客户端代码中，您可以创建表达式并执行解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; context; <span class="hljs-comment">// 上下文存储变量</span><br>    context[<span class="hljs-string">&quot;x&quot;</span>] = <span class="hljs-number">5</span>;<br>    context[<span class="hljs-string">&quot;y&quot;</span>] = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 创建表达式: x + y - 2</span><br>    Expression* expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SubtractExpression</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddExpression</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">VariableExpression</span>(<span class="hljs-string">&quot;x&quot;</span>, context), <span class="hljs-keyword">new</span> <span class="hljs-built_in">VariableExpression</span>(<span class="hljs-string">&quot;y&quot;</span>, context)),<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">VariableExpression</span>(<span class="hljs-string">&quot;2&quot;</span>, context)<br>    );<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; expression-&gt;<span class="hljs-built_in">interpret</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出结果</span><br><br>    <span class="hljs-keyword">delete</span> expression; <span class="hljs-comment">// 清理内存</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-3-解释器模式的优缺点"><a href="#15-3-解释器模式的优缺点" class="headerlink" title="15.3 解释器模式的优缺点"></a>15.3 解释器模式的优缺点</h4><p><strong>优点</strong>：</p><ol><li><strong>简化代码</strong>：通过将文法规则封装为对象，代码变得更加清晰和易于理解。</li><li><strong>易于扩展</strong>：可以通过添加新的终结符和非终结符类来扩展新的文法规则，而无需修改现有代码。</li><li><strong>实现简洁</strong>：对于简单的文法，解释器模式实现起来相对简单。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>性能问题</strong>：对于复杂的文法，可能会导致性能问题，因为每个表达式都需要创建一个对象。</li><li><strong>难以维护</strong>：如果文法规则复杂，可能导致系统的维护变得困难，因为类的数量可能会显著增加。</li><li><strong>适用性限制</strong>：只适合用来处理简单的语法；复杂的语言解析通常更适合使用编译器设计技术。</li></ol><h4 id="15-4-适用场景"><a href="#15-4-适用场景" class="headerlink" title="15.4 适用场景"></a>15.4 适用场景</h4><ul><li>需要对某种语言的语法进行解释和执行。</li><li>需要解析简单的文法规则，如计算表达式。</li><li>需要支持新的文法规则扩展。</li></ul><h4 id="15-5-总结"><a href="#15-5-总结" class="headerlink" title="15.5 总结"></a>15.5 总结</h4><p>解释器模式为处理和解释特定语言或格式提供了一种灵活的解决方案。它将文法规则与执行逻辑分离，使得扩展和维护变得更加容易。然而，解释器模式通常只适用于简单的文法，对于复杂的语法解析，更适合使用其他编译原理的方法。</p><p><em><strong>tips：文法（区别语法：特指文法中的结构规则，描述如何正确地组合符号和单词来形成有效的程序或表达式）</strong></em></p><p><em>在计算机科学中，文法通常指的是编程语言或数据格式的语法规则。它定义了合法的语句和表达式的结构。这种文法通常用形式语言的规则来表示，包括：</em></p><ul><li><em><strong>终结符</strong>（Terminal Symbols）：文法中最基本的符号，无法被进一步分解。</em></li><li><em><strong>非终结符</strong>（Non-terminal Symbols）：可以被替换为一个或多个终结符或其他非终结符的符号。</em></li><li><em><strong>产生式</strong>（Production Rules）：描述了非终结符如何被替换为其他符号的规则。</em></li></ul><p>常见的文法类型包括：</p><ul><li><strong>上下文无关文法</strong>（Context-Free Grammar, CFG）：用于描述编程语言的语法，常用于编译器。</li><li><strong>正则文法</strong>（Regular Grammar）：用于描述正则表达式。</li></ul><h3 id="16-迭代器（Iterator）"><a href="#16-迭代器（Iterator）" class="headerlink" title="16.迭代器（Iterator）"></a>16.迭代器（Iterator）</h3><p>提供一种方法来顺序访问集合中的元素，而不暴露底层结构。</p><p>迭代器（Iterator）是一种设计模式和编程概念，用于提供对集合（如数组、列表、树等）中元素的顺序访问，而无需暴露集合的内部结构。迭代器模式允许开发者在不直接操作集合的情况下，遍历集合中的元素，从而提供了一种统一的访问接口。</p><h4 id="16-1-主要组成部分"><a href="#16-1-主要组成部分" class="headerlink" title="16.1 主要组成部分"></a>16.1 主要组成部分</h4><ol><li><strong>迭代器接口</strong>：<ul><li>定义用于访问集合元素的方法，如 <code>next()</code>、<code>hasNext()</code> 等。</li></ul></li><li><strong>具体迭代器</strong>：<ul><li>实现了迭代器接口，维护当前的遍历状态（如当前位置）并实现具体的遍历逻辑。</li></ul></li><li><strong>聚合类（集合）</strong>：<ul><li>提供创建迭代器的接口，通常会有一个方法返回一个新的迭代器实例。</li></ul></li></ol><h4 id="16-2-迭代器的基本功能"><a href="#16-2-迭代器的基本功能" class="headerlink" title="16.2 迭代器的基本功能"></a>16.2 迭代器的基本功能</h4><p>迭代器通常提供以下基本功能：</p><ul><li><strong>初始化</strong>：将迭代器设置到集合的开始位置。</li><li><strong>访问元素</strong>：提供方法获取当前元素。</li><li><strong>移动到下一个元素</strong>：提供方法移动到下一个元素。</li><li><strong>检查是否有下一个元素</strong>：提供方法检查是否还有更多元素可以访问。</li></ul><h4 id="16-3-C-中的迭代器"><a href="#16-3-C-中的迭代器" class="headerlink" title="16.3 C++ 中的迭代器"></a>16.3 C++ 中的迭代器</h4><p>在 C++ 中，标准模板库（STL）提供了强大的迭代器支持，迭代器可以用于遍历容器（如 <code>std::vector</code>、<code>std::list</code>、<code>std::map</code> 等）。</p><p>以下是一个简单的例子，展示了如何使用 C++ 的迭代器遍历一个 <code>std::vector</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个整数向量</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 使用迭代器遍历向量</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>    <span class="hljs-keyword">for</span> (it = numbers.<span class="hljs-built_in">begin</span>(); it != numbers.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出当前元素</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="16-4-C-迭代器的类型"><a href="#16-4-C-迭代器的类型" class="headerlink" title="16.4 C++ 迭代器的类型"></a>16.4 C++ 迭代器的类型</h4><p>在 C++ 中，迭代器有不同的类型，具体包括：</p><ol><li><strong>输入迭代器（Input Iterator）</strong>：<ul><li>只允许读取数据，通常用于单次遍历。</li></ul></li><li><strong>输出迭代器（Output Iterator）</strong>：<ul><li>只允许写入数据，通常用于向集合中添加元素。</li></ul></li><li><strong>前向迭代器（Forward Iterator）</strong>：<ul><li>支持多次遍历，但只能向前移动。</li></ul></li><li><strong>双向迭代器（Bidirectional Iterator）</strong>：<ul><li>支持向前和向后移动，适用于如 <code>std::list</code> 等容器。</li></ul></li><li><strong>随机访问迭代器（Random Access Iterator）</strong>：<ul><li>支持快速随机访问，允许在容器中任意位置移动，适用于如 <code>std::vector</code> 等容器。</li></ul></li></ol><h4 id="16-5-迭代器的优点"><a href="#16-5-迭代器的优点" class="headerlink" title="16.5 迭代器的优点"></a>16.5 迭代器的优点</h4><ul><li><strong>封装性</strong>：迭代器隐藏了集合的具体实现，使得集合的内部结构对外部代码透明。</li><li><strong>统一接口</strong>：通过相同的接口访问不同类型的集合，增强了代码的灵活性和可重用性。</li><li><strong>简化代码</strong>：提供了简洁的方式遍历集合，减少了使用索引的复杂性。</li></ul><h4 id="16-6-迭代器的缺点"><a href="#16-6-迭代器的缺点" class="headerlink" title="16.6 迭代器的缺点"></a>16.6 迭代器的缺点</h4><ul><li><strong>性能开销</strong>：某些情况下，使用迭代器可能会带来额外的性能开销，尤其是在频繁创建和销毁迭代器的场景中。</li><li><strong>复杂性</strong>：对于某些复杂数据结构，迭代器的实现可能会增加系统的复杂性。</li></ul><h4 id="16-7总结"><a href="#16-7总结" class="headerlink" title="16.7总结"></a>16.7总结</h4><p>迭代器是一种重要的设计模式，用于简化集合的遍历操作。通过提供统一的接口，迭代器不仅提高了代码的可读性和可维护性，还使得对不同类型集合的操作变得更加一致。迭代器在现代 C++ 编程中被广泛使用，是 STL 的核心部分之一。</p><h3 id="17-中介者（Mediator）"><a href="#17-中介者（Mediator）" class="headerlink" title="17.中介者（Mediator）"></a>17.中介者（Mediator）</h3><p>使用一个中介对象来管理对象之间的交互，从而减少类之间的耦合。</p><p>中介者（Mediator）是一种设计模式，旨在减少对象之间的直接通信，从而降低它们之间的耦合。通过引入一个中介者对象来协调各个对象的交互，中介者模式可以使得对象之间的通信变得更加清晰、灵活，并且易于维护。</p><h4 id="17-1-主要组成部分"><a href="#17-1-主要组成部分" class="headerlink" title="17.1 主要组成部分"></a>17.1 主要组成部分</h4><ol><li><strong>中介者接口</strong>：<ul><li>定义一个接口，声明所有参与者（同事对象）之间的交互方法。</li></ul></li><li><strong>具体中介者</strong>：<ul><li>实现中介者接口，并维护对所有参与者的引用。负责协调参与者之间的交互。</li></ul></li><li><strong>同事类</strong>：<ul><li>参与者（对象），它们通过中介者进行交互，而不是直接相互通信。</li></ul></li></ol><h4 id="17-2-中介者的工作原理"><a href="#17-2-中介者的工作原理" class="headerlink" title="17.2 中介者的工作原理"></a>17.2 中介者的工作原理</h4><ul><li>同事对象通过中介者对象进行通信，而不是直接彼此交互。</li><li>中介者负责协调同事对象之间的行为和交互，处理它们之间的复杂关系。</li><li>通过中介者，可以在不修改同事对象的情况下，添加新的同事或改变交互规则。</li></ul><h4 id="17-3-示例"><a href="#17-3-示例" class="headerlink" title="17.3 示例"></a>17.3 示例</h4><p>下面是一个使用中介者模式的简单示例，模拟一个聊天系统中的用户和聊天室的交互：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span>;<br><br><span class="hljs-comment">// 同事类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">User</span>(Mediator* mediator, <span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">mediator</span>(mediator), <span class="hljs-built_in">name</span>(name) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>        std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Mediator* mediator;<br>    std::string name;<br>&#125;;<br><br><span class="hljs-comment">// 中介者接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message, User* user)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体中介者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> : <span class="hljs-keyword">public</span> Mediator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User* user)</span> </span>&#123;<br>        users.<span class="hljs-built_in">push_back</span>(user);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message, User* user)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u : users) &#123;<br>            <span class="hljs-keyword">if</span> (u != user) &#123; <span class="hljs-comment">// 不发给发送者</span><br>                u-&gt;<span class="hljs-built_in">receiveMessage</span>(message);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;User*&gt; users; <span class="hljs-comment">// 参与者列表</span><br>&#125;;<br><br><span class="hljs-comment">// 同事类方法实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">User::sendMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>    std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; sends: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    mediator-&gt;<span class="hljs-built_in">sendMessage</span>(message, <span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ChatRoom chatRoom;<br><br>    <span class="hljs-function">User <span class="hljs-title">alice</span><span class="hljs-params">(&amp;chatRoom, <span class="hljs-string">&quot;Alice&quot;</span>)</span></span>;<br>    <span class="hljs-function">User <span class="hljs-title">bob</span><span class="hljs-params">(&amp;chatRoom, <span class="hljs-string">&quot;Bob&quot;</span>)</span></span>;<br><br>    chatRoom.<span class="hljs-built_in">addUser</span>(&amp;alice);<br>    chatRoom.<span class="hljs-built_in">addUser</span>(&amp;bob);<br><br>    alice.<span class="hljs-built_in">sendMessage</span>(<span class="hljs-string">&quot;Hello, Bob!&quot;</span>);<br>    bob.<span class="hljs-built_in">sendMessage</span>(<span class="hljs-string">&quot;Hi, Alice!&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="17-4-中介者模式的优点"><a href="#17-4-中介者模式的优点" class="headerlink" title="17.4 中介者模式的优点"></a>17.4 中介者模式的优点</h4><ol><li><strong>降低耦合</strong>：<ul><li>中介者模式通过将对象之间的交互封装到中介者中，减少了对象之间的直接依赖，从而降低了耦合度。</li></ul></li><li><strong>集中管理</strong>：<ul><li>所有的交互逻辑集中在中介者中，易于维护和扩展。</li></ul></li><li><strong>灵活性</strong>：<ul><li>可以方便地添加新的同事类或修改现有的交互规则，而不需要修改其他同事类的代码。</li></ul></li><li><strong>清晰的交互</strong>：<ul><li>通过中介者的引入，系统中的对象交互变得更加清晰，易于理解。</li></ul></li></ol><h4 id="17-5-中介者模式的缺点"><a href="#17-5-中介者模式的缺点" class="headerlink" title="17.5 中介者模式的缺点"></a>17.5 中介者模式的缺点</h4><ol><li><strong>单点故障</strong>：<ul><li>中介者作为中央协调者，如果出现问题，可能会影响到所有同事对象的交互。</li></ul></li><li><strong>复杂性增加</strong>：<ul><li>如果中介者变得过于复杂，可能会导致代码的可维护性下降。</li></ul></li><li><strong>性能开销</strong>：<ul><li>引入中介者可能会增加一定的性能开销，尤其是在需要频繁交互的场景中。</li></ul></li></ol><h4 id="17-6-总结"><a href="#17-6-总结" class="headerlink" title="17.6 总结"></a>17.6 总结</h4><p>中介者模式是一种有效的设计模式，适用于复杂对象之间的交互场景。通过将对象之间的交互逻辑集中到中介者中，可以减少对象之间的耦合，提高系统的灵活性和可维护性。中介者模式在GUI框架、消息传递系统和事件处理系统等场景中广泛应用。</p><h3 id="18-备忘录（Memento）"><a href="#18-备忘录（Memento）" class="headerlink" title="18.备忘录（Memento）"></a>18.备忘录（Memento）</h3><p>在不暴露内部状态的情况下保存对象的状态，以便稍后恢复。常用于实现撤销功能。</p><p>备忘录（Memento）是一种设计模式，主要用于在不违反封装性的情况下，捕获和保存一个对象的内部状态，以便在将来能够恢复到这个状态。备忘录模式的核心思想是提供一个机制，允许对象在未来的某个时间点恢复其之前的状态，而无需公开其内部实现细节。</p><h4 id="18-1-主要组成部分"><a href="#18-1-主要组成部分" class="headerlink" title="18.1 主要组成部分"></a>18.1 主要组成部分</h4><ol><li><strong>备忘录（Memento）</strong>：<ul><li>用于存储对象的内部状态。备忘录对象通常是不可变的，以确保其状态在被外部对象访问时不会被修改。</li></ul></li><li><strong>发起人（Originator）</strong>：<ul><li>需要保存状态的对象。发起人可以创建一个备忘录对象来保存其当前状态，也可以从备忘录中恢复状态。</li></ul></li><li><strong>管理者（Caretaker）</strong>：<ul><li>负责管理备忘录，保存备忘录的对象。管理者不允许直接访问备忘录的内容，而只是存储和恢复备忘录。</li></ul></li></ol><h4 id="18-2-备忘录的工作原理"><a href="#18-2-备忘录的工作原理" class="headerlink" title="18.2 备忘录的工作原理"></a>18.2 备忘录的工作原理</h4><ul><li>发起人创建一个备忘录，保存其当前状态。</li><li>管理者存储备忘录。</li><li>当需要恢复状态时，发起人可以使用备忘录恢复到之前的状态。</li></ul><h4 id="18-3-示例"><a href="#18-3-示例" class="headerlink" title="18.3 示例"></a>18.3 示例</h4><p>以下是一个使用备忘录模式的简单示例，模拟文本编辑器的撤销操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 备忘录类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Memento</span>(<span class="hljs-type">const</span> std::string&amp; state) : <span class="hljs-built_in">state</span>(state) &#123;&#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string state; <span class="hljs-comment">// 存储状态</span><br>&#125;;<br><br><span class="hljs-comment">// 发起人类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;state = state;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Setting state to: &quot;</span> &lt;&lt; state &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function">std::unique_ptr&lt;Memento&gt; <span class="hljs-title">saveStateToMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Memento&gt;(state); <span class="hljs-comment">// 保存当前状态</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getStateFromMemento</span><span class="hljs-params">(<span class="hljs-type">const</span> Memento&amp; memento)</span> </span>&#123;<br>        state = memento.<span class="hljs-built_in">getState</span>(); <span class="hljs-comment">// 从备忘录恢复状态</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Restored state to: &quot;</span> &lt;&lt; state &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string state; <span class="hljs-comment">// 发起人的状态</span><br>&#125;;<br><br><span class="hljs-comment">// 管理者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveState</span><span class="hljs-params">(Originator&amp; originator)</span> </span>&#123;<br>        memento = originator.<span class="hljs-built_in">saveStateToMemento</span>(); <span class="hljs-comment">// 保存发起人的状态</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restoreState</span><span class="hljs-params">(Originator&amp; originator)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (memento) &#123;<br>            originator.<span class="hljs-built_in">getStateFromMemento</span>(*memento); <span class="hljs-comment">// 从备忘录恢复状态</span><br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;Memento&gt; memento; <span class="hljs-comment">// 存储备忘录</span><br>&#125;;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Originator originator;<br>    Caretaker caretaker;<br><br>    originator.<span class="hljs-built_in">setState</span>(<span class="hljs-string">&quot;State 1&quot;</span>);<br>    caretaker.<span class="hljs-built_in">saveState</span>(originator);<br><br>    originator.<span class="hljs-built_in">setState</span>(<span class="hljs-string">&quot;State 2&quot;</span>);<br>    caretaker.<span class="hljs-built_in">saveState</span>(originator);<br><br>    originator.<span class="hljs-built_in">setState</span>(<span class="hljs-string">&quot;State 3&quot;</span>);<br>    <br>    <span class="hljs-comment">// 恢复到之前的状态</span><br>    caretaker.<span class="hljs-built_in">restoreState</span>(originator); <span class="hljs-comment">// 恢复到 State 2</span><br>    caretaker.<span class="hljs-built_in">restoreState</span>(originator); <span class="hljs-comment">// 恢复到 State 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="18-4-备忘录模式的优点"><a href="#18-4-备忘录模式的优点" class="headerlink" title="18.4 备忘录模式的优点"></a>18.4 备忘录模式的优点</h4><ol><li><strong>封装性</strong>：<ul><li>备忘录模式可以在不暴露对象内部状态的情况下保存和恢复状态，保护了对象的封装性。</li></ul></li><li><strong>简化撤销操作</strong>：<ul><li>备忘录模式特别适合实现撤销（Undo）功能，可以方便地保存和恢复状态。</li></ul></li><li><strong>历史记录</strong>：<ul><li>可以保存多个状态的备忘录，使得对象可以在多个历史状态之间切换。</li></ul></li></ol><h4 id="18-5-备忘录模式的缺点"><a href="#18-5-备忘录模式的缺点" class="headerlink" title="18.5 备忘录模式的缺点"></a>18.5 备忘录模式的缺点</h4><ol><li><strong>内存开销</strong>：<ul><li>如果状态数据很大，可能会消耗较多内存来存储多个备忘录。</li></ul></li><li><strong>性能问题</strong>：<ul><li>频繁创建和销毁备忘录可能会影响性能。</li></ul></li><li><strong>实现复杂性</strong>：<ul><li>在某些情况下，管理多个备忘录可能会使得实现变得复杂。</li></ul></li></ol><h4 id="18-6-总结"><a href="#18-6-总结" class="headerlink" title="18.6 总结"></a>18.6 总结</h4><p>备忘录模式是一种重要的设计模式，适用于需要保存和恢复对象状态的场景，尤其是在实现撤销操作时。通过将状态保存和恢复的逻辑封装在备忘录中，备忘录模式不仅可以保护对象的内部状态，还能使得对象之间的交互变得更加灵活。</p><h3 id="19-观察者（Observer）"><a href="#19-观察者（Observer）" class="headerlink" title="19.观察者（Observer）"></a>19.观察者（Observer）</h3><p>定义对象之间的依赖关系，便于在一个对象发生变化时通知依赖的对象。</p><p>观察者模式（Observer Pattern）是一种行为型设计模式，定义了一种一对多的依赖关系，让多个观察者对象能够同时监听和响应一个主题对象的状态变化。这个模式通常用于实现事件处理系统或消息发布-订阅机制。</p><h4 id="19-1-主要组成部分"><a href="#19-1-主要组成部分" class="headerlink" title="19.1 主要组成部分"></a>19.1 主要组成部分</h4><ol><li><strong>主题（Subject）</strong>：<ul><li>主题是被观察的对象，负责维护一组观察者并通知它们状态的变化。主题通常提供添加、移除观察者的接口。</li></ul></li><li><strong>观察者（Observer）</strong>：<ul><li>观察者是需要对主题的状态变化做出反应的对象。每个观察者都实现一个更新接口，以接收主题的通知。</li></ul></li><li><strong>具体主题（Concrete Subject）</strong>：<ul><li>具体主题实现了主题接口，维护观察者的集合，并在其状态变化时通知所有观察者。</li></ul></li><li><strong>具体观察者（Concrete Observer）</strong>：<ul><li>具体观察者实现了观察者接口，定义了在接收到主题通知时应执行的具体操作。</li></ul></li></ol><h4 id="19-2-工作原理"><a href="#19-2-工作原理" class="headerlink" title="19.2 工作原理"></a>19.2 工作原理</h4><ul><li>观察者注册到主题中。</li><li>当主题的状态发生变化时，它会通知所有注册的观察者。</li><li>观察者接收到通知后，根据主题的状态执行相应的操作。</li></ul><h4 id="19-3-示例"><a href="#19-3-示例" class="headerlink" title="19.3  示例"></a>19.3  示例</h4><p>以下是一个使用观察者模式的简单示例，模拟天气监测系统：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 观察者接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 主题接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer* observer)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer* observer)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体主题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> : <span class="hljs-keyword">public</span> Subject &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;Observer*&gt; observers;<br>    <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-type">float</span> humidity;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer* observer)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        observers.<span class="hljs-built_in">push_back</span>(observer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer* observer)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        observers.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(observers.<span class="hljs-built_in">begin</span>(), observers.<span class="hljs-built_in">end</span>(), observer), observers.<span class="hljs-built_in">end</span>());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer* observer : observers) &#123;<br>            observer-&gt;<span class="hljs-built_in">update</span>(temperature, humidity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMeasurements</span><span class="hljs-params">(<span class="hljs-type">float</span> temp, <span class="hljs-type">float</span> hum)</span> </span>&#123;<br>        temperature = temp;<br>        humidity = hum;<br>        <span class="hljs-built_in">notifyObservers</span>(); <span class="hljs-comment">// 通知所有观察者</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体观察者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditionsDisplay</span> : <span class="hljs-keyword">public</span> Observer &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-type">float</span> humidity;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temp, <span class="hljs-type">float</span> hum)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        temperature = temp;<br>        humidity = hum;<br>        <span class="hljs-built_in">display</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Current conditions: &quot;</span> &lt;&lt; temperature &lt;&lt; <span class="hljs-string">&quot;°C and &quot;</span> &lt;&lt; humidity &lt;&lt; <span class="hljs-string">&quot;% humidity&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    WeatherData weatherData;<br><br>    CurrentConditionsDisplay currentDisplay;<br>    weatherData.<span class="hljs-built_in">registerObserver</span>(&amp;currentDisplay);<br><br>    weatherData.<span class="hljs-built_in">setMeasurements</span>(<span class="hljs-number">30.0f</span>, <span class="hljs-number">65.0f</span>);<br>    weatherData.<span class="hljs-built_in">setMeasurements</span>(<span class="hljs-number">28.0f</span>, <span class="hljs-number">70.0f</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="19-4-观察者模式的优点"><a href="#19-4-观察者模式的优点" class="headerlink" title="19.4 观察者模式的优点"></a>19.4 观察者模式的优点</h4><ol><li><strong>解耦</strong>：<ul><li>观察者模式将主题和观察者解耦，主题不需要知道观察者的具体实现，从而提高了模块之间的独立性。</li></ul></li><li><strong>动态关系</strong>：<ul><li>观察者可以在运行时动态注册和注销，提供了灵活的对象间关系。</li></ul></li><li><strong>多重观察者</strong>：<ul><li>主题可以通知多个观察者，适合于一对多的场景。</li></ul></li></ol><h4 id="19-5-观察者模式的缺点"><a href="#19-5-观察者模式的缺点" class="headerlink" title="19.5 观察者模式的缺点"></a>19.5 观察者模式的缺点</h4><ol><li><strong>性能问题</strong>：<ul><li>当观察者数量较多或通知频繁时，可能会导致性能下降。</li></ul></li><li><strong>循环依赖</strong>：<ul><li>如果观察者中也注册了主题，可能会导致循环依赖和无限循环通知的问题。</li></ul></li><li><strong>复杂性</strong>：<ul><li>在实现时可能需要处理观察者的注册、注销和通知逻辑，增加了系统的复杂性。</li></ul></li></ol><h4 id="19-6-应用场景"><a href="#19-6-应用场景" class="headerlink" title="19.6 应用场景"></a>19.6 应用场景</h4><p>观察者模式广泛应用于需要广播通信的场景，如：</p><ul><li>GUI 事件处理系统。</li><li>数据监控系统（如股票、天气等）。</li><li>MVC（模型-视图-控制器）架构中，模型可以作为主题，视图作为观察者。</li><li>发布-订阅系统。</li></ul><h4 id="19-7-总结"><a href="#19-7-总结" class="headerlink" title="19.7 总结"></a>19.7 总结</h4><p>观察者模式是一种强大的设计模式，用于处理对象之间的依赖关系。通过使用观察者模式，可以有效地管理对象之间的交互，使得代码更加灵活和可维护。</p><h3 id="20-状态（State）"><a href="#20-状态（State）" class="headerlink" title="20.状态（State）"></a>20.状态（State）</h3><p>允许对象在状态变化时更改其行为。通常是通过改变其内部状态类来实现的。</p><p>状态模式（State Pattern）是一种行为型设计模式，它允许对象在其内部状态发生变化时改变其行为。换句话说，状态模式使得一个对象的行为可以根据其状态的不同而变化，适用于那些在不同状态下表现出不同行为的对象。</p><h4 id="20-1-主要组成部分"><a href="#20-1-主要组成部分" class="headerlink" title="20.1 主要组成部分"></a>20.1 主要组成部分</h4><ol><li><strong>上下文（Context）</strong>：<ul><li>上下文维护一个对状态对象的引用，通常是一个接口类型。上下文会委托状态对象来处理具体的行为。</li></ul></li><li><strong>状态接口（State）</strong>：<ul><li>定义了与上下文相关的状态所需的接口，通常包含一些用于处理状态转换的方法。</li></ul></li><li><strong>具体状态（Concrete State）</strong>：<ul><li>实现状态接口的类，每个具体状态类都实现了在该状态下应执行的行为。</li></ul></li></ol><h4 id="20-2-工作原理"><a href="#20-2-工作原理" class="headerlink" title="20.2 工作原理"></a>20.2 工作原理</h4><ul><li>当上下文的状态发生变化时，它会切换到另一个具体状态对象。</li><li>状态对象可以在自己的内部逻辑中决定何时切换到另一个状态。</li><li>上下文将请求委托给当前的状态对象。</li></ul><h4 id="20-3-示例"><a href="#20-3-示例" class="headerlink" title="20.3 示例"></a>20.3 示例</h4><p>以下是一个简单的示例，演示了一个文本编辑器的状态：草稿、提交和审核。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 状态接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DocumentState</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draft</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">review</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DocumentState</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 上下文</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;DocumentState&gt; state;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Document</span>(std::unique_ptr&lt;DocumentState&gt; initialState) : <span class="hljs-built_in">state</span>(std::<span class="hljs-built_in">move</span>(initialState)) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(std::unique_ptr&lt;DocumentState&gt; newState)</span> </span>&#123;<br>        state = std::<span class="hljs-built_in">move</span>(newState);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draft</span><span class="hljs-params">()</span> </span>&#123;<br>        state-&gt;<span class="hljs-built_in">draft</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">()</span> </span>&#123;<br>        state-&gt;<span class="hljs-built_in">submit</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">review</span><span class="hljs-params">()</span> </span>&#123;<br>        state-&gt;<span class="hljs-built_in">review</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体状态：草稿状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DraftState</span> : <span class="hljs-keyword">public</span> DocumentState &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draft</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Document is already in draft state.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Submitting the document.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">review</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t review, first submit the document.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体状态：提交状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubmittedState</span> : <span class="hljs-keyword">public</span> DocumentState &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draft</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t edit, document is submitted.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Document is already submitted.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">review</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Reviewing the submitted document.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体状态：审核状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReviewState</span> : <span class="hljs-keyword">public</span> DocumentState &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draft</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t edit, document is under review.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t submit, document is under review.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">review</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Document is already under review.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Document <span class="hljs-title">doc</span><span class="hljs-params">(std::make_unique&lt;DraftState&gt;())</span></span>;<br>    <br>    doc.<span class="hljs-built_in">draft</span>();   <span class="hljs-comment">// Document is already in draft state.</span><br>    doc.<span class="hljs-built_in">submit</span>();  <span class="hljs-comment">// Submitting the document.</span><br>    <br>    <span class="hljs-comment">// 状态转换</span><br>    doc.<span class="hljs-built_in">setState</span>(std::<span class="hljs-built_in">make_unique</span>&lt;SubmittedState&gt;());<br>    doc.<span class="hljs-built_in">submit</span>();  <span class="hljs-comment">// Document is already submitted.</span><br>    doc.<span class="hljs-built_in">review</span>();  <span class="hljs-comment">// Reviewing the submitted document.</span><br><br>    <span class="hljs-comment">// 状态转换</span><br>    doc.<span class="hljs-built_in">setState</span>(std::<span class="hljs-built_in">make_unique</span>&lt;ReviewState&gt;());<br>    doc.<span class="hljs-built_in">review</span>();  <span class="hljs-comment">// Document is already under review.</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="20-4-状态模式的优点"><a href="#20-4-状态模式的优点" class="headerlink" title="20.4 状态模式的优点"></a>20.4 状态模式的优点</h4><ol><li><strong>简化代码</strong>：<ul><li>状态模式将与状态相关的行为集中在状态类中，避免了使用大量的条件语句（如if-else或switch）。</li></ul></li><li><strong>易于扩展</strong>：<ul><li>可以轻松地添加新状态，只需创建新的状态类并实现状态接口，而不需要修改现有代码。</li></ul></li><li><strong>状态封装</strong>：<ul><li>每个状态的行为都被封装在相应的状态类中，符合单一职责原则。</li></ul></li></ol><h4 id="20-5-状态模式的缺点"><a href="#20-5-状态模式的缺点" class="headerlink" title="20.5 状态模式的缺点"></a>20.5 状态模式的缺点</h4><ol><li><strong>类数量增加</strong>：<ul><li>每个状态通常需要一个类，可能导致类的数量增加，增加系统的复杂性。</li></ul></li><li><strong>状态转移管理</strong>：<ul><li>状态转移的逻辑可能会变得复杂，特别是在多个状态之间存在相互依赖时。</li></ul></li></ol><h4 id="20-6-应用场景"><a href="#20-6-应用场景" class="headerlink" title="20.6 应用场景"></a>20.6 应用场景</h4><p>状态模式适用于以下场景：</p><ul><li>需要根据对象的内部状态改变其行为的场合。</li><li>复杂的状态转移逻辑，适合通过状态模式进行封装。</li><li>需要动态改变对象的状态并调整行为的应用。</li></ul><h4 id="20-7-总结"><a href="#20-7-总结" class="headerlink" title="20.7 总结"></a>20.7 总结</h4><p>状态模式提供了一种灵活的方式来处理对象状态的变化。通过使用状态模式，可以使代码更加清晰、易于维护和扩展。它在许多应用中都得到了广泛的应用，特别是在需要处理复杂状态的情况下。</p><h3 id="21-策略（Strategy）"><a href="#21-策略（Strategy）" class="headerlink" title="21.策略（Strategy）"></a>21.策略（Strategy）</h3><p>定义一系列算法，将它们封装在可互换的类中，使得算法可以独立于使用它的客户端变化。</p><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的行为。通过将算法的实现放在独立的策略类中，策略模式使得客户端可以根据需要在运行时选择和切换不同的策略。这样可以避免使用大量的条件语句（如if-else或switch）来选择算法的实现，提高代码的可维护性和可扩展性。</p><h4 id="21-1-主要组成部分"><a href="#21-1-主要组成部分" class="headerlink" title="21.1 主要组成部分"></a>21.1 主要组成部分</h4><ol><li><strong>策略接口（Strategy）</strong>：<ul><li>定义了一系列算法或操作的方法接口，通常会有一个执行的方法。</li></ul></li><li><strong>具体策略（Concrete Strategy）</strong>：<ul><li>实现策略接口的具体类，每个具体策略类定义了不同的算法或操作。</li></ul></li><li><strong>上下文（Context）</strong>：<ul><li>持有对策略接口的引用，用于在运行时调用策略的行为。上下文可以动态地切换所使用的策略。</li></ul></li></ol><h4 id="21-2-工作原理"><a href="#21-2-工作原理" class="headerlink" title="21.2 工作原理"></a>21.2 工作原理</h4><ul><li>客户端创建一个上下文，并传入所需的具体策略。</li><li>上下文调用策略的执行方法，具体策略类的实现决定了实际的行为。</li><li>客户端可以随时更改上下文中的策略，以便在运行时选择不同的行为。</li></ul><h4 id="21-3-示例"><a href="#21-3-示例" class="headerlink" title="21.3 示例"></a>21.3 示例</h4><p>以下是一个简单的示例，展示了不同的排序策略（如冒泡排序和快速排序）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 策略接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortStrategy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SortStrategy</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体策略：冒泡排序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> : <span class="hljs-keyword">public</span> SortStrategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Using Bubble Sort.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (data[j] &gt; data[j + <span class="hljs-number">1</span>]) &#123;<br>                    std::<span class="hljs-built_in">swap</span>(data[j], data[j + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体策略：快速排序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> : <span class="hljs-keyword">public</span> SortStrategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Using Quick Sort.&quot;</span> &lt;&lt; std::endl;<br>        std::<span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 上下文</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    SortStrategy* strategy;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sorter</span>(SortStrategy* strat) : <span class="hljs-built_in">strategy</span>(strat) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setStrategy</span><span class="hljs-params">(SortStrategy* strat)</span> </span>&#123;<br>        strategy = strat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span> </span>&#123;<br>        strategy-&gt;<span class="hljs-built_in">sort</span>(data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><br>    <span class="hljs-function">Sorter <span class="hljs-title">sorter</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BubbleSort())</span></span>;<br>    sorter.<span class="hljs-built_in">sort</span>(data); <span class="hljs-comment">// 使用冒泡排序</span><br><br>    sorter.<span class="hljs-built_in">setStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QuickSort</span>());<br>    sorter.<span class="hljs-built_in">sort</span>(data); <span class="hljs-comment">// 使用快速排序</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="21-4-策略模式的优点"><a href="#21-4-策略模式的优点" class="headerlink" title="21.4 策略模式的优点"></a>21.4 策略模式的优点</h4><ol><li><strong>消除了条件语句</strong>：<ul><li>策略模式将条件语句移到策略类中，使得代码更加清晰。</li></ul></li><li><strong>易于扩展</strong>：<ul><li>可以方便地添加新策略，只需实现新的策略类，而不需要修改现有代码。</li></ul></li><li><strong>算法的封装</strong>：<ul><li>每个算法被封装在独立的策略类中，符合单一职责原则。</li></ul></li><li><strong>动态选择算法</strong>：<ul><li>客户端可以在运行时选择不同的算法，增加了灵活性。</li></ul></li></ol><h4 id="21-5-策略模式的缺点"><a href="#21-5-策略模式的缺点" class="headerlink" title="21.5 策略模式的缺点"></a>21.5 策略模式的缺点</h4><ol><li><strong>类的数量增加</strong>：<ul><li>每个策略通常需要一个类，可能导致类的数量增加。</li></ul></li><li><strong>客户端需要了解所有策略</strong>：<ul><li>客户端需要知道可用的策略类，可能导致客户端变得复杂。</li></ul></li></ol><h4 id="21-6-应用场景"><a href="#21-6-应用场景" class="headerlink" title="21.6 应用场景"></a>21.6 应用场景</h4><p>策略模式适用于以下场景：</p><ul><li>需要在运行时选择算法的场合。</li><li>有多个算法可以相互替换，且客户端希望能够自由切换的场合。</li><li>需要消除条件语句，增加代码的可维护性和可读性。</li></ul><h4 id="21-7-总结"><a href="#21-7-总结" class="headerlink" title="21.7 总结"></a>21.7 总结</h4><p>策略模式提供了一种灵活的方式来定义和选择算法。通过使用策略模式，代码可以更加清晰和易于扩展，使得在不同的上下文中选择合适的算法成为可能。策略模式在许多应用中都得到了广泛的应用，特别是在需要多种可替换算法的情况下。</p><h3 id="22-模板方法（Template-Method）"><a href="#22-模板方法（Template-Method）" class="headerlink" title="22.模板方法（Template Method）"></a>22.模板方法（Template Method）</h3><p>定义算法框架，允许子类重写特定步骤，而不改变算法的结构。</p><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤的实现延迟到子类中。通过这种方式，模板方法允许子类在不改变算法结构的情况下重新定义算法的某些特定步骤。这个模式的关键在于，父类提供了算法的基本框架，而具体的实现则由子类完成。</p><h4 id="22-1-主要组成部分"><a href="#22-1-主要组成部分" class="headerlink" title="22.1 主要组成部分"></a>22.1 主要组成部分</h4><ol><li><strong>抽象类（Abstract Class）</strong>：<ul><li>定义了一个模板方法（template method），包含了算法的基本结构。模板方法通常是一个公共的方法，包含了一系列的调用顺序。</li><li>包含一些抽象方法，这些方法需要在子类中实现，以便完成具体的操作。</li></ul></li><li><strong>具体类（Concrete Class）</strong>：<ul><li>实现抽象类中定义的抽象方法，提供具体的操作步骤。</li></ul></li></ol><h4 id="22-2-工作原理"><a href="#22-2-工作原理" class="headerlink" title="22.2 工作原理"></a>22.2 工作原理</h4><ul><li>客户端调用模板方法，该方法按照固定的步骤调用抽象方法和具体实现的方法。</li><li>具体类提供了算法的具体实现，用户可以通过继承来扩展或修改算法的某些部分。</li></ul><h4 id="22-3-示例"><a href="#22-3-示例" class="headerlink" title="22.3 示例"></a>22.3 示例</h4><p>以下是一个简单的示例，展示了制作饮料的过程，其中不同的饮料有不同的制作方式（如茶和咖啡）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CaffeineBeverage</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 模板方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepareRecipe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">boilWater</span>();<br>        <span class="hljs-built_in">brew</span>();<br>        <span class="hljs-built_in">pourInCup</span>();<br>        <span class="hljs-built_in">addCondiments</span>();<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addCondiments</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">boilWater</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Boiling water&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Pouring into cup&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体类：茶</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> CaffeineBeverage &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Steeping the tea&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addCondiments</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Adding lemon&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体类：咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> CaffeineBeverage &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Dripping coffee through filter&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addCondiments</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Adding sugar and milk&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    CaffeineBeverage* tea = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Tea</span>();<br>    tea-&gt;<span class="hljs-built_in">prepareRecipe</span>(); <span class="hljs-comment">// 制作茶</span><br><br>    std::cout &lt;&lt; std::endl;<br><br>    CaffeineBeverage* coffee = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Coffee</span>();<br>    coffee-&gt;<span class="hljs-built_in">prepareRecipe</span>(); <span class="hljs-comment">// 制作咖啡</span><br><br>    <span class="hljs-keyword">delete</span> tea;<br>    <span class="hljs-keyword">delete</span> coffee;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="22-4-模板方法模式的优点"><a href="#22-4-模板方法模式的优点" class="headerlink" title="22.4 模板方法模式的优点"></a>22.4 模板方法模式的优点</h4><ol><li><strong>代码复用</strong>：<ul><li>通过将共同的算法步骤放在基类中，可以避免代码重复，提高代码复用率。</li></ul></li><li><strong>控制算法的结构</strong>：<ul><li>基类定义了算法的结构，子类只能改变算法的特定部分，确保了算法的一致性。</li></ul></li><li><strong>方便扩展</strong>：<ul><li>通过创建新的子类，可以方便地添加新的算法，而无需修改现有代码。</li></ul></li></ol><h4 id="22-5-模板方法模式的缺点"><a href="#22-5-模板方法模式的缺点" class="headerlink" title="22.5 模板方法模式的缺点"></a>22.5 模板方法模式的缺点</h4><ol><li><strong>基类与子类之间的紧耦合</strong>：<ul><li>由于模板方法在基类中定义，子类必须遵循该结构，可能会限制子类的灵活性。</li></ul></li><li><strong>类的数量增加</strong>：<ul><li>每个算法都需要一个子类，可能导致类的数量增加。</li></ul></li></ol><h4 id="22-6-应用场景"><a href="#22-6-应用场景" class="headerlink" title="22.6 应用场景"></a>22.6 应用场景</h4><p>模板方法模式适用于以下场景：</p><ul><li>在多个子类中有相同的算法步骤，但某些步骤的实现可能不同的情况。</li><li>当需要控制算法的整体结构并允许部分步骤的变化时。</li></ul><h4 id="22-7-总结"><a href="#22-7-总结" class="headerlink" title="22.7 总结"></a>22.7 总结</h4><p>模板方法模式通过定义算法的骨架，允许子类在不改变算法结构的情况下实现具体的步骤。这种模式通过将公共代码放在基类中，避免了代码的重复，提高了代码的复用性和可维护性。模板方法模式在许多框架和库中得到了广泛应用，例如许多设计模式中的实现都体现了这一模式。</p><h3 id="23-访问者（Visitor）"><a href="#23-访问者（Visitor）" class="headerlink" title="23.访问者（Visitor）"></a>23.访问者（Visitor）</h3><p>定义作用于对象结构的操作，将操作与对象的结构分离。可以在不更改类的前提下增加新操作。</p><p>访问者模式（Visitor Pattern）是一种行为型设计模式，它允许你在不修改对象结构的前提下，定义新的操作。通过将这些操作封装到访问者对象中，访问者模式使得可以在一组对象上执行不同的操作。</p><h4 id="23-1-主要组成部分"><a href="#23-1-主要组成部分" class="headerlink" title="23.1 主要组成部分"></a>23.1 主要组成部分</h4><ol><li><strong>抽象访问者（Visitor）</strong>：<ul><li>定义对每个具体元素类的访问方法（<code>visit</code> 方法）。</li></ul></li><li><strong>具体访问者（Concrete Visitor）</strong>：<ul><li>实现抽象访问者中的方法，定义对具体元素的具体操作。</li></ul></li><li><strong>抽象元素（Element）</strong>：<ul><li>定义一个接受访问者的方法（<code>accept</code> 方法），该方法通常接收一个访问者对象。</li></ul></li><li><strong>具体元素（Concrete Element）</strong>：<ul><li>实现抽象元素，并在接受访问者时调用访问者的方法。</li></ul></li><li><strong>对象结构（Object Structure）</strong>：<ul><li>维护一组元素，可以遍历这些元素，并通过访问者访问它们。</li></ul></li></ol><h4 id="23-2-工作原理"><a href="#23-2-工作原理" class="headerlink" title="23.2 工作原理"></a>23.2 工作原理</h4><ul><li>客户端代码创建一个访问者实例，并将其传递给对象结构中的元素。</li><li>每个元素调用访问者的相关方法，允许访问者对其进行操作。</li></ul><h4 id="23-3-示例"><a href="#23-3-示例" class="headerlink" title="23.3 示例"></a>23.3 示例</h4><p>以下是一个简单的示例，展示了如何使用访问者模式来计算不同形状的面积和周长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>;<br><br><span class="hljs-comment">// 抽象访问者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeVisitor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Circle* circle)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Square* square)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 抽象元素</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(ShapeVisitor* visitor)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体元素：圆形</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> radius) : <span class="hljs-built_in">radius</span>(radius) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(ShapeVisitor* visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor-&gt;<span class="hljs-built_in">visit</span>(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> radius;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-comment">// 具体元素：正方形</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Square</span>(<span class="hljs-type">double</span> side) : <span class="hljs-built_in">side</span>(side) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(ShapeVisitor* visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor-&gt;<span class="hljs-built_in">visit</span>(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getSide</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> side;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> side;<br>&#125;;<br><br><span class="hljs-comment">// 具体访问者：计算面积</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AreaVisitor</span> : <span class="hljs-keyword">public</span> ShapeVisitor &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Circle* circle)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">double</span> area = <span class="hljs-number">3.14159</span> * circle-&gt;<span class="hljs-built_in">getRadius</span>() * circle-&gt;<span class="hljs-built_in">getRadius</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Circle Area: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Square* square)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">double</span> area = square-&gt;<span class="hljs-built_in">getSide</span>() * square-&gt;<span class="hljs-built_in">getSide</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Square Area: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体访问者：计算周长</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PerimeterVisitor</span> : <span class="hljs-keyword">public</span> ShapeVisitor &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Circle* circle)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">double</span> perimeter = <span class="hljs-number">2</span> * <span class="hljs-number">3.14159</span> * circle-&gt;<span class="hljs-built_in">getRadius</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Circle Perimeter: &quot;</span> &lt;&lt; perimeter &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Square* square)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">double</span> perimeter = <span class="hljs-number">4</span> * square-&gt;<span class="hljs-built_in">getSide</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Square Perimeter: &quot;</span> &lt;&lt; perimeter &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Shape*&gt; shapes;<br>    shapes.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>(<span class="hljs-number">5</span>));<br>    shapes.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Square</span>(<span class="hljs-number">4</span>));<br><br>    AreaVisitor areaVisitor;<br>    PerimeterVisitor perimeterVisitor;<br><br>    <span class="hljs-keyword">for</span> (Shape* shape : shapes) &#123;<br>        shape-&gt;<span class="hljs-built_in">accept</span>(&amp;areaVisitor);<br>        shape-&gt;<span class="hljs-built_in">accept</span>(&amp;perimeterVisitor);<br>    &#125;<br><br>    <span class="hljs-comment">// 清理内存</span><br>    <span class="hljs-keyword">for</span> (Shape* shape : shapes) &#123;<br>        <span class="hljs-keyword">delete</span> shape;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="23-4-访问者模式的优点"><a href="#23-4-访问者模式的优点" class="headerlink" title="23.4 访问者模式的优点"></a>23.4 访问者模式的优点</h4><ol><li><strong>分离操作和对象结构</strong>：<ul><li>访问者模式将操作的实现与对象结构的定义分离，使得可以在不修改对象结构的情况下增加新的操作。</li></ul></li><li><strong>增加新的操作</strong>：<ul><li>只需添加新的访问者类就可以增加新的操作，而不需要修改已有的类。</li></ul></li><li><strong>强类型操作</strong>：<ul><li>由于每个访问者都为每种具体元素提供了类型安全的操作，避免了类型转换带来的错误。</li></ul></li></ol><h4 id="23-5-访问者模式的缺点"><a href="#23-5-访问者模式的缺点" class="headerlink" title="23.5 访问者模式的缺点"></a>23.5 访问者模式的缺点</h4><ol><li><strong>对象结构的变化</strong>：<ul><li>如果对象结构发生变化（添加新元素类），需要修改所有访问者的实现，增加了维护成本。</li></ul></li><li><strong>复杂性</strong>：<ul><li>增加了系统的复杂性，尤其是在元素类和访问者类较多的情况下。</li></ul></li></ol><h4 id="23-6-应用场景"><a href="#23-6-应用场景" class="headerlink" title="23.6 应用场景"></a>23.6 应用场景</h4><p>访问者模式适用于以下场景：</p><ul><li>对于一个对象结构中的元素需要执行很多不同操作，但这些操作的实现又不会影响到元素的结构。</li><li>需要在不改变元素类的情况下增加新的操作。</li></ul><h4 id="23-7-总结"><a href="#23-7-总结" class="headerlink" title="23.7 总结"></a>23.7 总结</h4><p>访问者模式通过将操作封装在访问者对象中，使得可以在不修改对象结构的情况下为对象添加新的操作。通过将行为与对象的状态分离，访问者模式提供了良好的扩展性和灵活性，但也带来了额外的复杂性和维护成本。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2024/04/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/04/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1.创建线程"></a>1.创建线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pringt</span><span class="hljs-params">(std::string str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)<br>&#123;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1.创建线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">thread1</span><span class="hljs-params">(pringt,<span class="hljs-string">&quot;hello thread&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 2.1 等待线程1结束再结束主线程</span><br><span class="hljs-comment">//thread1.join(); </span><br>    <span class="hljs-comment">// 2.2 线程分离</span><br><span class="hljs-comment">//thread1.detach();</span><br><span class="hljs-comment">// 2.3 先判断能否join</span><br><span class="hljs-type">bool</span> isJoin = thread<span class="hljs-number">1.</span><span class="hljs-built_in">joinable</span>();<br><span class="hljs-keyword">if</span> (isJoin)<br>&#123;<br>thread<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 代码阻塞在这里</span><br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;over&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-常见错误"><a href="#2-常见错误" class="headerlink" title="2.常见错误"></a>2.常见错误</h2><ul><li>忘记等待线程完成或分离线程：如果我们创建了一个线程，但没有等待它完成或分离它，那么在主线程结束时，可能会导致未定义行为。</li><li>访问共享数据时没有同步：如果我们在多个线程中访问共享数据，但没有使用同步机制，那么可能会导致数据竞争、死锁等问题。</li><li>异常传递问题：如果在线程中发生了异常，但没有处理它，那么可能会导致程序崩溃。因此，我们应该在线程中使用try-catch块来捕获异常，并在适当的地方处理它。</li></ul><ol><li><p>传递临时变量的问题：</p></li><li><p>传递指针或引用指向局部变量的问题：</p></li><li><p>传递指针或引用指向已释放的内存的问题：</p></li><li><p>类成员函数作为入口函数，类对象被提前释放</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><br>std::thread thread2;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>x += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>thread2 = std::<span class="hljs-built_in">thread</span>(foo, std::<span class="hljs-built_in">ref</span>(a));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function">std::thread <span class="hljs-title">thread1</span><span class="hljs-params">(foo, std::ref(a))</span></span>;  <span class="hljs-comment">//传递引用</span><br><br><span class="hljs-built_in">test</span>();<br><span class="hljs-comment">//thread2.join();//这里会报错,局部变量a的地址已经被释放掉了</span><br><br><br><br><br>thread<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-生产者消费者"><a href="#3-生产者消费者" class="headerlink" title="3.生产者消费者"></a>3.生产者消费者</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt;         <span class="hljs-type">queue_t</span>;<br>std::condition_variable condition;<br>std::mutex              mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Productor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-type">queue_t</span>.<span class="hljs-built_in">push</span>(i);<br>        condition.<span class="hljs-built_in">notify_one</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Productor : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        condition.<span class="hljs-built_in">wait</span>(lock, []() &#123;<br>            <span class="hljs-keyword">return</span> !<span class="hljs-type">queue_t</span>.<span class="hljs-built_in">empty</span>();<br>        &#125;);<br>        <span class="hljs-type">int</span> value = <span class="hljs-type">queue_t</span>.<span class="hljs-built_in">front</span>();<br><span class="hljs-type">queue_t</span>.<span class="hljs-built_in">pop</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Consumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(Productor)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(Consumer)</span></span>;<br><br>t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C11 新特性详细学习</title>
    <link href="/2023/08/08/C11%E7%89%B9%E6%80%A7/"/>
    <url>/2023/08/08/C11%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>C++11新特性</font></center><h3 id="1-原始字面量"><a href="#1-原始字面量" class="headerlink" title="1.原始字面量"></a>1.原始字面量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string str = <span class="hljs-string">R&quot;xxx(c\n\n)xxx&quot;</span>;<br><span class="hljs-comment">//（）里面是什么，就是什么字符，不需要转译</span><br><span class="hljs-comment">//xxx是注释，要求左右对齐</span><br></code></pre></td></tr></table></figure><h3 id="2-常量表达式constexpr"><a href="#2-常量表达式constexpr" class="headerlink" title="2.常量表达式constexpr"></a>2.常量表达式constexpr</h3><h3 id="3-decltype自动推导"><a href="#3-decltype自动推导" class="headerlink" title="3.decltype自动推导"></a>3.decltype自动推导</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">decltype</span>(a) b = <span class="hljs-number">11</span>;  <span class="hljs-comment">//int</span><br><span class="hljs-keyword">decltype</span>(a<span class="hljs-number">+3.14</span>) c = <span class="hljs-number">1.11</span>;  <span class="hljs-comment">//double</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    string text;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">110</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">99</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y = x;<br>    <span class="hljs-keyword">decltype</span>(x) a = x;<br>    <span class="hljs-keyword">decltype</span>(y) b = x;<br>    <span class="hljs-keyword">decltype</span>(Test::value) c = <span class="hljs-number">0</span>;<br><br>    Test t;<br>    <span class="hljs-keyword">decltype</span>(t.text) d = <span class="hljs-string">&quot;hello, world&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//变量a被推导为 int类型</span><br><span class="hljs-comment">//变量b被推导为 const int &amp;类型</span><br><span class="hljs-comment">//变量c被推导为 const int类型</span><br><span class="hljs-comment">//变量d被推导为 string类型</span><br></code></pre></td></tr></table></figure><p>(1)表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的。</p><p>(2)表达式是函数调用，使用decltype推导出的类型和函数返回值一致。</p><p>(3)表达式是一个左值，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> Test obj;<br>    <span class="hljs-comment">//带有括号的表达式</span><br>    <span class="hljs-keyword">decltype</span>(obj.num) a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">decltype</span>((obj.num)) b = a;<br>    <span class="hljs-comment">//加法表达式</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">decltype</span>(n + m) c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">decltype</span>(n = n + m) d = n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>obj.num 为类的成员访问表达式，符合场景1，因此 a 的类型为int<br>obj.num 带有括号，符合场景3，因此b 的类型为 const int&amp;。<br>n+m 得到一个右值，符合场景1，因此c的类型为 int<br>n&#x3D;n+m 得到一个左值 n，符合场景3，因此d的类型为 int&amp;</p><p>返回值类型重置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-comment">// 返回类型后置语法</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t + u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t + u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>    x = <span class="hljs-number">520</span>;<br>    <span class="hljs-type">double</span> y = <span class="hljs-number">13.14</span>;<br>    <span class="hljs-comment">// auto z = add&lt;int, double&gt;(x, y);</span><br>    <span class="hljs-keyword">auto</span> z = <span class="hljs-built_in">add</span>(x, y); <span class="hljs-comment">// 简化之后的写法</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自动类型推导参考：</p><p><a href="https://subingwen.cn/cpp/autotype/">https://subingwen.cn/cpp/autotype/</a></p><h3 id="4-final和override"><a href="#4-final和override" class="headerlink" title="4.final和override"></a>4.final和override</h3><p>override表明子类要重写子类虚函数</p><p>final和override用法一样，但是final是断子绝孙类</p><p>（1）final修饰函数（只能修饰虚函数，且不可继承）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class...&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Child class...&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandChild</span> : <span class="hljs-keyword">public</span> Child<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 语法错误, 不允许重写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;GrandChild class...&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(2) final修饰类(修饰类不可以被继承)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class...&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">final</span>: <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Child class...&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// error, 语法错误</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandChild</span> : <span class="hljs-keyword">public</span> Child<br>&#123;<br><span class="hljs-keyword">public</span>:<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-using"><a href="#5-using" class="headerlink" title="5.using"></a>5.using</h3><p>typedef和using类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> 新的类型 = 旧的类型;<br><span class="hljs-comment">// 使用举例</span><br><span class="hljs-keyword">using</span> <span class="hljs-type">uint_t</span> = <span class="hljs-type">int</span>;<br><br><span class="hljs-comment">// 使用typedef定义函数指针</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span><span class="hljs-params">(*func_ptr)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-comment">// 使用using定义函数指针</span><br><span class="hljs-keyword">using</span> func_ptr1 = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>);<br></code></pre></td></tr></table></figure><h3 id="6-模板默认参数"><a href="#6-模板默认参数" class="headerlink" title="6.模板默认参数"></a>6.模板默认参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R = <span class="hljs-type">int</span>, <span class="hljs-keyword">typename</span> N&gt;<br></code></pre></td></tr></table></figure><p>模板会自动推导类型，如果推导不出来，使用默认参数</p><h3 id="7-委托构造函数"><a href="#7-委托构造函数" class="headerlink" title="7.委托构造函数"></a>7.委托构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123;&#125;;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> max)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_max = max &gt; <span class="hljs-number">0</span> ? max : <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> max, <span class="hljs-type">int</span> min):<span class="hljs-built_in">Test</span>(max)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_min = min &gt; <span class="hljs-number">0</span> &amp;&amp; min &lt; max ? min : <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> max, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> mid):<span class="hljs-built_in">Test</span>(max, min)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="hljs-number">50</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m_min;<br>    <span class="hljs-type">int</span> m_max;<br>    <span class="hljs-type">int</span> m_middle;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">90</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="hljs-string">&quot;, middle: &quot;</span> <br>         &lt;&lt; t.m_middle &lt;&lt; <span class="hljs-string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>1.不要循环委托</p><p>2.放在初始化列表委托，免得重定义（初始化列表为直接构造，函数中调用先赋值给形参，再初始化）</p><h3 id="8-继承构造"><a href="#8-继承构造" class="headerlink" title="8.继承构造"></a>8.继承构造</h3><p><code>using 类名::构造函数名</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">m_i</span>(i) &#123;&#125;<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> j) :<span class="hljs-built_in">m_i</span>(i), <span class="hljs-built_in">m_j</span>(j) &#123;&#125;<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> j, string k) :<span class="hljs-built_in">m_i</span>(i), <span class="hljs-built_in">m_j</span>(j), <span class="hljs-built_in">m_k</span>(k) &#123;&#125;<br><br>    <span class="hljs-type">int</span> m_i;<br>    <span class="hljs-type">double</span> m_j;<br>    string m_k;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::Base;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Child <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">520</span>, <span class="hljs-number">13.14</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;int: &quot;</span> &lt;&lt; c<span class="hljs-number">1.</span>m_i &lt;&lt; <span class="hljs-string">&quot;, double: &quot;</span> &lt;&lt; c<span class="hljs-number">1.</span>m_j &lt;&lt; endl;<br>    <span class="hljs-function">Child <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">520</span>, <span class="hljs-number">13.14</span>, <span class="hljs-string">&quot;i love you&quot;</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;int: &quot;</span> &lt;&lt; c<span class="hljs-number">2.</span>m_i &lt;&lt; <span class="hljs-string">&quot;, double: &quot;</span> <br>         &lt;&lt; c<span class="hljs-number">2.</span>m_j &lt;&lt; <span class="hljs-string">&quot;, string: &quot;</span> &lt;&lt; c<span class="hljs-number">2.</span>m_k &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-std-initializer-list"><a href="#9-std-initializer-list" class="headerlink" title="9.std::initializer_list"></a>9.std::initializer_list</h3><p>在C++的STL容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用std::initializer_list这个轻量级的类模板来实现。</p><p>先来介绍一下这个类模板的一些特点：</p><ul><li>它是一个轻量级的容器类型，内部定义了迭代器iterator等容器必须的概念，遍历时得到的迭代器是只读的。</li><li>对于std::initializer_list<T>而言，它可以接收任意长度的初始化列表，但是要求元素必须是同种类型T</li><li>在std::initializer_list内部有三个成员接口：size(), begin(), end()。</li><li>std::initializer_list对象只能被整体初始化或者赋值。</li></ul><p>函数直接传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); ++it)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    initializer_list&lt;<span class="hljs-type">int</span>&gt; list;<br>    cout &lt;&lt; <span class="hljs-string">&quot;current list size: &quot;</span> &lt;&lt; list.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-built_in">traversal</span>(list);<br><br>    list = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span> &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;current list size: &quot;</span> &lt;&lt; list.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-built_in">traversal</span>(list);<br>    cout &lt;&lt; endl;<br>    <br>    list = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span> &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;current list size: &quot;</span> &lt;&lt; list.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-built_in">traversal</span>(list);<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">////////////////////////////////////////////////////</span><br>    <span class="hljs-comment">////////////// 直接通过初始化列表传递数据 //////////////</span><br>    <span class="hljs-comment">////////////////////////////////////////////////////</span><br>    <span class="hljs-built_in">traversal</span>(&#123; <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span> &#125;);<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-built_in">traversal</span>(&#123; <span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span> &#125;);<br>    cout &lt;&lt; endl;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;构造传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(std::initializer_list&lt;string&gt; list)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = list.<span class="hljs-built_in">begin</span>(); it != list.<span class="hljs-built_in">end</span>(); ++it)<br>        &#123;<br>            cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            m_names.<span class="hljs-built_in">push_back</span>(*it);<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; m_names;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(&#123; <span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;lucy&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span> &#125;)</span></span>;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(&#123; <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;nihao&quot;</span>, <span class="hljs-string">&quot;shijie&quot;</span> &#125;)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-基于范围的for循环"><a href="#10-基于范围的for循环" class="headerlink" title="10.基于范围的for循环"></a>10.基于范围的for循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> value : t)&#123;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; value : t)&#123;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; value : t)&#123;&#125; <br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>元素只读，<code>set</code>容器，或者<code>map</code>不可修改<code>key</code>值</p></li><li><p>访问次数</p><ul><li>基于范围的for循环遍历的对象可以是一个表达式或者容器&#x2F;数组等。假设我们对一个容器进行遍历，在遍历过程中for循环对这个容器的访问频率是一次还是多次呢？我们通过下面的例子验证一下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">getRange</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;get vector range...&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : <span class="hljs-built_in">getRange</span>())<br>    &#123;<br>        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">get vector range...<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="11-可调用对象"><a href="#11-可调用对象" class="headerlink" title="11.可调用对象"></a>11.可调用对象</h3><p>在C++中存在“可调用对象”这么一个概念。准确来说，可调用对象有如下几种定义：</p><ul><li>是一个函数指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">print1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;print1&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 定义函数指针</span><br><span class="hljs-built_in">int</span> (*func)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &amp;print1;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    a=<span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a=func(1, 1)=&quot;</span> &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>是一个具有operator()成员函数的类对象（仿函数）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-comment">// ()操作符重载</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t;<br>    <span class="hljs-built_in">t</span>(<span class="hljs-string">&quot;我是要成为海贼王的男人!!!&quot;</span>);<span class="hljs-comment">// 仿函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>是一个可被转换为函数指针的类对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> func_ptr = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, string);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a, string b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 将类对象转换为函数指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">func_ptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> print;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t;<br>    <span class="hljs-comment">// 对象转换为函数指针, 并调用</span><br>    <span class="hljs-built_in">t</span>(<span class="hljs-number">19</span>, <span class="hljs-string">&quot;Monkey D. Luffy&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>是一个类成员函数指针或者类成员指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a, string b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">// 定义类成员函数指针指向类成员函数</span><br>    <span class="hljs-comment">//void (Test::*func_ptr)(int, string) = &amp;Test::print;</span><br><span class="hljs-keyword">using</span> func_ptr = <span class="hljs-built_in">void</span>(Test::*)(<span class="hljs-type">int</span>,string);<br>func_ptr f1 = &amp;Test::print;    <br><span class="hljs-comment">// 类成员指针指向类成员变量</span><br>    <span class="hljs-comment">//int Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="hljs-keyword">using</span> obj_ptr1 = <span class="hljs-type">int</span> Test::*;<br>obj_ptr1 pt = &amp; Test::m_num;<br><br><span class="hljs-comment">//     Test t;</span><br><span class="hljs-comment">//     // 通过类成员函数指针调用类成员函数</span><br><span class="hljs-comment">//     (t.*func_ptr)(19, &quot;Monkey D. Luffy&quot;);</span><br><span class="hljs-comment">//     // 通过类成员指针初始化类成员变量</span><br><span class="hljs-comment">//     t.*obj_ptr = 1;</span><br><span class="hljs-comment">//     cout &lt;&lt; &quot;number is: &quot; &lt;&lt; t.m_num &lt;&lt; endl;</span><br><br>Test t;<br>(t.*f1)(<span class="hljs-number">19</span>, <span class="hljs-string">&quot;Monkey D. Luffy&quot;</span>);<br>t.*pt = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;number is: &quot;</span> &lt;&lt; t.m_num &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中满足条件的这些可调用对象对应的类型被统称为可调用类型。C++中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。</p><h3 id="12-可调用对象包装器"><a href="#12-可调用对象包装器" class="headerlink" title="12.可调用对象包装器"></a>12.可调用对象包装器</h3><p>包含头文件<code>#include&lt;functional&gt;</code></p><p>使用语法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br>std::function&lt;返回值类型(参数类型列表)&gt; diy_name = 可调用对象;<br></code></pre></td></tr></table></figure><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1.包装普通函数</span><br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f1 = add;<br>    <span class="hljs-comment">// 2.包装静态类成员函数</span><br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f2 = T1::sub;<br>    <span class="hljs-comment">// 3.包装仿函数</span><br>    T2                      t;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f3 = t;<br><br>    <span class="hljs-comment">// 函数调用</span><br>    <span class="hljs-built_in">f1</span>(<span class="hljs-number">9</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">f2</span>(<span class="hljs-number">9</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">f3</span>(<span class="hljs-number">9</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过测试代码可以得到结论：std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</p><h4 id="2-作为回调函数使用"><a href="#2-作为回调函数使用" class="headerlink" title="2.作为回调函数使用"></a>2.作为回调函数使用</h4><p>因为回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用，来看一下下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数参数是一个包装器对象</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> function&lt;<span class="hljs-built_in">void</span>()&gt;&amp; f) : <span class="hljs-built_in">callback</span>(f)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">callback</span>(); <span class="hljs-comment">// 调用通过构造函数得到的函数指针</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    function&lt;<span class="hljs-type">void</span>()&gt; callback;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;我是要成为海贼王的男人!!!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(b)</span></span>; <span class="hljs-comment">// 仿函数通过包装器对象进行包装</span><br>    a.<span class="hljs-built_in">notify</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的例子可以看出，使用对象包装器std::function可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p><p>另外，使用std::function作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><h3 id="13-绑定器"><a href="#13-绑定器" class="headerlink" title="13.绑定器"></a>13.绑定器</h3><p>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。通俗来讲，它主要有两大作用：</p><ul><li>1.将可调用对象与其参数一起绑定成一个仿函数。</li><li>2.将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。</li></ul><p>绑定器函数使用语法格式如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 绑定非类成员函数/变量</span><br><span class="hljs-built_in">auto</span> f = std::bind(可调用对象地址, 绑定的参数/占位符);<br><span class="hljs-comment">// 绑定类成员函/变量</span><br><span class="hljs-built_in">auto</span> f = std::bind(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);<br></code></pre></td></tr></table></figure><p>下面来看一个关于绑定器的实际使用的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; &amp; f)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">f</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output_add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; x + <span class="hljs-number">10</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用绑定器绑定可调用对象和参数</span><br>    <span class="hljs-keyword">auto</span> f1 = <span class="hljs-built_in">bind</span>(output, placeholders::_1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">callFunc</span>(i, f1);<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">auto</span> f2 = <span class="hljs-built_in">bind</span>(output_add, placeholders::_1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">callFunc</span>(i, f2);<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的程序中，使用了std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。</p><p>placeholders::_1是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符placeholders::_2、placeholders::_3、placeholders::_4、placeholders::_5等……</p><p>下面是占位符和默认参数的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span><br>    <span class="hljs-built_in">bind</span>(output, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)();  <span class="hljs-comment">// 1  2</span><br>    <span class="hljs-built_in">bind</span>(output, placeholders::_1, <span class="hljs-number">2</span>)(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 10 2</span><br>    <span class="hljs-built_in">bind</span>(output, <span class="hljs-number">2</span>, placeholders::_1)(<span class="hljs-number">10</span>);                    <span class="hljs-comment">// 2  10</span><br><br>    <span class="hljs-comment">// error, 调用时没有第二个参数</span><br>    <span class="hljs-comment">// bind(output, 2, placeholders::_2)(10);</span><br>    <span class="hljs-comment">// 调用时第一个参数10被吞掉了，没有被使用</span><br>    <span class="hljs-built_in">bind</span>(output, <span class="hljs-number">2</span>, placeholders::_2)(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 2  20</span><br><br>    <span class="hljs-built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 10 20</span><br>    <span class="hljs-built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 20 10</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过测试可以看到，std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于调用发生时的第几个参数。</p><p>可调用对象包装器std::function是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器std::bind的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_number = <span class="hljs-number">100</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t;<br>    <span class="hljs-comment">// 绑定类成员函数</span><br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f1 = <br>        <span class="hljs-built_in">bind</span>(&amp;Test::output, &amp;t, placeholders::_1, placeholders::_2);<br>    <span class="hljs-comment">// 绑定类成员变量(公共)</span><br>    function&lt;<span class="hljs-type">int</span>&amp;(<span class="hljs-type">void</span>)&gt; f2 = <span class="hljs-built_in">bind</span>(&amp;Test::m_number, &amp;t);<br><br>    <span class="hljs-comment">// 调用</span><br>    <span class="hljs-built_in">f1</span>(<span class="hljs-number">520</span>, <span class="hljs-number">1314</span>);<br>    <span class="hljs-built_in">f2</span>() = <span class="hljs-number">2333</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;t.m_number: &quot;</span> &lt;&lt; t.m_number &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</p><p>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</p><p>示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用auto进行类型的自动推导，这样使用起来会更容易一些。</p><h3 id="14-lambda表达式"><a href="#14-lambda表达式" class="headerlink" title="14. lambda表达式"></a>14. lambda表达式</h3><h4 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1.基本用法"></a>1.基本用法</h4><p>lambda表达式是C++11最重要也是最常用的特性之一，这是现代编程语言的一个特点，lambda表达式有如下的一些优点：</p><ul><li>声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li><li>简洁：避免了代码膨胀和功能分散，让开发更加高效。</li><li>在需要的时间和地点实现功能闭包，使程序更加灵活。</li></ul><p>lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda表达式的语法形式简单归纳如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">[capture](params) opt -&gt; ret &#123;body;&#125;;<br></code></pre></td></tr></table></figure><p>其中capture是捕获列表，params是参数列表，opt是函数选项，ret是返回值类型，body是函数体。</p><ol><li><p>捕获列表[]: 捕获一定范围内的变量</p></li><li><p>参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> f = []()&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 没有参数, 参数列表为空</span><br><span class="hljs-keyword">auto</span> f = []&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 没有参数, 参数列表省略不写</span><br></code></pre></td></tr></table></figure><ol start="3"><li>opt 选项， 不需要可以省略</li></ol><ul><li>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li></ul><ol start="4"><li><p>返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。</p></li><li><p>函数体：函数的实现，这部分不能省略，但函数体可以为空。</p></li></ol><p><a href="https://subingwen.cn/cpp/lambda/">https://subingwen.cn/cpp/lambda/</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查询word关键字</title>
    <link href="/2023/04/09/%E6%9F%A5%E8%AF%A2Word%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/04/09/%E6%9F%A5%E8%AF%A2Word%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Qt查询关键字"><a href="#C-Qt查询关键字" class="headerlink" title="C++&#x2F;Qt查询关键字"></a>C++&#x2F;Qt查询关键字</h1><p><strong>需求：</strong></p><p>计算机某个文件夹下，有很多word文档，现在需要通过一个应用查询所有word文档中的是否有某个关键字，如果有，列出word文档，并且可以打开word使其嵌套到Qt窗口中。</p><p><strong>环境:</strong></p><p>windows10</p><p>QtCreator4.11&#x2F; Qt5.14</p><p>界面显示：</p><p><img src="/../images/image-20230410003738817.png" alt="image-20230410003738817"></p><p><strong>源码</strong></p><p>WordFind.pro</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++">QT       += core gui<br><br><span class="hljs-built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="hljs-number">4</span>): QT += widgets<br><br>CONFIG += c+<span class="hljs-number">+11</span><br>CONFIG += qaxcontainer<br># The following define makes your compiler emit warnings <span class="hljs-keyword">if</span> you use<br><span class="hljs-meta"># any Qt feature that has been marked deprecated (the exact warnings</span><br><span class="hljs-meta"># depend on your compiler). Please consult the documentation of the</span><br><span class="hljs-meta"># deprecated API in order to know how to port your code away from it.</span><br>DEFINES += QT_DEPRECATED_WARNINGS<br><br># You can also make your code fail to compile <span class="hljs-keyword">if</span> it uses deprecated APIs.<br># In order to <span class="hljs-keyword">do</span> so, uncomment the following line.<br># You can also select to disable deprecated APIs only up to a certain version of Qt.<br>#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=<span class="hljs-number">0x060000</span>    <span class="hljs-meta"># disables all the APIs deprecated before Qt 6.0.0</span><br><br>SOURCES += \<br>    WordSearchThread.cpp \<br>    main.cpp \<br>    widget.cpp<br><br>HEADERS += \<br>    WordSearchThread.h \<br>    widget.h<br><br>FORMS += \<br>    widget.ui<br><br># Default rules <span class="hljs-keyword">for</span> deployment.<br>qnx: target.path = /tmp/$$&#123;TARGET&#125;/bin<br><span class="hljs-keyword">else</span>: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin<br>!<span class="hljs-built_in">isEmpty</span>(target.path): INSTALLS += target<br><br></code></pre></td></tr></table></figure><p>widget.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> WIDGET_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIDGET_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QAxObject&gt;</span></span><br><br>QT_BEGIN_NAMESPACE<br><span class="hljs-keyword">namespace</span> Ui &#123; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>; &#125;<br>QT_END_NAMESPACE<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WidgetPrivate</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WordCompose</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">public</span> QWidget<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>(QWidget *parent = <span class="hljs-literal">nullptr</span>);<br>    ~<span class="hljs-built_in">Widget</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetDocPath</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindWord</span><span class="hljs-params">(QString Path, QString Text)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitWidget</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateWidgetBody</span><span class="hljs-params">(QString Text)</span></span>;<br><br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsContainsKeyWords</span><span class="hljs-params">(QString Path,QString KeyWords,QAxObject* word,QAxObject* documents)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OpenWindow</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;str, <span class="hljs-type">const</span> QString&amp; keyWord)</span></span>;<br><br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_pushButton_clicked</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_pushButton_2_clicked</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closeEvent</span><span class="hljs-params">(QCloseEvent *event)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closeWord</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">(QResizeEvent *event)</span></span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resizeEvent</span><span class="hljs-params">(QResizeEvent *event)</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">private</span>:<br>    Ui::Widget *ui;<br>    WidgetPrivate * _P;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> countNumber;<br>    HWND m_WindowShowHwnd = <span class="hljs-literal">NULL</span>;<br><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// WIDGET_H</span></span><br><br></code></pre></td></tr></table></figure><p>widget.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><code class="hljs C++/Qt">#include &quot;widget.h&quot;<br>#include &quot;ui_widget.h&quot;<br><br>#include &lt;QDir&gt;<br>#include &lt;QStringList&gt;<br>#include &lt;QString&gt;<br>#include &lt;Windows.h&gt;<br>#include &lt;QRegExp&gt;<br>#include &lt;QAxObject&gt;<br>#include &lt;map&gt;<br>#include &lt;vector&gt;<br>#include &lt;QDebug&gt;<br>#include &lt;QMessageBox&gt;<br>#include &lt;QWidget&gt;<br>#include &lt;QThreadPool&gt;<br>#include &lt;QDebug&gt;<br><br>struct WordCompose<br>&#123;<br>    //序号<br>    int numberCount;<br>    //文件路径<br>    QString path;<br>    //当前行号<br>    int rowCurrent;<br>    //附近文本<br>    QString context;<br>&#125;;<br><br>struct WidgetPrivate<br>&#123;<br>    WidgetPrivate()<br>        :_CurrentOpenpApp(nullptr)<br>        ,_CurrentOpenpDocs(nullptr)<br>        ,_CurrentOpenpDoc(nullptr)<br>        ,_Hwnd(NULL)<br>        ,_ThreadNumber(1) //默认单线程工作<br>        ,_PoolA(nullptr)<br>        ,_IsOpened(0)<br>    &#123;<br><br>    &#125;<br>    // 设置要查找的文件夹路径<br>    QString _FolderPath = &quot;C:\\Users\\liruilong\\Desktop\\llxx\\&quot;;<br>    // 定义一个vector来存储文件名<br>    std::vector&lt;QString&gt; _FileNames;<br>    // 定义存储关键字和对应文档行号的容器<br>    std::map&lt;QString,std::vector&lt;WordCompose&gt;&gt; _AllWordC;<br>    // 定义存储含有关键字的文档路径<br>    std::vector&lt;QString&gt; _KeyFileNames;<br><br>    QAxObject* _CurrentOpenpApp;<br>    QAxObject* _CurrentOpenpDocs;<br>    QAxObject* _CurrentOpenpDoc;<br>    RECT _Rect;<br>    HWND _Hwnd;<br>    //定义word操作线程数量（包含主线程）<br>    int _ThreadNumber;<br>    int _IsOpened;<br><br>    QThreadPool *_PoolA;<br>&#125;;<br><br>int Widget::countNumber = 0;<br><br>Widget::Widget(QWidget *parent)<br>    : QWidget(parent)<br>    , ui(new Ui::Widget)<br>    ,_P(new WidgetPrivate)<br>&#123;<br>    ui-&gt;setupUi(this);<br>    GetDocPath();<br>    InitWidget();<br>    _P-&gt;_PoolA = new QThreadPool();<br><br>&#125;<br><br>Widget::~Widget()<br>&#123;<br>    delete ui;<br>&#125;<br><br>void Widget::GetDocPath()<br>&#123;<br>    _P-&gt;_FileNames.clear();<br>    // 定义要查找的文件后缀名<br>    QStringList filters;<br>    filters &lt;&lt; &quot;*.doc&quot; &lt;&lt; &quot;*.docx&quot;;<br><br>    // 打开文件夹并查找指定文件<br>    QDir dir(_P-&gt;_FolderPath);<br>    QStringList fileList = dir.entryList(filters, QDir::Files);<br><br>    // 将文件名存储到vector中<br>    for (int i = 0; i &lt; fileList.size(); ++i)<br>    &#123;<br>        QString filePath = _P-&gt;_FolderPath + fileList.at(i);<br>        QString fileName = QFileInfo(filePath).fileName();<br>        _P-&gt;_FileNames.push_back(filePath);<br>    &#125;<br>&#125;<br><br>void Widget::FindWord(QString filePath, QString keywords)<br>&#123;<br>&#125;<br><br>void Widget::InitWidget()<br>&#123;<br>    QStringList list_header;<br>    //list_header&lt;&lt;QString(&quot;序号&quot;)&lt;&lt;QString(&quot;文件位置&quot;)&lt;&lt;QString(&quot;所在行数&quot;)&lt;&lt;QString(&quot;文件内容&quot;);<br>    list_header&lt;&lt;QString(&quot;01&quot;)&lt;&lt;QString(&quot;02&quot;);//&lt;&lt;QString(&quot;03&quot;)&lt;&lt;QString(&quot;04&quot;);<br>    ui-&gt;resultTable-&gt;setColumnCount(2);<br>    ui-&gt;resultTable-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);<br>    ui-&gt;resultTable-&gt;setSelectionMode(QAbstractItemView::SingleSelection);<br>    ui-&gt;resultTable-&gt;setHorizontalHeaderLabels(list_header);<br>    ui-&gt;resultTable-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);<br>    ui-&gt;resultTable-&gt;horizontalHeader()-&gt;setStretchLastSection(true);<br><br>    // 设置第一列的宽度为200<br>    ui-&gt;resultTable-&gt;setColumnWidth(0, 200);<br><br>    // 设置第二列的宽度为第一列的一半<br>    ui-&gt;resultTable-&gt;horizontalHeader()-&gt;setSectionResizeMode(1, QHeaderView::Stretch);<br>    ui-&gt;resultTable-&gt;horizontalHeader()-&gt;setStretchLastSection(true);<br>&#125;<br><br>void Widget::CreateWidgetBody(QString Text)<br>&#123;<br>    ui-&gt;resultTable-&gt;clear();<br>    ui-&gt;resultTable-&gt;setRowCount(0);<br>    InitWidget();<br>    if(Text==&quot;&quot;)return;<br>    //std::map&lt;QString,std::vector&lt;WordCompose&gt;&gt;<br>    //std::vector&lt;WordCompose&gt; wordCompose = _P-&gt;_AllWordC[Text];<br>    int row =0;<br>    for(auto filepath : _P-&gt;_KeyFileNames)<br>    &#123;<br>        ui-&gt;resultTable-&gt;insertRow(row);<br>        QString fileName = filepath.section(&#x27;\\&#x27;, -1);<br>        ui-&gt;resultTable-&gt;setItem(row, 0, new QTableWidgetItem(fileName));<br>        ui-&gt;resultTable-&gt;setItem(row, 1, new QTableWidgetItem(filepath));<br>    &#125;<br>&#125;<br><br>bool Widget::IsContainsKeyWords(QString Path, QString KeyWords,QAxObject* word, QAxObject* documents)<br>&#123;<br>    //    // Word 应用程序对象<br>    //    QAxObject* word = new QAxObject(&quot;Word.Application&quot;);<br>    //    if (!word) &#123;<br>    //        qDebug() &lt;&lt; &quot;Failed to create Word Application object!&quot;;<br>    //        return false;<br>    //    &#125;<br><br>    //    // 设置是否可见<br>    //    word-&gt;setProperty(&quot;Visible&quot;, false);<br><br>    //    //打开 Word 文档<br>    //    QAxObject* documents = word-&gt;querySubObject(&quot;Documents&quot;);<br>    if (!documents)<br>    &#123;<br>        qDebug() &lt;&lt; &quot;Failed to get Documents object!&quot;;<br>        return false;<br>    &#125;<br>    //    double t1 = clock();<br>    QAxObject* document = documents-&gt;querySubObject(&quot;Open(const QString&amp;)&quot;, Path);<br>    //    double t2 = clock();<br>    if (!document) &#123;<br>        qDebug() &lt;&lt; &quot;Failed to open document!&quot;;<br>        return false;<br>    &#125;<br><br>    // 查找关键字<br>    QAxObject* selection = word-&gt;querySubObject(&quot;Selection&quot;);<br>    if (!selection) &#123;<br>        qDebug() &lt;&lt; &quot;Failed to get Selection object!&quot;;<br>        return false;<br>    &#125;<br>    //    double t3 = clock();<br>    QAxObject* find = selection-&gt;querySubObject(&quot;Find&quot;);<br>    if (!find) &#123;<br>        qDebug() &lt;&lt; &quot;Failed to get Find object!&quot;;<br>        return false;<br>    &#125;<br>    find-&gt;setProperty(&quot;Text&quot;, KeyWords);<br>    bool m_found = find-&gt;dynamicCall(&quot;Execute()&quot;).toBool();<br>    //    double t4 = clock();<br>    //关闭Word 文档<br>    document-&gt;dynamicCall(&quot;Close()&quot;);<br><br>    _P-&gt;_KeyFileNames.push_back(Path);<br>    //    double t5 = clock();<br>    //    qDebug()&lt;&lt;Path&lt;&lt;endl;<br>    //    qDebug()&lt;&lt; t2 - t1&lt;&lt;endl&lt;&lt;t3 - t2&lt;&lt;endl&lt;&lt;t4 - t3&lt;&lt;endl&lt;&lt;t5 - t4&lt;&lt;endl;<br><br>    return m_found;<br>&#125;<br><br>void Widget::on_pushButton_clicked()<br>&#123;<br>    closeWord();<br>    GetDocPath();<br>    _P-&gt;_KeyFileNames.clear();<br>//    double t1 = clock();<br>    countNumber = 0;<br>    QString text = ui-&gt;lineEdit-&gt;text();<br><br>    //文件处理个数<br>    //int size = _P-&gt;_FileNames.size();<br><br><br>    // Word 应用程序对象<br>    QAxObject* word = new QAxObject(&quot;Word.Application&quot;);<br>    if (!word) &#123;<br>        qDebug() &lt;&lt; &quot;Failed to create Word Application object!&quot;;<br>        return;<br>    &#125;<br><br>    // 设置是否可见<br>    word-&gt;setProperty(&quot;Visible&quot;, false);<br><br>    //打开 Word 文档<br>    QAxObject* documents = word-&gt;querySubObject(&quot;Documents&quot;);<br>    if (!documents)<br>    &#123;<br>        qDebug() &lt;&lt; &quot;Failed to get Documents object!&quot;;<br>        return;<br>    &#125;<br>    //    double t2 = clock();<br>    //    qDebug()&lt;&lt;&quot;open tool ....&quot;&lt;&lt;t2-t1&lt;&lt;endl;<br><br>    for (auto filepath:_P-&gt;_FileNames)<br>    &#123;<br>        //先尝试单线程<br>        // 修改为多线程，维护线程池<br>        //问题1，频繁打开word，消耗时间性能和内存<br>        //问题2，多线程处理同名文件，由于window应用机制，只能有一个同名应用，再增加就会报错或者警告<br><br>        //优化：1.主线程处理一个word程序，异线程处理其他word程序，主线程维护线程池<br><br><br>        IsContainsKeyWords(filepath,text,word,documents);<br>    &#125;<br>    //    double t4 = clock();<br>    //    qDebug()&lt;&lt;&quot;time total ....&quot;&lt;&lt;t4-t2&lt;&lt;endl;<br>    word-&gt;dynamicCall(&quot;Quit()&quot;);<br>    //    if(_P-&gt;_ThreadNumber == 1)<br>    //    &#123;<br>    //<br>    //    &#125;<br>    //    else if(_P-&gt;_ThreadNumber &gt; 1)<br>    //    &#123;<br>    //        //单个线程处理文件个数<br>    //        int oneThreadSize = size/_P-&gt;_ThreadNumber;<br>    //        //如果只有一个文件或者文件数量小于线程数，销毁多余线程<br>    //        if(size&lt;_P-&gt;_ThreadNumber)<br>    //        &#123;<br>    //            _P-&gt;_ThreadNumber = size;<br>    //            //创建任务队列<br>    //        &#125;<br>    //        //如果文件数量等于线程数则平均分配<br>    //        else if(size==_P-&gt;_ThreadNumber)<br>    //        &#123;<br>    //            //创建任务队列<br>    //        &#125;<br>    //        //如果文件数量大于线程数，则先分配同等数量，在依次均分<br>    //        else if(size&gt;_P-&gt;_ThreadNumber)<br>    //        &#123;<br>    //            //创建任务队列<br>    //<br>    //        &#125;<br>    //<br>    //    &#125;<br>    //显示widget<br>    CreateWidgetBody(text);<br>    //        double t3 = clock();<br>    //        qDebug()&lt;&lt;&quot;time total ....&quot;&lt;&lt;t3-t1&lt;&lt;endl;<br>&#125;<br><br>void Widget::on_pushButton_2_clicked()<br>&#123;<br>    //double t1 = clock();<br>    if (!ui-&gt;resultTable-&gt;selectedItems().isEmpty())<br>    &#123;<br>        QString str = ui-&gt;resultTable-&gt;selectedItems().at(1)-&gt;text();<br>        OpenWindow(str, ui-&gt;lineEdit-&gt;text());<br>    &#125;<br>    else<br>    &#123;<br>        //QMessageBox::information(nullptr, &quot;提示&quot;, &quot;请选中要打开的文件路径&quot;);<br>    &#125;<br>    //qDebug()&lt;&lt;ui-&gt;lineEdit-&gt;text()&lt;&lt;&quot;: &quot;&lt;&lt;clock()-t1&lt;&lt;endl;<br>&#125;<br><br>void Widget::closeEvent(QCloseEvent *event)<br>&#123;<br>    closeWord();<br>&#125;<br><br>void Widget::closeWord()<br>&#123;<br>    if(_P-&gt;_CurrentOpenpApp)<br>    &#123;<br>        if(_P-&gt;_CurrentOpenpDocs)<br>        &#123;<br>            if(_P-&gt;_CurrentOpenpDoc)<br>            &#123;<br>                _P-&gt;_CurrentOpenpDoc-&gt;dynamicCall(&quot;Close()&quot;);<br>            &#125;<br>        &#125;<br>        _P-&gt;_CurrentOpenpApp-&gt;dynamicCall(&quot;Quit()&quot;);<br>        delete _P-&gt;_CurrentOpenpApp;<br>        _P-&gt;_CurrentOpenpApp= nullptr;<br>    &#125;<br>&#125;<br><br>void Widget::onResize(QResizeEvent *event)<br>&#123;<br>    // 如果找到了窗口句柄<br>    if (_P-&gt;_Hwnd != NULL)<br>    &#123;<br>        // 获取窗口父句柄<br>        HWND parentHwnd = reinterpret_cast&lt;HWND&gt;(ui-&gt;widget-&gt;winId());<br>        // 将 Word 窗口嵌入到程序窗口中<br>        SetParent(_P-&gt;_Hwnd, parentHwnd);<br>        // 移动窗口，将关闭按钮遮盖住<br>        RECT rect;<br>        GetClientRect(parentHwnd, &amp;rect);<br>        MoveWindow(_P-&gt;_Hwnd, 0, -30, rect.right - rect.left, rect.bottom - rect.top + 30, TRUE);<br>        _P-&gt;_Rect = rect;<br>    &#125;<br>&#125;<br><br>void Widget::resizeEvent(QResizeEvent *event)<br>&#123;<br>    onResize(event);<br>&#125;<br><br>void Widget::OpenWindow(const QString &amp;str, const QString&amp; keyWord)<br>&#123;<br>    double t1 = clock();<br>    // 将文件路径转换为本机格式<br>    QString path = QDir::toNativeSeparators(str);<br>    if(_P-&gt;_IsOpened == 0)<br>    &#123;<br>        _P-&gt;_IsOpened++;<br>        //打开word<br><br>        // 创建 Word 应用程序对象<br>        _P-&gt;_CurrentOpenpApp = new QAxObject(&quot;Word.Application&quot;);<br><br>        // 如果创建失败，直接返回<br>        if (!_P-&gt;_CurrentOpenpApp)<br>        &#123;<br>            return;<br>        &#125;<br>        // 隐藏word启动界面<br>        _P-&gt;_CurrentOpenpApp-&gt;setProperty(&quot;DisplayAlerts&quot;, 0);<br>        // 前台不显示word<br>        _P-&gt;_CurrentOpenpApp-&gt;setProperty(&quot;Visible&quot;, false);<br>        // 获取文档集合对象<br>        _P-&gt;_CurrentOpenpDocs = _P-&gt;_CurrentOpenpApp-&gt;querySubObject(&quot;Documents&quot;);<br>    &#125;<br>    double t2 = clock();<br>    // 打开前先关闭<br>    if(_P-&gt;_CurrentOpenpDoc)<br>    &#123;<br>        _P-&gt;_CurrentOpenpDoc-&gt;dynamicCall(&quot;Close()&quot;);<br>    &#125;<br><br>    //closeWord();<br>    //关闭word异常,进程无法关闭，导致下次打开同一文档阻塞 (通过关闭事件解决，程序析构时另一进程无法关闭)<br><br><br>    // 如果获取失败，直接返回<br>    if (!_P-&gt;_CurrentOpenpDocs)<br>    &#123;<br>        return;<br>    &#125;<br>    // 打开指定路径的 Word 文档<br>    _P-&gt;_CurrentOpenpDoc = _P-&gt;_CurrentOpenpDocs-&gt;querySubObject(&quot;Open(const QString&amp;)&quot;, path);<br>    double t3 = clock();<br>    // 如果打开失败，直接返回<br>    if (!_P-&gt;_CurrentOpenpDoc)<br>    &#123;<br>        return;<br>    &#125;<br><br>    // 获取文档名称<br>    QString name = QFileInfo(str).fileName();<br>    // 构造窗口标题名称<br>    QString title = name + &quot; - Word&quot;;<br>    // 将 QString 类型转换为 std::wstring 类型<br>    std::wstring strTitle = title.toStdWString();<br><br>    // 初始化 HWND 句柄和超时时间<br>    HWND hwnd = NULL;<br>    int timeout = 10000;<br>    int count = 0;<br>    double t4 = clock();<br>    // 在超时时间内查找窗口句柄<br>    hwnd = FindWindow(L&quot;OpusApp&quot;, strTitle.c_str()); //word: OpusApp , excel:XLMAIN ,PPT:PPTFrameClass<br><br>//    while (count &lt; timeout)<br>//    &#123;<br>//        hwnd = FindWindow(L&quot;OpusApp&quot;, strTitle.c_str()); //word: OpusApp , excel:XLMAIN ,PPT:PPTFrameClass<br>//        if (hwnd != NULL)<br>//        &#123;<br>//            break;<br>//        &#125;<br>//        Sleep(100);<br>//        count += 100;<br>//    &#125;<br>    double t5 = clock();<br>    // 如果找到了窗口句柄<br>    if (hwnd != NULL)<br>    &#123;<br>        // 获取窗口父句柄<br>        HWND parentHwnd = reinterpret_cast&lt;HWND&gt;(ui-&gt;widget-&gt;winId());<br>        // 将 Word 窗口嵌入到程序窗口中<br>        SetParent(hwnd, parentHwnd);<br>        // 移动窗口，将关闭按钮遮盖住<br>        RECT rect;<br>        GetClientRect(parentHwnd, &amp;rect);<br>        MoveWindow(hwnd, 0, -30, rect.right - rect.left, rect.bottom - rect.top + 30, TRUE);<br>        _P-&gt;_Rect = rect;<br>        _P-&gt;_Hwnd = hwnd;<br>        //打开word跳转<br>        QAxObject *selection = _P-&gt;_CurrentOpenpApp-&gt;querySubObject(&quot;Selection&quot;);<br>        if(selection)<br>        &#123;<br>            QAxObject *find = selection-&gt;querySubObject(&quot;Find&quot;);<br>            if(find)<br>            &#123;<br>                find-&gt;setProperty(&quot;Text&quot;, keyWord);<br>                find-&gt;dynamicCall(&quot;Execute()&quot;);<br>            &#125;<br>        &#125;<br><br>        //在需要显示Word窗口的时候，可以调用<br>        _P-&gt;_CurrentOpenpApp-&gt;dynamicCall(&quot;Visible&quot;, true);<br><br>        update();<br>    &#125;<br>//    double t6 = clock();<br>//    qDebug()&lt;&lt;str&lt;&lt;endl;<br>//    qDebug()&lt;&lt;t2-t1&lt;&lt;endl&lt;&lt;t3-t2&lt;&lt;endl&lt;&lt;t4-t3&lt;&lt;endl&lt;&lt;t5-t4&lt;&lt;endl&lt;&lt;t6-t5&lt;&lt;endl;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>widget.ui</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C++">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;ui version=<span class="hljs-string">&quot;4.0&quot;</span>&gt;<br> &lt;<span class="hljs-keyword">class</span>&gt;Widget&lt;/<span class="hljs-keyword">class</span>&gt;<br> &lt;widget <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QWidget&quot;</span> name=<span class="hljs-string">&quot;Widget&quot;</span>&gt;<br>  &lt;property name=<span class="hljs-string">&quot;geometry&quot;</span>&gt;<br>   &lt;rect&gt;<br>    &lt;x&gt;<span class="hljs-number">0</span>&lt;/x&gt;<br>    &lt;y&gt;<span class="hljs-number">0</span>&lt;/y&gt;<br>    &lt;width&gt;<span class="hljs-number">1145</span>&lt;/width&gt;<br>    &lt;height&gt;<span class="hljs-number">610</span>&lt;/height&gt;<br>   &lt;/rect&gt;<br>  &lt;/property&gt;<br>  &lt;property name=<span class="hljs-string">&quot;windowTitle&quot;</span>&gt;<br>   &lt;string&gt;Widget&lt;/string&gt;<br>  &lt;/property&gt;<br>  &lt;layout <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QHBoxLayout&quot;</span> name=<span class="hljs-string">&quot;horizontalLayout_3&quot;</span>&gt;<br>   &lt;item&gt;<br>    &lt;layout <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QVBoxLayout&quot;</span> name=<span class="hljs-string">&quot;verticalLayout&quot;</span> stretch=<span class="hljs-string">&quot;1,3,1,10&quot;</span>&gt;<br>     &lt;property name=<span class="hljs-string">&quot;spacing&quot;</span>&gt;<br>      &lt;number&gt;<span class="hljs-number">0</span>&lt;/number&gt;<br>     &lt;/property&gt;<br>     &lt;item&gt;<br>      &lt;layout <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QHBoxLayout&quot;</span> name=<span class="hljs-string">&quot;horizontalLayout&quot;</span>&gt;<br>       &lt;item&gt;<br>        &lt;widget <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QLineEdit&quot;</span> name=<span class="hljs-string">&quot;lineEdit&quot;</span>/&gt;<br>       &lt;/item&gt;<br>       &lt;item&gt;<br>        &lt;widget <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QPushButton&quot;</span> name=<span class="hljs-string">&quot;pushButton&quot;</span>&gt;<br>         &lt;property name=<span class="hljs-string">&quot;text&quot;</span>&gt;<br>          &lt;string&gt;查询&lt;/string&gt;<br>         &lt;/property&gt;<br>        &lt;/widget&gt;<br>       &lt;/item&gt;<br>       &lt;item&gt;<br>        &lt;spacer name=<span class="hljs-string">&quot;horizontalSpacer_2&quot;</span>&gt;<br>         &lt;property name=<span class="hljs-string">&quot;orientation&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">enum</span>&gt;Qt::Horizontal&lt;/<span class="hljs-keyword">enum</span>&gt;<br>         &lt;/property&gt;<br>         &lt;property name=<span class="hljs-string">&quot;sizeHint&quot;</span> stdset=<span class="hljs-string">&quot;0&quot;</span>&gt;<br>          &lt;size&gt;<br>           &lt;width&gt;<span class="hljs-number">40</span>&lt;/width&gt;<br>           &lt;height&gt;<span class="hljs-number">20</span>&lt;/height&gt;<br>          &lt;/size&gt;<br>         &lt;/property&gt;<br>        &lt;/spacer&gt;<br>       &lt;/item&gt;<br>      &lt;/layout&gt;<br>     &lt;/item&gt;<br>     &lt;item&gt;<br>      &lt;widget <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QTableWidget&quot;</span> name=<span class="hljs-string">&quot;resultTable&quot;</span>/&gt;<br>     &lt;/item&gt;<br>     &lt;item&gt;<br>      &lt;layout <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QHBoxLayout&quot;</span> name=<span class="hljs-string">&quot;horizontalLayout_2&quot;</span>&gt;<br>       &lt;item&gt;<br>        &lt;spacer name=<span class="hljs-string">&quot;horizontalSpacer&quot;</span>&gt;<br>         &lt;property name=<span class="hljs-string">&quot;orientation&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">enum</span>&gt;Qt::Horizontal&lt;/<span class="hljs-keyword">enum</span>&gt;<br>         &lt;/property&gt;<br>         &lt;property name=<span class="hljs-string">&quot;sizeHint&quot;</span> stdset=<span class="hljs-string">&quot;0&quot;</span>&gt;<br>          &lt;size&gt;<br>           &lt;width&gt;<span class="hljs-number">40</span>&lt;/width&gt;<br>           &lt;height&gt;<span class="hljs-number">20</span>&lt;/height&gt;<br>          &lt;/size&gt;<br>         &lt;/property&gt;<br>        &lt;/spacer&gt;<br>       &lt;/item&gt;<br>       &lt;item&gt;<br>        &lt;widget <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QPushButton&quot;</span> name=<span class="hljs-string">&quot;pushButton_2&quot;</span>&gt;<br>         &lt;property name=<span class="hljs-string">&quot;text&quot;</span>&gt;<br>          &lt;string&gt;打开文档&lt;/string&gt;<br>         &lt;/property&gt;<br>        &lt;/widget&gt;<br>       &lt;/item&gt;<br>      &lt;/layout&gt;<br>     &lt;/item&gt;<br>     &lt;item&gt;<br>      &lt;widget <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QGroupBox&quot;</span> name=<span class="hljs-string">&quot;groupBox&quot;</span>&gt;<br>       &lt;property name=<span class="hljs-string">&quot;title&quot;</span>&gt;<br>        &lt;string&gt;文挡内容&lt;/string&gt;<br>       &lt;/property&gt;<br>       &lt;layout <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QHBoxLayout&quot;</span> name=<span class="hljs-string">&quot;horizontalLayout_4&quot;</span>&gt;<br>        &lt;item&gt;<br>         &lt;widget <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;QWidget&quot;</span> name=<span class="hljs-string">&quot;widget&quot;</span> native=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>        &lt;/item&gt;<br>       &lt;/layout&gt;<br>      &lt;/widget&gt;<br>     &lt;/item&gt;<br>    &lt;/layout&gt;<br>   &lt;/item&gt;<br>  &lt;/layout&gt;<br> &lt;/widget&gt;<br> &lt;resources/&gt;<br> &lt;connections/&gt;<br>&lt;/ui&gt;<br><br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    Widget w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++、Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习C++、做做练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI训练路线</title>
    <link href="/2023/03/20/AI%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2023/03/20/AI%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<ol><li>学习Python编程语言：</li></ol><ul><li>学习基本语法和数据结构</li><li>学习函数和面向对象编程</li><li>学习Python的科学计算库，例如NumPy，Pandas和Matplotlib等</li></ul><ol start="2"><li>学习数学基础知识：</li></ol><ul><li>线性代数，包括矩阵和向量的操作</li><li>概率论和统计学，包括基本的概率分布，期望和方差等</li></ul><ol start="3"><li>学习机器学习基础知识：</li></ol><ul><li>学习监督学习算法，例如线性回归，逻辑回归和决策树等</li><li>学习无监督学习算法，例如聚类和降维等</li><li>学习模型评估和选择的方法</li></ul><ol start="4"><li>学习深度学习基础知识：</li></ol><ul><li>学习神经网络的基本结构和训练方法</li><li>学习反向传播算法和优化器的原理</li><li>学习卷积神经网络和循环神经网络等常用的深度学习模型</li></ul><ol start="5"><li>实践项目：</li></ol><ul><li>使用Python和相应的机器学习和深度学习库来实现实际项目，例如图像分类，文本分类，自然语言生成等</li></ul><ol start="6"><li>学习AI应用和工具：</li></ol><ul><li>了解AI在不同领域的应用，例如计算机视觉，自然语言处理，智能推荐等</li><li>学习使用开源工具和框架，例如TensorFlow，PyTorch，Keras和Scikit-learn等</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>深度学习</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QT实现IE内核浏览器</title>
    <link href="/2023/03/15/Qt%E5%AE%9E%E7%8E%B0IE%E5%86%85%E6%A0%B8%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%88%E9%9C%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E5%B8%A6IE%EF%BC%89/"/>
    <url>/2023/03/15/Qt%E5%AE%9E%E7%8E%B0IE%E5%86%85%E6%A0%B8%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%88%E9%9C%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E5%B8%A6IE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>QT实现IE浏览器</font></center><p><strong>Qt5.14 &#x2F; Qt5.11</strong></p><p><strong>包含模块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Pro">QT += axcontainer<br></code></pre></td></tr></table></figure><p>**头文件 **  Dialog.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++(Qt)">#ifndef DIALOG_H<br>#define DIALOG_H<br><br>#include &lt;QDialog&gt;<br>#include &lt;QLineEdit&gt;<br>#include &lt;ActiveQt/QAxWidget&gt;<br><br>namespace Ui &#123;<br>class Dialog;<br>&#125;<br><br>class Dialog : public QDialog<br>&#123;<br>  Q_OBJECT<br><br>public:<br>  explicit Dialog(QWidget *parent = 0);<br>  ~Dialog();<br><br>private slots:<br>  void loadNavigate();<br>  void GetDebugTool();<br>private:<br>  Ui::Dialog *ui;<br>  QLineEdit *lineUrl;<br>  QAxWidget* webWidget;<br>&#125;;<br><br>#endif // DIALOG_H<br><br></code></pre></td></tr></table></figure><p>**源文件 ** Dialog.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++(Qt)">#include &quot;Dialog.h&quot;<br>#include &quot;ui_Dialog.h&quot;<br>#include &lt;QVBoxLayout&gt;<br>#include &lt;QFile&gt;<br>#include &lt;QTextStream&gt;<br>#include &lt;QAxObject&gt;<br><br>Dialog::Dialog(QWidget *parent) :<br>  QDialog(parent),<br>  ui(new Ui::Dialog)<br>&#123;<br>  ui-&gt;setupUi(this);<br><br>  lineUrl = new QLineEdit;<br>  lineUrl-&gt;setText(&quot;https://liruilong9999.github.io/&quot;);<br>  connect(lineUrl,SIGNAL(returnPressed()),this,SLOT(loadNavigate()));<br><br>  webWidget = new QAxWidget;<br>  //设置ActiveX控件为IEMicrosoft Web Browser<br>  //设置ActiveX控件的id，最有效的方式就是使用UUID<br>  //此处的&#123;8856F961-340A-11D0-A96B-00C04FD705A2&#125;就是Microsoft Web Browser控件的UUID<br>  webWidget-&gt;setControl(QString::fromUtf8(&quot;&#123;8856F961-340A-11D0-A96B-00C04FD705A2&#125;&quot;));<br>  webWidget-&gt;setObjectName(QString::fromUtf8(&quot;webWidget&quot;));//设置控件的名称<br>  webWidget-&gt;setFocusPolicy(Qt::StrongFocus);//设置控件接收键盘焦点的方式：鼠标单击、Tab键<br>  webWidget-&gt;setProperty(&quot;DisplayAlerts&quot;,false); //不显示任何警告信息。<br>  webWidget-&gt;setProperty(&quot;DisplayScrollBars&quot;,true); // 显示滚动条<br><br>  QVBoxLayout *mainLayout = new QVBoxLayout;<br>  mainLayout-&gt;addWidget(lineUrl);<br>  mainLayout-&gt;addWidget(webWidget);<br>  setLayout(mainLayout);<br><br>  setWindowState(Qt::WindowMaximized);//最大化<br><br>//  QString DOC = webWidget-&gt;generateDocumentation();<br>//  QFile outFile(&quot;com_function.html&quot;);<br>//  outFile.open(QIODevice ::ReadWrite|QIODevice ::Text);<br>//  QTextStream TS(&amp;outFile);<br>//  TS&lt;&lt;DOC&lt;&lt;endl;<br><br>  setWindowTitle(&quot;浏览器&quot;);<br>  this-&gt;setWindowFlags(Qt::Dialog | Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint);<br><br>&#125;<br><br>Dialog::~Dialog()<br>&#123;<br>  delete ui;<br>&#125;<br><br>void Dialog::loadNavigate()<br>&#123;<br>  QString sUrl = lineUrl-&gt;text().trimmed();<br>  QVariantList params =&#123;sUrl,0,&quot;&quot;,&quot;&quot;,&quot;&quot;&#125;;<br>  webWidget-&gt;dynamicCall(&quot;Navigate2(QString, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;)&quot;, params);<br> // GetDebugTool();<br>&#125;<br><br>void Dialog::GetDebugTool()<br>&#123;<br>    QAxObject *browser = new QAxObject();<br>    browser-&gt;querySubObject(&quot;Document&quot;);<br>    browser-&gt;dynamicCall(&quot;parentWindow().open(&#x27;&#x27;,&#x27;_blank&#x27;,&#x27;width=800,height=600&#x27;)&quot;);<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Qt</category>
      
      <category>Internet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>QT实现IE内核浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="/2023/03/11/HTML/"/>
    <url>/2023/03/11/HTML/</url>
    
    <content type="html"><![CDATA[<h1 id="一、HTML-简介"><a href="#一、HTML-简介" class="headerlink" title="一、HTML 简介"></a>一、HTML 简介</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我的第一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="img"></p><ul><li>**<code>&lt;!DOCTYPE html&gt;</code>**声明为 HTML5 文档</li><li><strong><code>&lt;html&gt;</code></strong> 元素是 HTML 页面的根元素</li><li><strong><code>&lt;head&gt;</code></strong> 元素包含了文档的元（meta）数据，如 <strong><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></strong> 定义网页编码格式为 <strong>utf-8</strong>。</li><li><strong><code>&lt;title&gt;</code></strong> 元素描述了文档的标题</li><li><strong><code>&lt;body&gt;</code></strong> 元素包含了可见的页面内容</li><li><strong><code>&lt;h1&gt;</code></strong> 元素定义一个大标题</li><li><strong><code>&lt;p&gt;</code></strong> 元素定义一个段落</li></ul><p>**注：**在浏览器的页面上使用键盘上的 <strong>F12</strong> 按键开启调试模式，就可以看到组成标签。</p><h2 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML?"></a>什么是HTML?</h2><p>HTML 是用来描述网页的一种语言。</p><ul><li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li><li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用标记标签来<strong>描述</strong>网页</li><li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li><li>HTML文档也叫做 <strong>web 页面</strong></li></ul><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><ul><li>HTML 标签是由<em>尖括号</em>包围的关键词，比如 <code>&lt;html&gt;</code></li><li>HTML 标签通常是<em>成对出现</em>的，比如 <code>&lt;b&gt; </code>和<code> &lt;/b&gt;</code></li><li>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em></li><li>开始和结束标签也被称为<em>开放标签</em>和<em>闭合标签</em></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">标签</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">标签</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p>“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思.</p><p>但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:</p><p>HTML 元素:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Web-浏览器"><a href="#Web-浏览器" class="headerlink" title="Web 浏览器"></a>Web 浏览器</h2><p>Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。</p><p>浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户：</p><p><img src="/../images/html-first.png" alt="img"></p><h2 id="HTML-网页结构"><a href="#HTML-网页结构" class="headerlink" title="HTML 网页结构"></a>HTML 网页结构</h2><p>下面是一个可视化的HTML页面结构：</p><p><img src="/../images/image-20230311224933953.png" alt="image-20230311224933953"></p><p><em>只有<code>&lt;body&gt;</code> 区域 (白色部分) 才会在浏览器中显示。</em></p><h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><p>从初期的网络诞生后，已经出现了许多HTML版本:</p><table><thead><tr><th align="left">版本</th><th align="left">发布时间</th></tr></thead><tbody><tr><td align="left">HTML</td><td align="left">1991</td></tr><tr><td align="left">HTML+</td><td align="left">1993</td></tr><tr><td align="left">HTML 2.0</td><td align="left">1995</td></tr><tr><td align="left">HTML 3.2</td><td align="left">1997</td></tr><tr><td align="left">HTML 4.01</td><td align="left">1999</td></tr><tr><td align="left">XHTML 1.0</td><td align="left">2000</td></tr><tr><td align="left">HTML5</td><td align="left">2012</td></tr><tr><td align="left">XHTML5</td><td align="left">2013</td></tr></tbody></table><h2 id="声明"><a href="#声明" class="headerlink" title="&lt;!DOCTYPE&gt; 声明"></a>&lt;!DOCTYPE&gt; 声明</h2><!DOCTYPE><p>声明有助于浏览器中正确显示网页。</p><p>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。</p><p>doctype 声明是不区分大小写的，以下方式均可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span><br><br><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><br><span class="hljs-meta">&lt;!Doctype <span class="hljs-keyword">Html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="通用声明"><a href="#通用声明" class="headerlink" title="通用声明"></a>通用声明</h2><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="HTML-4-01"><a href="#HTML-4-01" class="headerlink" title="HTML 4.01"></a>HTML 4.01</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="XHTML-1-0"><a href="#XHTML-1-0" class="headerlink" title="XHTML 1.0"></a>XHTML 1.0</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h2><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>页面标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我的第一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="二、HTML基础"><a href="#二、HTML基础" class="headerlink" title="二、HTML基础"></a>二、HTML基础</h1><h2 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a>HTML 标题</h2><p>HTML 标题（Heading）是通过<code>&lt;h1&gt; - &lt;h6&gt; </code>标签来定义的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这是一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这是一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a>HTML 段落</h2><p>HTML 段落是通过标签 <code>&lt;p&gt;</code> 来定义的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是另外一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a>HTML 链接</h2><p>HTML 链接是通过标签<code>&lt;a&gt;</code>来定义的.</p><p>href是Hypertext Reference的缩写。意思是指定超链接目标的URL.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>**提示:**在 href 属性中指定链接的地址。</p><h2 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h2><p>HTML 图像是通过标签 <code>&lt;img&gt;</code> 来定义的.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;img decoding<span class="hljs-operator">=</span><span class="hljs-string">&quot;async&quot;</span>    src<span class="hljs-operator">=</span><span class="hljs-string">&quot;./xiaoming.png&quot;</span> width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;280&quot;</span>  alt<span class="hljs-operator">=</span><span class="hljs-string">&quot;小明1234123412341234&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>sync</strong>: 同步解码图像，保证与其他内容一起显示。</li><li><strong>async</strong>: 异步解码图像，加快显示其他内容。</li><li><strong>auto</strong>: 默认模式，表示不偏好解码模式。由浏览器决定哪种方式更适合用户。</li></ul><p>此属性类似于在<code>&lt;script&gt;</code>上使用 async 属性。加载图像所需的时间不会改变，但其“解码”的方式由解码属性决定。decoding 属性可以控制是否允许浏览器尝试异步加载图像。异步加载对 <code>&lt;img&gt; </code>元素很有用，对屏幕外的图像对象可能会更有用。</p><p>alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p><p><strong>注意：</strong> 图像的名称和尺寸是以属性的形式提供的。</p><h1 id="三、HTML元素"><a href="#三、HTML元素" class="headerlink" title="三、HTML元素"></a>三、HTML元素</h1><p>HTML 文档由 HTML 元素定义。</p><h2 id="HTML-元素-1"><a href="#HTML-元素-1" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><table><thead><tr><th align="left">开始标签 *</th><th align="left">元素内容</th><th align="left">结束标签 *</th></tr></thead><tbody><tr><td align="left"><code>&lt;p&gt;</code></td><td align="left">这是一个段落</td><td align="left"><code>&lt;/p&gt;</code></td></tr><tr><td align="left"><code>&lt;a href=&quot;default.htm&quot;&gt;</code></td><td align="left">这是一个链接</td><td align="left"><code>&lt;/a&gt;</code></td></tr><tr><td align="left"><code>&lt;br&gt;</code></td><td align="left">换行</td><td align="left"></td></tr></tbody></table><p><em>*<em><strong>开始标签常被称为</strong>起始标签（opening tag）</em>*，结束标签常称为</em>*闭合标签（closing tag）**。</p><h2 id="HTML-元素语法"><a href="#HTML-元素语法" class="headerlink" title="HTML 元素语法"></a>HTML 元素语法</h2><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容（empty content）</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li></ul><p><strong>注释:</strong> 您将在本教程的下一章中学习更多有关属性的内容。</p><h2 id="嵌套的-HTML-元素"><a href="#嵌套的-HTML-元素" class="headerlink" title="嵌套的 HTML 元素"></a>嵌套的 HTML 元素</h2><p>大多数 HTML 元素可以嵌套（HTML 元素可以包含其他 HTML 元素）。</p><p>HTML 文档由相互嵌套的 HTML 元素构成。</p><h2 id="HTML-文档实例"><a href="#HTML-文档实例" class="headerlink" title="HTML 文档实例"></a>HTML 文档实例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上实例包含了三个 HTML 元素。</p><h2 id="HTML-实例解析"><a href="#HTML-实例解析" class="headerlink" title="HTML 实例解析"></a>HTML 实例解析</h2><p><code>&lt;p&gt; </code> 元素:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个 <code>&lt;p&gt;</code> 元素定义了 HTML 文档中的一个段落。<br>这个元素拥有一个开始标签 <code>&lt;p&gt;</code> 以及一个结束标签<code>  &lt;/p&gt;</code>.<br>元素内容是: 这是第一个段落。</p><p><strong><code>&lt;body&gt; </code>元素:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;body&gt;</code> 元素定义了 HTML 文档的主体。<br>这个元素拥有一个开始标签<code>&lt;body&gt; </code>以及一个结束标签<code> &lt;/body&gt;</code>。<br>元素内容是另一个 HTML 元素（p 元素）。</p><p><strong><code>&lt;html&gt; </code>元素：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;html&gt;</code>  元素定义了整个 HTML 文档。<br>这个元素拥有一个开始标签 <code>&lt;html&gt;</code> ，以及一个结束标签<code> &lt;/html&gt;</code>.<br>元素内容是另一个 HTML 元素（body 元素）。</p><h2 id="不要忘记结束标签"><a href="#不要忘记结束标签" class="headerlink" title="不要忘记结束标签"></a>不要忘记结束标签</h2><p>即使您忘记了使用结束标签，大多数浏览器也会正确地显示 HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<br></code></pre></td></tr></table></figure><p>以上实例在浏览器中也能正常显示，因为关闭标签是可选的。</p><p>但不要依赖这种做法。忘记使用结束标签会产生不可预料的结果或错误。</p><hr><h2 id="HTML-空元素"><a href="#HTML-空元素" class="headerlink" title="HTML 空元素"></a>HTML 空元素</h2><p>没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。</p><p><code>&lt;br&gt;</code> 就是没有关闭标签的空元素（<code>&lt;br&gt; </code>标签定义换行）。</p><p>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。</p><p>在开始标签中添加斜杠，比如<code> &lt;br /&gt;</code>，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。</p><p>即使 <code>&lt;br&gt; </code>在所有浏览器中都是有效的，但使用 <code>&lt;br /&gt; </code>其实是更长远的保障。</p><hr><h2 id="HTML-提示：使用小写标签"><a href="#HTML-提示：使用小写标签" class="headerlink" title="HTML 提示：使用小写标签"></a>HTML 提示：使用小写标签</h2><p>HTML 标签对大小写不敏感：<code>&lt;P&gt; </code>等同于<code> &lt;p&gt;</code>。许多网站都使用大写的 HTML 标签。</p><p>使用小写标签，是因为未来 (X)HTML 版本中强制使用小写。</p><h1 id="四、HTML属性"><a href="#四、HTML属性" class="headerlink" title="四、HTML属性"></a>四、HTML属性</h1><p>属性是 HTML 元素提供的附加信息。</p><h2 id="HTML-属性"><a href="#HTML-属性" class="headerlink" title="HTML 属性"></a>HTML 属性</h2><ul><li>HTML 元素可以设置<strong>属性</strong></li><li>属性可以在元素中添加<strong>附加信息</strong></li><li>属性一般描述于<strong>开始标签</strong></li><li>属性总是以名称&#x2F;值对的形式出现，<strong>比如：<code>name=&quot;value&quot; </code></strong>。</li></ul><h2 id="属性实例"><a href="#属性实例" class="headerlink" title="属性实例"></a>属性实例</h2><p>HTML 链接由 <code>&lt;a&gt; </code>标签定义。链接的地址在 <strong>href 属性</strong>中指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.runoob.com&quot;</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML-属性常用引用属性值"><a href="#HTML-属性常用引用属性值" class="headerlink" title="HTML 属性常用引用属性值"></a>HTML 属性常用引用属性值</h2><p>属性值应该始终被包括在引号内。</p><p>双引号是最常用的，不过使用单引号也没有问题。</p><p><strong>提示:</strong> <em>在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：</em></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;John &quot;ShotGun&quot; Nelson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="HTML-提示：使用小写属性"><a href="#HTML-提示：使用小写属性" class="headerlink" title="HTML 提示：使用小写属性"></a>HTML 提示：使用小写属性</h2><p>属性和属性值对大小写不敏感。</p><p>不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性&#x2F;属性值。</p><p>而新版本的 (X)HTML 要求使用小写属性。</p><p>下面列出了适用于大多数 HTML 元素的属性：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">class</td><td align="left">为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td></tr><tr><td align="left">id</td><td align="left">定义元素的唯一id</td></tr><tr><td align="left">style</td><td align="left">规定元素的行内样式（inline style）</td></tr><tr><td align="left">title</td><td align="left">描述了元素的额外信息 (作为工具条使用)</td></tr></tbody></table><h1 id="五、HTML标题"><a href="#五、HTML标题" class="headerlink" title="五、HTML标题"></a>五、HTML标题</h1><h2 id="HTML-标题-1"><a href="#HTML-标题-1" class="headerlink" title="HTML 标题"></a>HTML 标题</h2><p>标题（Heading）是通过<code> &lt;h1&gt; - &lt;h6&gt;</code> 标签进行定义的。</p><p><code>&lt;h1&gt;</code> 定义最大的标题。<code> &lt;h6&gt;</code>定义最小的标题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一个标题。<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这是一个标题。<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这是一个标题。<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注释:</strong> 浏览器会自动地在标题的前后添加空行。</p><h2 id="标题很重要"><a href="#标题很重要" class="headerlink" title="标题很重要"></a>标题很重要</h2><p>请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题。</p><p>搜索引擎使用标题为您的网页的结构和内容编制索引。</p><p>因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。</p><p>应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p><h2 id="HTML-水平线"><a href="#HTML-水平线" class="headerlink" title="HTML 水平线"></a>HTML 水平线</h2><p><code>&lt;hr&gt; </code>标签在 HTML 页面中创建水平线。</p><p><code>hr </code>元素可用于分隔内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h2><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p><p>注释写法如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注释:</strong> 开始括号之后（左边的括号）需要紧跟一个叹号 <strong>!</strong> (英文标点符号)，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。</p><h2 id="HTML-提示-如何查看源代码"><a href="#HTML-提示-如何查看源代码" class="headerlink" title="HTML 提示 - 如何查看源代码"></a>HTML 提示 - 如何查看源代码</h2><p>你是否看过一些网页然后惊叹它是如何实现的。</p><p>如果您想找到其中的奥秘，只需要单击右键，然后选择”查看源文件”（IE）或”查看页面源代码”（Firefox），其他浏览器的做法也是类似的。这么做会打开一个包含页面 HTML 代码的窗口。</p><h1 id="六、HTML-段落"><a href="#六、HTML-段落" class="headerlink" title="六、HTML 段落"></a>六、HTML 段落</h1><p>HTML 可以将文档分割为若干段落。</p><h2 id="HTML-段落-1"><a href="#HTML-段落-1" class="headerlink" title="HTML 段落"></a>HTML 段落</h2><p>段落是通过<code>&lt;p&gt;</code>标签定义的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是另一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>**注意：**浏览器会自动地在段落的前后添加空行。（<code>&lt;/p&gt;</code> 是块级元素）</p><p><em>块元素又名块级<a href="https://baike.baidu.com/item/%E5%85%83%E7%B4%A0/29645?fromModule=lemma_inlink">元素</a>(block element)，和其对应的是内联元素(inline element)，都是html规范中的概念。大多数HTML 元素被定义为块级元素或内联元素。块级元素在浏览器显示时，通常会以新行来开始（和结束）。</em></p><h2 id="不要忘记结束标签-1"><a href="#不要忘记结束标签-1" class="headerlink" title="不要忘记结束标签"></a>不要忘记结束标签</h2><p>即使忘了使用结束标签，大多数浏览器也会正确地将 HTML 显示出来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是另一个段落<br></code></pre></td></tr></table></figure><p>上面的例子在大多数浏览器中都没问题，但不要依赖这种做法。忘记使用结束标签会产生意想不到的结果和错误。</p><p><strong>注释:</strong> 在未来的 HTML 版本中，不允许省略结束标签。</p><h2 id="HTML-折行"><a href="#HTML-折行" class="headerlink" title="HTML 折行"></a>HTML 折行</h2><p>如果您希望在不产生一个新段落的情况下进行换行（新行），请使用**<code>&lt;br&gt;</code>** 标签：</p><p><code>&lt;br /&gt;</code> 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签.</p><h2 id="HTML-输出-使用提醒"><a href="#HTML-输出-使用提醒" class="headerlink" title="HTML 输出- 使用提醒"></a>HTML 输出- 使用提醒</h2><p>我们无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。</p><p>对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。</p><p>当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。</p><p><strong>区分一下： <code>&lt;br&gt;</code>, <code>&lt;br/&gt;</code>以及<code> &lt;br /&gt;</code>（带有空格）</strong></p><p><strong><code>&lt;br&gt;</code></strong> 是 HTML 写法。<br><strong>是 XHTML1.1 的写法, 也是 XML 写法。</strong><code>&lt;br/&gt;</code> 是 XHTML 为兼容 HTML 的写法,也是 XML 写法。HTML5 因为兼容 XHTML，所以三种写法都可以使用。</p><p>早期发布的 HTML 规范当中，<code>&lt;br&gt;</code> 与<code>&lt;img&gt;</code>等元素是不用封闭自身的，但是这种元素造成了 HTML 规范的不严谨，于是在之后发布的 XHTML 语言中，参考了更为严谨的 XML 规范，在这些不用自身封闭的元素后加 <strong><code>/</code></strong> 来表示自行封闭，在逻辑上来讲等同于<code>&lt;br&gt;....&lt;/br&gt;</code>（但是没有 <strong><code>&lt;/br&gt;</code></strong> 这种写法），这样一来保证了较少的代码量，二来保证了规范的严谨。</p><h1 id="七、HTML-文本格式化"><a href="#七、HTML-文本格式化" class="headerlink" title="七、HTML 文本格式化"></a>七、HTML 文本格式化</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>加粗文本<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体文本<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>电脑自动输出<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>这是 <span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span> 下标<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span> 和 <span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span> 上标<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/image-20230312191637212.png" alt="image-20230312191637212"> </p><h2 id="HTML-格式化标签"><a href="#HTML-格式化标签" class="headerlink" title="HTML 格式化标签"></a>HTML 格式化标签</h2><p>HTML 使用标签 <code>&lt;b&gt;(&quot;bold&quot;) </code>与 <code>&lt;i&gt;(&quot;italic&quot;) </code>对输出的文本进行格式, 如：<strong>粗体</strong> or <em>斜体</em></p><p>这些HTML标签被称为格式化标签（请查看底部完整标签参考手册）。</p><p><strong>通常标签<code>&lt;strong&gt;</code>替换加粗标签<code>&lt;b&gt;</code>来使用, <code>&lt;em&gt; </code>替换<code> &lt;i&gt;</code>标签使用。</strong></p><p>然而，这些标签的含义是不同的：</p><p><code>&lt;b&gt; </code>与<code>&lt;i&gt; </code>定义粗体或斜体文本。</p><p><code>&lt;strong&gt; </code>或者<code> &lt;em&gt;</code>意味着你要呈现的文本是重要的，所以要突出显示。现今所有主要浏览器都能渲染各种效果的字体。不过，未来浏览器可能会支持更好的渲染效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>这个文本是加粗的<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>这个文本是加粗的<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">big</span>&gt;</span>这个文本字体放大<span class="hljs-tag">&lt;/<span class="hljs-name">big</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>这个文本是斜体的<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>这个文本是斜体的<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>这个文本是缩小的<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>这个文本包含<br><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>下标<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>这个文本包含<br><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>上标<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记笔记</title>
    <link href="/2023/03/11/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/11/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、学习路线"><a href="#一、学习路线" class="headerlink" title="一、学习路线"></a>一、学习路线</h1><p>1.先学习 HTML、CSS 和 JavaScript 的基础知识。</p><p>​Vue 是一个基于 JavaScript 的框架，因此，首先需要学习 HTML、CSS 和 JavaScript 的基础知识，包括变量、数据类型、循环、条件语句等等。这些是 Vue 中非常基础的知识点，也是你之后学习 Vue 的基石。</p><p>2.掌握 Vue 的基本概念和语法</p><p>​掌握 Vue 的基本概念和语法是非常重要的，这包括 Vue 实例、组件、生命周期、指令、计算属性等等。建议可以先通过官方文档来学习 Vue 的基础知识，可以在学习过程中尝试一些例子来加深理解。</p><p>3.学习 Vue 的进阶特性</p><p>​掌握 Vue 的基础知识后，可以开始学习 Vue 的进阶特性，例如 Vue Router、Vuex、SSR 等等。这些特性可以帮助你更好地进行前端开发。</p><p>4.学习前端工具和框架</p><p>​学习前端工具和框架可以提高你的前端开发效率，例如 Webpack、ESLint、Babel、React 等等。这些工具和框架可以帮助你更好地管理项目和代码，提高代码质量。</p><p>5.实践</p><p>​学习理论知识是很重要的，但是实践才是最关键的。建议在学习过程中多写一些代码，可以自己搭建一个项目，尝试使用 Vue 和其他前端工具和框架来实现它</p><h1 id="二、HTML"><a href="#二、HTML" class="headerlink" title="二、HTML"></a>二、HTML</h1><h1 id="三、CSS"><a href="#三、CSS" class="headerlink" title="三、CSS"></a>三、CSS</h1><h1 id="四、JavaScript"><a href="#四、JavaScript" class="headerlink" title="四、JavaScript"></a>四、JavaScript</h1>]]></content>
    
    
    <categories>
      
      <category>前端 JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScrip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件中级考试笔记</title>
    <link href="/2023/03/11/%E8%BD%AF%E4%BB%B6%E4%B8%AD%E7%BA%A7%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/03/11/%E8%BD%AF%E4%BB%B6%E4%B8%AD%E7%BA%A7%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、考纲"><a href="#一、考纲" class="headerlink" title="一、考纲"></a>一、考纲</h1><ol><li>掌握计算机内的数据表示、算数和逻辑运算方法</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件中级证书考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件中级证书考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU架构与操作系统</title>
    <link href="/2023/02/12/Cpu%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/02/12/Cpu%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU架构与操作系统"><a href="#CPU架构与操作系统" class="headerlink" title="CPU架构与操作系统"></a>CPU架构与操作系统</h1><h2 id="一、CPU架构"><a href="#一、CPU架构" class="headerlink" title="一、CPU架构"></a>一、CPU架构</h2><p>架构以指令集区分</p><h3 id="1-指令集"><a href="#1-指令集" class="headerlink" title="1 指令集"></a>1 指令集</h3><p>计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。指令的强弱也是CPU的重要指标，指令集是提高微处理器效率的最有效的工具之一。从现阶段的主流体系结构讲，指令集可分为复杂指令集和精简指令集两部分。</p><h4 id="1-1-CISC-复杂指令集"><a href="#1-1-CISC-复杂指令集" class="headerlink" title="1.1 CISC(复杂指令集)"></a>1.1 CISC(复杂指令集)</h4><p>复杂指令集，也称为CISC指令集，英文名是CISC，(ComplexInstruction Set Computina的缩写)。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。其实它是英特尔生产的x86系列(也就是IA-32架构)CPU及其兼容CPU，如AMD、VIA的。即使是现在新起的X86-64(也被称 AMD64)都是属于CISC的范畴。</p><p><strong>X86 架构</strong><br>Intel x86是英特尔公司于1978年推出的16位微处理器。<br>x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构。<br>Intel在早期以80x86这样的数字格式来命名处理器，包括Intel 8086、80186、80286、80386（i386, 从16位时代带入了32位时代）以及80486，由于以“86”作为结尾，因此其架构被称为“x86”。由于数字并不能作为注册商标，因此Intel及其竞争者均在新一代处理器使用可注册的名称，如奔腾（Pentium）、酷睿（Core）、锐龙（Ryzen，AMD推出）。<br>x86的32位架构一般又被称作IA-32，全名为“Intel Architecture, 32-bit”。</p><p><strong>AMD64</strong><br>AMD64，或“x64”，是一种64位元的电脑处理器架构。它是基于现有32位元的x86架构，由AMD公司所开发。之后也被Intel采用，被其称为“Intel 64”。一般也被称作“x86-64”、“x64”。<br>值得注意的是，Intel也推出过IA-64架构，虽然名字上与“IA-32”相似，但两者完全不兼容，并不属于x86指令集架构家族。</p><p>复杂指令集的每个小指令可以执行一些较低级的硬件操作，指令数目多而复杂，每条指令的执行长度不同。因为指令执行较为复杂，所以每条指令的执行时间较长，但每个单条指令可以处理的工作较为丰富。常见的使用CISC指令集的CPU有AMD、Intel、VIA等x86架构的CPU。<br>由于AMD、Intel、VIA所开发出来的x86架构CPU被大量使用于个人电脑（Personal Computer），因此，个人电脑常被称为x86架构电脑。<br>在2003年以前由Inter所开发的x86架构CPU由8位升级到16、32位，后来AMD依此架构修改新一代的CPU为64为，为了区别两者的差异，因此64位的个人电脑CPU又被统称为x86-64架构。</p><h4 id="1-2-RISC-精简指令集"><a href="#1-2-RISC-精简指令集" class="headerlink" title="1.2 RISC(精简指令集)"></a>1.2 RISC(精简指令集)</h4><p>精简指令集计算机(RISC:Reduced Instruction Set ComputingRISC)是一种执行较少类型计算机指令的微处理器，起源干80年代的 MIPS主机(即RISC机)，RISC机中采用的微处理器统称RISC处理器。这样一来，它能够以更快的速度执行操作(每秒执行更多百万条指令即MIPS)。因为计算机执行每个指令类型都需要额外的品体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢纽约约克镇IBM研究中心的lohn Cocke证明，计笪机中约20%的指令承担了80%的工作，千1974年，他提出RISC的概念。许多当前的微芯片都使用RISC概念。</p><p>这种CPU设计中，指令集较为精简，每个指令的运行时间都很短，完成的操作也很简单，指令的执行性能较佳；但是若要做复杂的事情，就要由多个指令来完成。<br>目前世界上使用范围最广的CPU可能就是ARM这种架构。</p><h3 id="2-CISC和RISC区别"><a href="#2-CISC和RISC区别" class="headerlink" title="2 CISC和RISC区别"></a>2 CISC和RISC区别</h3><p>从硬件角度来看CISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。</p><p>而RISC执行的是等长精简指令集CPU在执行指的时候度较快目性能稳定。因此在并行外理方面RISC明显优CISCRISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。</p><h4 id="2-1-CISC"><a href="#2-1-CISC" class="headerlink" title="2.1 CISC"></a>2.1 CISC</h4><h5 id="1-CISC体系的指令特征"><a href="#1-CISC体系的指令特征" class="headerlink" title="1 CISC体系的指令特征"></a>1 CISC体系的指令特征</h5><ol><li><p>使用微代码。指令集可以直接在微代码存储器（比主存储器的速度快很多）里执行，新设计的处理器，只需增加较少的电晶体就可以执行同样的指令集，也可以很快地编写新的指令集程序。</p></li><li><p>庞大的指令集。可以减少编程所需要的代码行数，减轻程序员的负担。高级语言对应的指令集：包括双运算元格式、寄存器到寄存器、寄存器到存储器以及存储器到寄存器的指令。</p></li></ol><h5 id="2-CISC体系的优缺点"><a href="#2-CISC体系的优缺点" class="headerlink" title="2 CISC体系的优缺点"></a>2 CISC体系的优缺点</h5><ol><li><p>优点：能够有效缩短新指令的微代码设计时间，允许设计师实现 CISC 体系机器的向上兼容。新的系统可以使用一个包含早期系统的指令超集合，也就可以使用较早电脑上使用的相同软件。另外微程序指令的格式与高级语言相匹配，因而编译器并不一定要重新编写。</p></li><li><p>缺点：指令集以及芯片的设计比上一代产品更复杂，不同的指令，需要不同的时钟周期来完成，执行较慢的指令，将影响整台机器的执行效率。</p></li></ol><h4 id="2-2-RISC"><a href="#2-2-RISC" class="headerlink" title="2.2 RISC"></a>2.2 RISC</h4><h5 id="1-RISC体系的指令特征"><a href="#1-RISC体系的指令特征" class="headerlink" title="1 RISC体系的指令特征"></a>1 RISC体系的指令特征</h5><ol><li><p>精简指令集：包含了简单、基本的指令，通过这些简单、基本的指令，就可以组合成复杂指令。</p></li><li><p>同样长度的指令：每条指令的长度都是相同的，可以在一个单独操作里完成。</p></li><li><p>单机器周期指令：大多数的指令都可以在一个机器周期里完成，并且允许处理器在同一时间内执行一系列的指令。</p></li></ol><h5 id="2-RISC体系的优缺点"><a href="#2-RISC体系的优缺点" class="headerlink" title="2 RISC体系的优缺点"></a>2 RISC体系的优缺点</h5><p>优点：在使用相同的芯片技术和相同运行时钟下，RISC 系统的运行速度将是 CISC 的2～4倍。由于RISC处理器的指令集是精简的，它的内存管理单元、浮点单元等都能设计在同一块芯片上。RISC 处理器比相对应的 CISC 处理器设计更简单，所需要的时间将变得更短，并可以比CISC处理器应用更多先进的技术，开发更快的下一代处理器。</p><p>缺点：多指令的操作使得程序开发者必须小心地选用合适的编译器，而且编写的代码量会变得非常大。另外就是RISC体系的处理器需要更快的存储器，这通常都集成于处理器内部，就是L1 Cache（一级缓存）。</p><p> 综合上面所述，若要再进一步比较CISC与RISC之差异，可以由以下几点来进行分析：</p><ol><li><p>指令的形成：CISC 因指令复杂，故采用微指令码控制单元的设计，而RISC的指令90%是由硬件直接完成，只有10%的指令是由软件以组合的方式完成，因此指令执行时间上RISC较短，但RISC所须ROM空间相对的比较大，至于RAM使用大小应该与程序的应用比较有关系。</p></li><li><p>寻址模式：CISC的需要较多的寻址模式，而RISC只有少数的寻址模式，因此CPU在计算存储器有效位址时，CISC占用的汇流排周期较多。</p></li><li><p>指令的执行：CISC指令的格式长短不一，执行时的周期次数也不统一，而RISC结构刚好相反，故适合采用流水线处理架构的设计，进而可以达到平均一周期完成一指令的方向努力。显然的，在设计上RISC较CISC简单，同时因为CISC的执行步骤过多，闲置的单元电路等待时间增长，不利于平行处理的设计，所以就效能而言RISC较CISC还是占了上风，但RISC因指令精简化后造成应用程式码变大，需要较大的存储器空间，且存在指令种类较多等等的缺点。</p></li></ol><p><strong>补充：</strong></p><p>所谓的位（bit），指的是CPU一次读取数据的最大量。64位CPU代表CPU一次可以读写64位的数据，32位CPU则是CPU一次能读取32位的意思。因为CPU读取数据量有限制，因此能够从内存中读写的数据也就有所限制。所以一般32位的CPU能读写最大数据量，大概就是4GB。</p><h2 id="二、主流操作系统"><a href="#二、主流操作系统" class="headerlink" title="二、主流操作系统"></a>二、主流操作系统</h2><h3 id="1-银河麒麟桌面操作系统V4"><a href="#1-银河麒麟桌面操作系统V4" class="headerlink" title="1 银河麒麟桌面操作系统V4"></a>1 银河麒麟桌面操作系统V4</h3><p>银河麒麟桌面操作系统具有良好的软硬件兼容性，支持飞腾、鲲鹏等自主CPU及x86平台。银河麒麟桌面操作系统主要面向电子办公、家庭生活、个人娱乐。</p><h3 id="2-银河麒麟桌面操作系统V10"><a href="#2-银河麒麟桌面操作系统V10" class="headerlink" title="2 银河麒麟桌面操作系统V10"></a>2 银河麒麟桌面操作系统V10</h3><p>银河麒麟桌面操作系统V10是图形化桌面操作系统产品。现已适配国产主流软硬件产品，同源支持飞腾、鲲鹏、海思麒麟、龙芯、申威、海光、兆芯等国产CPU和Intel、AMD平台，通过功耗管理、内核锁及页拷贝、网络、VFS、NVME等针对性的深入优化。软件商店内包括自研应用和第三方商业软件在内的各类应用，同时提供Android兼容环境和Windows兼容环境。支持多CPU平台的统一软件升级仓库、版本在线更新功能。</p><h3 id="3-统信操作系统"><a href="#3-统信操作系统" class="headerlink" title="3 统信操作系统"></a>3 统信操作系统</h3><p>统信操作系统（UOS）是由统信软件开发的一款基于Linux内核的操作系统，分为统信桌面操作系统、统信操作系统服务器版和统信操作系统专用设备版。统信桌面操作系统V20以桌面应用场景为主，支持主流国产芯片平台的笔记本、台式机、一体机和工作站。系统包含原创专属的桌面环境、多款自研应用，以及众多来自开源社区的原生应用软件。通过系统预装的应用商店和互联网中的软件仓库，用户能够获得近千款应用软件的支持，可够满足日常办公和娱乐需求。</p><p>统信桌面操作系统V20具备极好的软硬件及外设兼容性。在硬件方面能够兼容联想、华为、清华同方、长城、曙光、航天科工、浪潮等整机厂商发布的主流型号终端设备；在软件方面，能够兼容流式、版式、电子签章等厂商发布的常用办公应用软件；在外设方面，能够兼容主流的打印机、扫描仪、高拍仪、读卡器等硬件设备。</p><p>统信桌面操作系统V20通过对整机、终端办公应用、服务端应用和硬件外设的适配支持，对桌面应用的开发、移植和优化，以及对应用场景解决方案的构建，完全满足项目支撑、平台应用、软件开发和系统定制的需求，体现了当今操作系统发展的最新水平；同时，也为党、政、军、能源、金融、军队军工等关键行业提供了符合当前业务需求和满足未来发展的平台支撑。</p><h3 id="4-CentOS7"><a href="#4-CentOS7" class="headerlink" title="4 CentOS7"></a>4 CentOS7</h3><p>CentOS 7是一个企业级的Linux发行版本，它源于RedHat免费公开的源代码进行再发行。CentOS 7内核更新至3.10.0、支持Linux容器、支持Open VMware Tools及3D图像即装即用、支持OpenJDK-7作为缺省JDK、支持内核空间内的iSCSI及FCoE、支持PTPv2等功能。</p><h4 id="4-1-发展历程"><a href="#4-1-发展历程" class="headerlink" title="4.1 发展历程"></a>4.1 发展历程</h4><p>2014年7月7日，CentOS 7第一个发行版发布，版本号为7.0.1406。<br>2015年3月31日至2020年4月27日，发布了CentOS 7.1.1503等八个版本。<br>2020年11月12日，CentOS 7最终版本CentOS 7.9.2009发布。<br>2020年12月8日，CentOS发布公告称CentOS Linux系列将不再更新维护，CentOS 7生命周期将于2024年6月30日终止。</p><h4 id="4-2-系统功能（部分）"><a href="#4-2-系统功能（部分）" class="headerlink" title="4.2 系统功能（部分）"></a>4.2 系统功能（部分）</h4><p><strong>内核</strong></p><table><thead><tr><th>crashkernel</th><th>CentOS 7支持在有大内存（最大为3TB）的系统中使用kdump崩溃转储机制，启用在一个以上 CPU 中引导crashnernel的功能。</th></tr></thead><tbody><tr><td>Swap内存压缩</td><td>CentOS 7引进了一个新功能，即swap内存压缩。Swap压缩由zswap执行，这是一个用于frontswap的精简后端。采用swap内存压缩技术可保证显著减少I&#x2F;O，并提高性能。</td></tr><tr><td>采用NUMA的调度和内存分配</td><td>在CentOS 7中，内核会在同一系统的不同NUMA节点间自动重置进程和内存以提高没有统一内存访问（NUMA）系统的性能。</td></tr><tr><td>APIC虚拟化</td><td>CentOS 7通过利用新处理器的硬件功能支持高级程序中断控制器（APIC）注册的虚拟化以便提高虚拟机监视器（VMM）中断处理能力。</td></tr><tr><td>vmcp内嵌在内核中</td><td>在CentOS 7中，vmcp内核模块内嵌在内核中。这可保证vmcp设备节点总会出现，同时用户可在不首先载入vmcp内核模块的情况下发送IBM z&#x2F;VM hypervisor控制程序命令。</td></tr><tr><td>全面DynTick支持</td><td>在CentOS 7中，<em>nohz_full</em>引导参数将最初的无缝内核功能延伸到额外的情况，比如可以停止tick的时候、可以使用per-cpu <em>nr_running&#x3D;1</em>设置的时候。即在CPU的运行队列中只有一个可运行的任务。</td></tr><tr><td>将内核模块列入黑名单</td><td>提供modprobe程序可让用户在安装时将内核模块放入黑名单。可通过运行命令：modprobe.blacklist&#x3D;<em>module</em>，禁用自动载入一个模块。</td></tr></tbody></table><p><strong>虚拟化</strong></p><table><thead><tr><th>PCI桥接</th><th>CentOS 7采用PCI桥接技术，可让用户配置32个以上的PCI设备（不支持桥接后的设备热插拔）。</th></tr></thead><tbody><tr><td>QEMU沙箱</td><td>CentOS 7使用内核系统调用过滤加强KVM虚拟化安全性，这提高了主机系统与虚拟机之间的独立性。</td></tr><tr><td>支持QEMU虚拟CPU热添加</td><td>CentOS 7中的QEMU提供虚拟CPU（vCPU）热添加支持。可在运行的虚拟机中添加虚拟CPU（vCPUS）以满足与负载关联的负载要求或者保持服务等级协议（SLA）。</td></tr><tr><td>多队列NIC</td><td>多队列virtio_net提供更好的可延伸性，每个虚拟CPU都有独立的传输或者接收队列以及可在不影响其他虚拟CPU的情况下使用的独立中断。</td></tr><tr><td>多队列virtio_scsi</td><td>多队列virtio_net提供更好的可延伸性。每个虚拟CPU都有独立的队列以及可在不影响其他虚拟CPU的情况下使用的独立中断。</td></tr><tr><td>KVM中的HyperV启示</td><td>CentOS 7已使用多个微软Hyper-V功能更新了KVM，例如：支持内存管理单元（MMU）和虚拟中断控制程序。微软在虚拟机和主机之间提供半虚拟API，通过在主机中使用这个功能的一部分，并根据微软的说明对其进行控制，微软Windows虚拟机就可以提高其性能。</td></tr><tr><td>QEMU虚拟机的I&#x2F;O节流</td><td>这个功能为QEMU虚拟机块设备提供I&#x2F;O节流。I&#x2F;O节流会延缓I&#x2F;O内存请求的处理。这样会延迟系统但可防止其死机。（注：不能节流数据层。）</td></tr><tr><td>基于VFIO的PCI设备分配</td><td>虚拟功能I&#x2F;O（VFIO）用户空间驱动程序界面为KVM虚拟机提供改进的PCI设备分配解决方案。VFIO提供内核级设备分离强化，提高设备访问的安全性，并与安全引导等功兼容。VFIO替换了前任系统中使用的KVM设备分配机制。</td></tr></tbody></table><p><strong>集群</strong></p><p>集群是多台计算机（节点）一同工作以便提高重要产品服务的可靠性、可扩展性和可用性。可利用CentOS 7的高可用性来根据性能、高可用性、负载平衡以及文件共享的不同需要采用各种不同的配置进行部署，具有以下功能特性：</p><table><thead><tr><th>Pacemaker集群管理器</th><th>CentOS 7使用Pacemaker替换rgmanager进行集群资源管理以及从节点失败中恢复。包括以下优点：资源配置的自动同步和版本管理；灵活的资源和fencing模式可与用户环境更紧密地对应；可使用fencing恢复资源层失败；在多节点中运行同一资源的能力；在两个不同模式之一的多个节点中运行同一资源的能力；Pacemaker不需要分布式锁管理程序；仲裁丢失或者形成多个分区时的可配置行为。</th></tr></thead><tbody><tr><td>keepalived和HAProxy</td><td>CentOS 7使用keepalived和HAProxy替换了负载平衡程序Piranha。keepalived软件包提供简单且强大的负载平衡和高可用功能，HAProxy为TCP和HTTP应用程序提供一个可靠的高性能网络负载平衡程序，特别适用于在需要持久性或者Layer7处理时有非常高负载的网页。</td></tr><tr><td>Pacemaker</td><td>Pacemaker 配置系统，也称pcs，替换了ccs、ricci和luci作为统一的集群配置和管理工具。其优点包括：命令行工具；可轻松自我启动集群，即初始化集群并使其开始运行；可配置集群选项；可添加、删除或者修改资源及其之间的关系。</td></tr><tr><td>新的资源代理</td><td>CentOS 7提供大量资源代理。资源代理时集群资源的标准化接口。资源代理可将一组标准操作转换为具体资源或者应用程序的步骤，并将其结果解读为成功或者失败。</td></tr></tbody></table><p><strong>文件系统</strong></p><table><thead><tr><th>支持 XFS 文件系统</th><th>CentOS 7中使用的默认文件系统是 XFS，它替换了前任系统中使用的第四代扩展的文件系统（ext4）。XFS是高度可扩展、高性能文件系统，支持高达16艾字节（约 1600万TB）的文件系统，多达8艾字节（约 800万TB）以及包含数千万条目的目录结构。XFS支持元数据日志，它可加快崩溃的恢复。XFS文件系统还可在挂载且活跃的情况下进行清理碎片和扩展操作。</th></tr></thead><tbody><tr><td>支持 IBM System z 中的 libhugetlbfs</td><td>CentOS 7支持IBM System z架构中的libhugetlbfs库，该库允许C和C++程序中的大页面透明开发，应用程序及中间件程序可从其性能优点或者大页面中受益而无需进行更改或者重新编译。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Cpu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU架构与操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtCreator</title>
    <link href="/2023/02/12/QtCreator%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/02/12/QtCreator%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="QtCreator"><a href="#QtCreator" class="headerlink" title="QtCreator"></a>QtCreator</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p>Qt Creator是使用Qt开发的IDE。Qt支持Windows、Linux&#x2F;Unix、Mac OS X、Android、BlackBerry、QNX等多种平台，Qt Creator为不同平台提供了统一的开发环境。</p><p>Qt Creator集成了Qt Designer、Qt Assistant、Help等工具。因此，在开发过程中可以很快的通过Designer来设计界面。如果想从Qt API中获得更详细的信息，只需要将光标定位到相应的类或函数并按下F1即可。</p><p>相关资料：</p><p>安装包</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VirtualApp-桌面云化技术</title>
    <link href="/2023/02/03/VirtualApp-%E6%A1%8C%E9%9D%A2%E4%BA%91%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/02/03/VirtualApp-%E6%A1%8C%E9%9D%A2%E4%BA%91%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>桌面云化</font></center><h1 id="1-设计"><a href="#1-设计" class="headerlink" title="1. 设计"></a>1. 设计</h1><p><strong>服务端代码：</strong></p><ol><li>创建一个套接字，用于与客户端通信。</li><li>等待客户端的连接请求。</li><li>建立与客户端的连接。</li><li>启动屏幕截图线程，不断获取桌面屏幕的当前图像。</li><li>压缩屏幕图像数据，并将其发送给客户端。</li></ol><p><strong>客户端代码：</strong></p><ol><li>连接到服务端。</li><li>接收服务端发送的屏幕图像数据。</li><li>解压屏幕图像数据。</li><li>将解压后的屏幕图像显示在客户端窗口中。</li><li>监听键盘和鼠标事件，并将其发送到服务端。</li></ol><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><p>服务端</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Ws2_32.lib&quot;</span>)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PORT = <span class="hljs-number">12345</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_SIZE = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_WIDTH = <span class="hljs-number">1920</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_HEIGHT = <span class="hljs-number">1080</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SCREEN_BPP = <span class="hljs-number">24</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">captureScreen</span><span class="hljs-params">(<span class="hljs-type">char</span>* buffer)</span> </span>&#123;<br>    HDC hdcScreen = <span class="hljs-built_in">GetDC</span>(<span class="hljs-literal">NULL</span>);<br>    HDC hdc = <span class="hljs-built_in">CreateCompatibleDC</span>(hdcScreen);<br>    HBITMAP hBitmap = <span class="hljs-built_in">CreateCompatibleBitmap</span>(hdcScreen, SCREEN_WIDTH, SCREEN_HEIGHT);<br>    <span class="hljs-built_in">SelectObject</span>(hdc, hBitmap);<br>    <span class="hljs-built_in">BitBlt</span>(hdc, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT, hdcScreen, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SRCCOPY);<br>    BITMAPINFOHEADER bih = &#123; <span class="hljs-number">0</span> &#125;;<br>    bih.biSize = <span class="hljs-built_in">sizeof</span>(BITMAPINFOHEADER);<br>    bih.biWidth = SCREEN_WIDTH;<br>    bih.biHeight = SCREEN_HEIGHT;<br>    bih.biPlanes = <span class="hljs-number">1</span>;<br>    bih.biBitCount = SCREEN_BPP;<br>    bih.biCompression = BI_RGB;<br>    bih.biSizeImage = (((SCREEN_WIDTH * SCREEN_BPP + <span class="hljs-number">31</span>) &amp; ~<span class="hljs-number">31</span>) &gt;&gt; <span class="hljs-number">3</span>) * SCREEN_HEIGHT;<br>    <span class="hljs-built_in">GetDIBits</span>(hdc, hBitmap, <span class="hljs-number">0</span>, SCREEN_HEIGHT, buffer, (BITMAPINFO*)&amp;bih, DIB_RGB_COLORS);<br>    <span class="hljs-built_in">ReleaseDC</span>(<span class="hljs-literal">NULL</span>, hdcScreen);<br>    <span class="hljs-built_in">DeleteDC</span>(hdc);<br>    <span class="hljs-built_in">DeleteObject</span>(hBitmap);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serveClient</span><span class="hljs-params">(SOCKET client)</span> </span>&#123;<br>    <span class="hljs-type">char</span> buffer[BUF_SIZE];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, BUF_SIZE);<br>        <span class="hljs-built_in">captureScreen</span>(buffer);<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">send</span>(client, buffer, BUF_SIZE, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (len == SOCKET_ERROR) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;send error&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">50</span>));<br>    &#125;<br>    <span class="hljs-built_in">closesocket</span>(client);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    WSAData wsaData;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) !=&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;WSAStartup error&quot;</span> &lt;&lt; std::endl; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br><br>SOCKET server = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="hljs-keyword">if</span> (server == INVALID_SOCKET) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;socket error&quot;</span> &lt;&lt; std::endl; <span class="hljs-built_in">WSACleanup</span>(); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br><br>sockaddr_in serverAddr = &#123; <span class="hljs-number">0</span> &#125;; serverAddr.sin_family = AF_INET; serverAddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); serverAddr.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(server, (sockaddr*)&amp;serverAddr, <span class="hljs-built_in">sizeof</span>(serverAddr)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bind error&quot;</span> &lt;&lt; std::endl; <span class="hljs-built_in">closesocket</span>(server); <span class="hljs-built_in">WSACleanup</span>(); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(server, SOMAXCONN) == SOCKET_ERROR) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;listen error&quot;</span> &lt;&lt; std::endl; <span class="hljs-built_in">closesocket</span>(server); <span class="hljs-built_in">WSACleanup</span>(); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;server started, waiting for clients...&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; sockaddr_in clientAddr = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-type">int</span> addrLen = <span class="hljs-built_in">sizeof</span>(clientAddr); SOCKET client = <span class="hljs-built_in">accept</span>(server, (sockaddr*)&amp;clientAddr, &amp;addrLen); <span class="hljs-keyword">if</span> (client == INVALID_SOCKET) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;accept error&quot;</span> &lt;&lt; std::endl; <span class="hljs-keyword">continue</span>; &#125; std::cout &lt;&lt; <span class="hljs-string">&quot;client connected&quot;</span> &lt;&lt; std::endl; std::thread <span class="hljs-built_in">t</span>(serveClient, client); t.<span class="hljs-built_in">detach</span>(); &#125;<br><br><span class="hljs-built_in">closesocket</span>(server); <span class="hljs-built_in">WSACleanup</span>(); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Screen Sharing Client<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: black;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-tag">canvas</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid gray;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;canvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;1920&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;1080&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:12345&#x27;</span>);</span><br><span class="language-javascript">        socket.<span class="hljs-property">binaryType</span> = <span class="hljs-string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="language-javascript">        socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;connected&#x27;</span>);</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> imageData = ctx.<span class="hljs-title function_">createImageData</span>(<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> data = imageData.<span class="hljs-property">data</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buffer.<span class="hljs-property">length</span>; i += <span class="hljs-number">3</span>) &#123;</span><br><span class="language-javascript">                data[i] = buffer[i + <span class="hljs-number">2</span>];</span><br><span class="language-javascript">                data[i + <span class="hljs-number">1</span>] = buffer[i + <span class="hljs-number">1</span>];</span><br><span class="language-javascript">                data[i + <span class="hljs-number">2</span>] = buffer[i];</span><br><span class="language-javascript">                data[i + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            ctx.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        socket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;disconnected&#x27;</span>);</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onkeydown</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">            socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;keydown&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">keyCode</span>: e.<span class="hljs-property">keyCode</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">shiftKey</span>: e.<span class="hljs-property">shiftKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">ctrlKey</span>: e.<span class="hljs-property">ctrlKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">altKey</span>: e.<span class="hljs-property">altKey</span></span><br><span class="language-javascript">            &#125;));</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onkeyup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">            socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;keyup&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">keyCode</span>: e.<span class="hljs-property">keyCode</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">shiftKey</span>: e.<span class="hljs-property">shiftKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">ctrlKey</span>: e.<span class="hljs-property">ctrlKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">altKey</span>: e.<span class="hljs-property">altKey</span></span><br><span class="language-javascript">            &#125;));</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        canvas.<span class="hljs-property">onmousedown</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">            socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;mousedown&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">button</span>: e.<span class="hljs-property">button</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">shiftKey</span>: e.<span class="hljs-property">shiftKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">ctrlKey</span>: e.<span class="hljs-property">ctrlKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">altKey</span>: e.<span class="hljs-property">altKey</span></span><br><span class="language-javascript">            &#125;));</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        canvas.<span class="hljs-property">onmouseup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">            socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;mouseup&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">button</span>: e.<span class="hljs-property">button</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">shiftKey</span>: e.<span class="hljs-property">shiftKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">ctrlKey</span>: e.<span class="hljs-property">ctrlKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">altKey</span>: e.<span class="hljs-property">altKey</span></span><br><span class="language-javascript">            &#125;));</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        canvas.<span class="hljs-property">onmousemove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">            socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;mousemove&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">x</span>: e.<span class="hljs-property">clientX</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">y</span>: e.<span class="hljs-property">clientY</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">shiftKey</span>: e.<span class="hljs-property">shiftKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">ctrlKey</span>: e.<span class="hljs-property">ctrlKey</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">altKey</span>: e.<span class="hljs-property">altKey</span></span><br><span class="language-javascript">            &#125;));</span><br><span class="language-javascript">        &#125;;</span><br></code></pre></td></tr></table></figure><h1 id="新设计"><a href="#新设计" class="headerlink" title="新设计"></a>新设计</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css">好的，以下是使用C++和Qt实现桌面云化技术的流程设计：<br><br>远程桌面连接：<br><br><span class="hljs-selector-tag">a</span>. 选择RDP或VNC协议进行远程桌面连接的实现，或使用现有的第三方库（如libvncserver）进行实现。<br><br><span class="hljs-selector-tag">b</span>. 实现服务器端和客户端之间的通信，包括建立连接、传输数据和断开连接等。<br><br>c. 在服务器端实现多用户连接管理，确保每个用户的远程桌面连接是独立的。<br><br>应用程序发布：<br><br><span class="hljs-selector-tag">a</span>. 实现应用程序的打包和发布，包括将应用程序打包成可执行文件或安装程序，以及将应用程序发布到远程计算机中。<br><br><span class="hljs-selector-tag">b</span>. 实现应用程序的启动和关闭，包括启动应用程序时的参数传递和关闭应用程序时的资源释放等。<br><br>c. 实现服务器端和客户端之间的通信，以便客户端可以访问远程应用程序。<br><br>d. 实现多用户应用程序发布管理，确保每个用户访问的应用程序是独立的。<br><br>身份验证和访问控制：<br><br><span class="hljs-selector-tag">a</span>. 实现身份验证模块，包括用户身份验证和访问控制等。<br><br><span class="hljs-selector-tag">b</span>. 实现服务器端和客户端之间的通信，以便客户端可以进行身份验证和访问控制。<br><br>c. 实现多用户身份验证和访问控制管理，确保每个用户的身份验证和访问控制是独立的。<br><br>网络安全：<br><br><span class="hljs-selector-tag">a</span>. 使用Qt的SSL模块实现网络安全，确保数据传输的安全性。<br><br><span class="hljs-selector-tag">b</span>. 实现服务器端和客户端之间的通信时使用SSL协议进行加密传输。<br><br>c. 实现多用户网络安全管理，确保每个用户的数据传<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>VirtualApp-桌面云化技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libcurl 库</title>
    <link href="/2022/12/16/libcurl/"/>
    <url>/2022/12/16/libcurl/</url>
    
    <content type="html"><![CDATA[<h1 id="libcurl-库"><a href="#libcurl-库" class="headerlink" title="libcurl 库"></a>libcurl 库</h1><h2 id="一、libcurl-介绍"><a href="#一、libcurl-介绍" class="headerlink" title="一、libcurl 介绍"></a>一、libcurl 介绍</h2><p>​用不同的协议连接和沟通不同的服务器。</p><p>​libcurl主要功能就是用不同的协议连接和沟通不同的服务器~也就是相当封装了的sockPHP 支持libcurl（允许你用不同的协议连接和沟通不同的服务器）。 libcurl当前支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传（当然你也可以使用PHP的ftp扩展）, HTTP基本表单上传，代理，cookies,和用户认证。</p><p><em><strong>来源于百度百科</strong></em></p><h2 id="二、libcurl-接口说明"><a href="#二、libcurl-接口说明" class="headerlink" title="二、libcurl 接口说明"></a>二、libcurl 接口说明</h2><p>libcurl的easy interface是最基本的用法，简要流程为：</p><ol><li>在主线程中调用<code>curl_global_init(CURL_GLOBAL_ALL)</code>初始化</li><li>调用<code>curl_easy_init</code>获取一个句柄；</li><li>调用<code>curl_easy_setopt</code>函数设置此次传输的一些基本参数，如url地址、http头、cookie信息、发送超时时 间等，其中，CURLOPT_URL是必设的选项；</li><li>设置完成后，调用<code>curl_easy_perform</code>函数发送数据；</li><li>数据发送完毕后，调用<code>curl_easy_cleanup</code>清空句柄；</li><li>调用<code>curl_global_cleanup()</code>做清理工作。</li></ol><h2 id="三、libcurl-示例"><a href="#三、libcurl-示例" class="headerlink" title="三、libcurl 示例"></a>三、libcurl 示例</h2><h3 id="1-http"><a href="#1-http" class="headerlink" title="1.http"></a>1.http</h3><p><strong>① 构造中进行全局初始化</strong></p><p><code>curl_global_init(CURL_GLOBAL_ALL); </code></p><p><em>一个进程调用一次</em></p><p><strong>②析构中做全局的清理工作</strong></p><p><code>curl_global_cleanup();</code></p><p><em>一个进程调用一次</em></p><p><strong>③方法中进行局部初始化以及局部清理操作，和组装数据传输相关操作</strong></p><p>以post为例，来源于CSDN，和ppt中的类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++_CURL">bool curl_post_req(const std::string &amp;url, const std::string &amp;postParams, std::string &amp;response)  <br>&#123;  <br>    <br>    CURL *curl = curl_easy_init();  <br>    CURLcode res;  <br>    if (curl)  <br>    &#123;  <br>        // set params  <br>        curl_easy_setopt(curl, CURLOPT_POST, 1);<br>        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());<br>        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postParams.c_str());<br>        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_call_back);  <br>        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&amp;response);  <br>        <br>        // start req  <br>        res = curl_easy_perform(curl);  <br>        if (res != CURLE_OK) &#123;<br><br>            LOG(NOTICE) &lt;&lt; &quot;curl_easy_perform() failed: &quot; + std::string(curl_easy_strerror(res));      <br>            return false;<br>        &#125;  <br><br>        long response_code = 0;<br>        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;response_code);<br>        <br>        if (response_code &lt; 200 || response_code &gt;= 300 || response.empty()) &#123;<br><br>            LOG(WARNING) &lt;&lt; &quot;http failed code: &quot; &lt;&lt; response_code;      <br>            return false;<br>        &#125;<br>        else &#123;<br><br>            LOG(NOTICE) &lt;&lt; &quot;http success code: &quot; &lt;&lt; response_code;<br>        &#125;<br><br>    &#125;  <br>    // release curl  <br>    curl_easy_cleanup(curl);  <br>    return true;  <br>&#125;  <br><br>//回调<br>size_t write_call_back(void *contents, size_t size, size_t nmemb, std::string *userp) &#123;<br><br>    userp-&gt;append((char *) contents, size * nmemb);<br>    return size * nmemb;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-ftp"><a href="#2-ftp" class="headerlink" title="2.ftp"></a>2.ftp</h3><p>文件存储</p><p><strong>① 上传文件Demo，来源于CSDN</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++_CURL">int main()<br>&#123;<br>    char url = &quot;ftp://……&quot;;//ftp的地址<br>    char fileName = &quot;test.txt&quot;; //文件名称<br><br>    FILE* fp = fopen(fileName,&quot;rb&quot;);<br>    if(fp == NULL)<br>    &#123;<br>        cout&lt;&lt;&quot;file open failed!&quot;&lt;&lt;endl;<br>        return -1;<br>    &#125;<br>    fseek(fp,0L,SEEK_END);<br>    long fileSize = ftell(fp);//要上传文件的大小<br>    fseek(fp,0L,SEEK_SET);//光标设置在文件最开始<br><br>    curl_global_init(CURL_GLOBAL_ALL);<br>    CURL* curl = curl_easy_init();<br>    if(!curl)<br>    &#123;<br>        fclose(fp);<br>        cout&lt;&lt;&quot;curl init failed!&quot;&lt;&lt;endl;<br>        return -1;<br>    &#125;<br>    //这里是传输的一些参数设定<br>    curl_easy_setopt(curl,CURLOPT_READDATE,fp);<br>    curl_easy_setopt(curl,CURLOPT_INFILESIZE,fileSize);<br>    curl_easy_setopt(curl,CURLOPT_UPLOAD,1L);<br>    curl_easy_setopt(curl,CURLOPT_URL,url);<br>    //如果目录不存在，则创建<br>    curl_easy_setopt(curl,CURLOPT_FTP_CREATE_MISSING_DIRS,1L);<br><br>    CURLcode result = curl_easy_perform(curl);<br>    if(result != CURLE_OK)<br>    &#123;<br>        cout&lt;&lt;&quot;error type : &quot;&lt;&lt;result&lt;&lt;endl;<br>        curl_easy_cleanup(curl);<br>        curl_global_cleanup();<br>        fclose(fp);<br>        return -1;<br>    &#125;<br>    curl_easy_cleanup(curl);<br>    curl_global_cleanup();<br>    fclose(fp);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>②下载文件</p><p>③删除文件</p><h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><p>应用场景</p><p>前端：C端xxxx接口调用java服务</p><p>网页接口调用</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>libcurl 库</tag>
      
      <tag>http</tag>
      
      <tag>ftp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础乐理学习笔记（部分）</title>
    <link href="/2022/05/09/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/09/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础乐理"><a href="#基础乐理" class="headerlink" title="基础乐理"></a>基础乐理</h1><h2 id="第一课：唱名"><a href="#第一课：唱名" class="headerlink" title="第一课：唱名"></a>第一课：唱名</h2><p>唱名：  0   1    2    3    4    5    6    7</p><p>​         do  re   mi  fa  sol  la   si</p><p>0代表休止符，不唱</p><table><thead><tr><th>第一天</th><th>第2-3天</th><th>第4-6天</th><th>第7-10天</th><th>第11到15天</th></tr></thead><tbody><tr><td>145</td><td>6153</td><td>37214</td><td>671253</td><td>2167453</td></tr><tr><td>236</td><td>3624</td><td>65143</td><td>541236</td><td>7432615</td></tr><tr><td>467</td><td>1642</td><td>14726</td><td>524167</td><td>5643172</td></tr><tr><td>126</td><td>5467</td><td>24561</td><td>137654</td><td>2167345</td></tr><tr><td>357</td><td>2765</td><td>74516</td><td>734126</td><td>1726345</td></tr></tbody></table><h2 id="第二课：简谱构造"><a href="#第二课：简谱构造" class="headerlink" title="第二课：简谱构造"></a>第二课：简谱构造</h2><p><img src="/../images/image-20220404121122302.png" alt="image-20220404121122302"></p><h2 id="第三课-：调号、拍号、情绪与速度"><a href="#第三课-：调号、拍号、情绪与速度" class="headerlink" title="第三课 ：调号、拍号、情绪与速度"></a>第三课 ：调号、拍号、情绪与速度</h2><p>拍号：</p><p><img src="/../images/image-20220404122719808.png" alt="image-20220404122719808"></p><p>情绪：<img src="/../images/image-20220404122744157.png" alt="image-20220404122744157"></p><p><img src="/../images/image-20220404122829140.png" alt="image-20220404122829140"></p><p>速度：</p><p><img src="/../images/image-20220404122816847.png" alt="image-20220404122816847"></p><h2 id="第四课：音名，钢琴键盘"><a href="#第四课：音名，钢琴键盘" class="headerlink" title="第四课：音名，钢琴键盘"></a>第四课：音名，钢琴键盘</h2><p>音名：CDEFGAB</p><p>调号  ： 唱名&#x3D;音名</p><p>钢琴 黑+白 88个键位，</p><p>音名位置永不会改变（无论什么情况，无论什么乐器）</p><p><img src="/../images/image-20220404160446454.png" alt="image-20220404160446454"></p><h2 id="第五课：深入了解-1-C"><a href="#第五课：深入了解-1-C" class="headerlink" title="第五课：深入了解 1&#x3D;C"></a>第五课：深入了解 1&#x3D;C</h2>]]></content>
    
    
    <categories>
      
      <category>基础乐理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础乐理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存映射文件操作</title>
    <link href="/2022/05/05/%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    <url>/2022/05/05/%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1、CreateFile-函数"><a href="#1、CreateFile-函数" class="headerlink" title="1、CreateFile 函数"></a>1、CreateFile 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">HANDLE <span class="hljs-title">CreateFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"> _In_ LPCSTR lpFileName,<span class="hljs-comment">//指向文件名的指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">    _In_ DWORD dwDesiredAccess,<span class="hljs-comment">// 访问模式（写 / 读）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    _In_ DWORD dwShareMode,<span class="hljs-comment">// 共享模式 </span></span></span><br><span class="hljs-params"><span class="hljs-function">    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,<span class="hljs-comment">// 指向安全属性的指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">    _In_ DWORD dwCreationDisposition,<span class="hljs-comment">// 如何创建</span></span></span><br><span class="hljs-params"><span class="hljs-function">    _In_ DWORD dwFlagsAndAttributes, <span class="hljs-comment">// 文件属性 </span></span></span><br><span class="hljs-params"><span class="hljs-function">    _In_opt_ HANDLE hTemplateFile<span class="hljs-comment">// 用于复制文件句柄 </span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br></code></pre></td></tr></table></figure><p>参数说明</p><table><thead><tr><th>参数</th><th>类型及说明</th></tr></thead><tbody><tr><td>lpFileName</td><td>String ，要打开的文件的名字</td></tr><tr><td>dwDesiredAccess</td><td>Long ，如果为 GENERIC_READ 表示允许对设备进行读访问；如果为 GENERIC_WRITE 表示允许对设备进行写访问（可组合使用）；如果为零，表示只允许获取与一个设备有关的信息</td></tr><tr><td>dwShareMode</td><td>Long ，零表示不共享； FILE_SHARE_READ 和 &#x2F; 或 FILE_SHARE_WRITE 表示允许对文件进行共享访问</td></tr><tr><td>lpSecurityAttributes</td><td>SECURITY_ATTRIBUTES ，指向一个 SECURITY_ATTRIBUTES 结构的指针，定义了文件的安全特性（如果操作系统支持的话）</td></tr><tr><td>dwCreationDisposition</td><td>Long ，下述常数之一:</td></tr><tr><td></td><td>CREATE_NEW 创建文件；如文件存在则会出错。</td></tr><tr><td></td><td>CREATE_ALWAYS创建文件，会改写前一个文件</td></tr><tr><td></td><td>OPEN_ALWAYS如文件不存在则创建它</td></tr><tr><td></td><td>OPEN_EXISTING文件必须已经存在。</td></tr><tr><td></td><td>TRUNCATE_EXISTINGj将现有文件缩短为零长度</td></tr><tr><td>dwFlagsAndAttributes</td><td>Long ，一个或多个下述常数</td></tr><tr><td></td><td>FILE_ATTRIBUTE_ARCHIVE标记归档属性</td></tr><tr><td></td><td>FILE_ATTRIBUTE_COMPRESSED将文件标记为已压缩，或者标记为文件在目录中的默认压缩方式</td></tr><tr><td></td><td>FILE_ATTRIBUTE_NORMAL默认属性</td></tr><tr><td></td><td>FILE_ATTRIBUTE_HIDDEN隐藏文件或目录</td></tr><tr><td></td><td>FILE_ATTRIBUTE_READONLY文件为只读</td></tr><tr><td></td><td>FILE_ATTRIBUTE_SYSTEM文件为系统文件</td></tr><tr><td></td><td>FILE_FLAG_WRITE_THROUGH操作系统不得推迟对文件的写操作</td></tr><tr><td></td><td>FILE_FLAG_OVERLAPPED允许对文件进行重叠操作</td></tr><tr><td></td><td>FILE_FLAG_NO_BUFFERING禁止对文件进行缓冲处理。文件只能写入磁盘卷的扇区块</td></tr><tr><td></td><td>FILE_FLAG_RANDOM_ACCESS针对随机访问对文件缓冲进行优化</td></tr><tr><td></td><td>FILE_FLAG_SEQUENTIAL_SCAN针对连续访问对文件缓冲进行优化</td></tr><tr><td></td><td>FILE_FLAG_DELETE_ON_CLOSE关闭了上一次打开的句柄后，将文件删除。特别适合临时文件</td></tr><tr><td></td><td>也可在 Windows NT 下组合使用下述常数标记：</td></tr><tr><td></td><td>SECURITY_ANONYMOUS ， SECURITY_IDENTIFICATION ， SECURITY_IMPERSONATION ，SECURITY_DELEGATION ， SECURITY_CONTEXT_TRACKING ， SECURITY_EFFECTIVE_ONLY</td></tr><tr><td>hTemplateFile</td><td>Long ，如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性</td></tr></tbody></table><h3 id="2、CreateFileMapping函数"><a href="#2、CreateFileMapping函数" class="headerlink" title="2、CreateFileMapping函数"></a>2、CreateFileMapping函数</h3><p>为指定文件创建或打开命名或未命名的文件映射对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">HANDLE WINAPI CreateFileMapping（<br>  _In_ HANDLE hFile，<br>  _In_opt_ LPSECURITY_ATTRIBUTES lpAttributes，<br>  _In_ DWORD flProtect，<br>  _In_ DWORD dwMaximumSizeHigh，<br>  _In_ DWORD dwMaximumSizeLow，<br>  _In_opt_ LPCTSTR lpName<br>）;<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ol><li>hFile [in]<br>从中创建文件映射对象的文件句柄。</li></ol><p>​       必须使用与flProtect参数指定的保护标志兼容的访问权限打开该文件。它不是必需的，但建议打开要映射的文件以进行独占访问。有关更多信息，请参阅文件安全性和访问权限。</p><p>​       如果hFile为INVALID_HANDLE_VALUE，则调用进程还必须在dwMaximumSizeHigh和dwMaximumSizeLow参数中指定文件映射对象的大小。在此方案中，CreateFileMapping创建指定大小的文件映射对象，该对象由系统页面文件而不是文件系统中的文件支持。</p><ol start="2"><li>lpAttributes [in，optional]<br>指向SECURITY_ATTRIBUTES结构的指针，该结构确定子进程是否可以继承返回的句柄。 SECURITY_ATTRIBUTES结构的lpSecurityDescriptor成员为新文件映射对象指定安全描述符。</li></ol><p>​       如果lpAttributes为NULL，则无法继承句柄，文件映射对象将获取默认安全描述符。文件映射对象的默认安全描述符中的访问控制列表（ACL）来自创建者的     主要或模拟令牌。有关更多信息，请参阅文件映射安全性和访问权限。</p><ol start="3"><li>flProtect [in]<br>指定文件映射对象的页面保护。对象的所有映射视图必须与此保护兼容。</li></ol><p>​       此参数可以是以下值之一。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td><strong>PAGE_EXECUTE_READ</strong>   0x20</td><td>允许将视图映射为只读，写时复制或执行访问。<br/>必须使用GENERIC_READ和GENERIC_EXECUTE访问权限创建hFile参数指定的文件句柄。<br/>Windows Server 2003和Windows XP：<br/>在带有SP1的Windows XP和带有SP1的Windows Server 2003之前，此值不可用。</td></tr><tr><td><strong>PAGE_EXECUTE_READWRITE</strong>     0x40</td><td>允许将视图映射为只读，写时复制，读&#x2F;写或执行访问。<br/>必须使用GENERIC_READ，GENERIC_WRITE和GENERIC_EXECUTE访问权限创建hFile参数指定的文件句柄。<br/>Windows Server 2003和Windows XP：在带有SP1的Windows XP和带有SP1的Windows Server 2003之前，此值不可用。</td></tr><tr><td><strong>PAGE_EXECUTE_WRITECOPY</strong>    0x80</td><td>允许将视图映射为只读，写时复制或执行访问。该值等于PAGE_EXECUTE_READ。<br/>必须使用GENERIC_READ和GENERIC_EXECUTE访问权限创建hFile参数指定的文件句柄。<br/>Windows Vista：在Windows Vista SP1之前，此值不可用。<br/>Windows Server 2003和Windows XP：不支持此值。</td></tr><tr><td>PAGE_READONLY                      0x02</td><td>允许映射视图以进行只读或写时复制访问。尝试写入特定区域会导致访问冲突。<br/>必须使用GENERIC_READ访问权限创建hFile参数指定的文件句柄。<br/></td></tr><tr><td>PAGE_READWRITE                     0x04</td><td>允许映射视图以进行只读，写时复制或读&#x2F;写访问。<br/>必须使用GENERIC_READ和GENERIC_WRITE访问权限创建hFile参数指定的文件句柄。</td></tr><tr><td>PAGE_WRITECOPY                    0x08</td><td>允许映射视图以进行只读或写时复制访问。该值相当于PAGE_READONLY。<br/>必须使用GENERIC_READ访问权限创建hFile参数指定的文件句柄。<br/>应用程序可以通过将它们与前面的页面保护值之一组合来为文件映射对象指定以下一个或多个属性。</td></tr><tr><td>SEC_COMMIT                0x8000000</td><td>如果文件映射对象由操作系统页面文件（hfile参数为INVALID_HANDLE_VALUE）支持，则指定当文件视图映射到进程地址空间时，将提交整个页面范围而不是保留。系统必须具有足够的可提交页面来保存整个映射。否则，CreateFileMapping失败。<br/>此属性对可执行映像文件或数据文件支持的文件映射对象没有影响（hfile参数是文件的句柄）。<br/>SEC_COMMIT不能与SEC_RESERVE结合使用。<br/>如果未指定任何属性，则假定为SEC_COMMIT。</td></tr><tr><td>SEC_IMAGE                  0x1000000</td><td>指定hFile参数指定的文件是可执行映像文件。<br/>SEC_IMAGE属性必须与页面保护值（如PAGE_READONLY）结合使用。但是，此页面保护值对可执行映像文件的视图没有影响。可执行文件视图的页面保护由可执行文件本身决定。<br/>SEC_IMAGE没有其他属性有效。</td></tr><tr><td>SEC_IMAGE_NO_EXECUTE           0x11000000</td><td>指定hFile参数指定的文件是不会执行的可执行映像文件，并且加载的映像文件将不会运行强制完整性检查。此外，映射使用SEC_IMAGE_NO_EXECUTE属性创建的文件映射对象的视图不会调用使用PsSetLoadImageNotifyRoutine内核API注册的驱动程序回调。<br/>SEC_IMAGE_NO_EXECUTE属性必须与PAGE_READONLY页面保护值组合使用。 SEC_IMAGE_NO_EXECUTE没有其他属性有效。<br/>Windows Server 2008 R2，Windows 7，Windows Server 2008，Windows Vista，Windows Server 2003和Windows XP：Windows Server 2012和Windows 8之前不支持此值。</td></tr><tr><td>SEC_LARGE_PAGES                  0x80000000</td><td>允许大页面用于由操作系统页面文件支持的文件映射对象（hfile参数为INVALID_HANDLE_VALUE）。由可执行映像文件或数据文件支持的文件映射对象不支持此属性（hFile参数是可执行映像或数据文件的句柄）。<br/>文件映射对象的最大大小必须是GetLargePageMinimum函数返回的大页面的最小大小的倍数。如果不是，则CreateFileMapping失败。映射使用SEC_LARGE_PAGES创建的文件映射对象的视图时，基址和视图大小也必须是最小大页面大小的倍数。<br/>SEC_LARGE_PAGES需要在调用者令牌中启用SeLockMemoryPrivilege特权。<br/>如果指定了SEC_LARGE_PAGES，则还必须指定SEC_COMMIT。<br/>Windows Server 2003：Windows Server 2003 SP1之前不支持此值。<br/>Windows XP：不支持此值。</td></tr><tr><td>SEC_NOCACHE                           0x10000000</td><td>将所有页面设置为不可缓存。<br/>应用程序不应使用此属性，除非设备明确要求。使用带有SEC_NOCACHE映射的内存的互锁函数可能会导致EXCEPTION_ILLEGAL_INSTRUCTION异常。<br/>SEC_NOCACHE要求设置SEC_RESERVE或SEC_COMMIT属性。</td></tr><tr><td>SEC_RESERVE                             0x4000000</td><td>如果文件映射对象由操作系统页面文件（hfile参数为INVALID_HANDLE_VALUE）支持，则指定当文件视图映射到进程地址空间时，整个页面范围保留供进程以后使用而非承诺。<br/>可以在后续调用VirtualAlloc函数时提交保留页面。提交页面后，无法使用VirtualFree函数释放或取消它们。<br/>此属性对可执行映像文件或数据文件支持的文件映射对象没有影响（hfile参数是文件的句柄）。<br/>SEC_RESERVE不能与SEC_COMMIT结合使用。</td></tr><tr><td>SEC_WRITECOMBINE                          0x40000000</td><td>将所有页面设置为写入组合。<br/>应用程序不应使用此属性，除非设备明确要求。使用带有SEC_WRITECOMBINE映射的内存的互锁函数可能会导致EXCEPTION_ILLEGAL_INSTRUCTION异常。<br/>SEC_WRITECOMBINE需要设置SEC_RESERVE或SEC_COMMIT属性。<br/>Windows Server 2003和Windows XP：Windows Vista之前不支持此标志。</td></tr></tbody></table><ol start="4"><li><p>dwMaximumSizeHigh [in]<br>文件映射对象最大大小的高阶DWORD。</p></li><li><p>dwMaximumSizeLow [in]<br>文件映射对象的最大大小的低位DWORD。</p><pre><code class="hljs">如果此参数和dwMaximumSizeHigh为0（零），则文件映射对象的最大大小等于hFile标识的文件的当前大         小。</code></pre></li></ol><p>​   尝试映射长度为0（零）的文件失败，错误代码为ERROR_FILE_INVALID。应用程序应测试长度为0（零）的文      件并拒绝这些文件。</p><ol start="6"><li>lpName [in，optional]<br>文件映射对象的名称。</li></ol><p>​   如果此参数与现有映射对象的名称匹配，则该函数请求具有flProtect指定的保护的对象的访问权限。</p><p>​   如果此参数为NULL，则创建没有名称的文件映射对象。</p><p>​   如果lpName与现有事件，信号量，互斥锁，等待计时器或作业对象的名称匹配，则该函数将失败，并且         GetLastError函数将返回ERROR_INVALID_HANDLE。这是因为这些对象共享相同的命名空间。</p><p>​该名称可以具有“Global”或“Local”前缀，以在全局或会话命名空间中显式创建对象。名称的其余部分可以包含除反斜杠字符（\）之外的任何字符。从会话零以外的会话在全局命名空间中创建文件映射对象需要   SeCreateGlobalPrivilege特权。有关更多信息，请参阅内核对象命名空间。</p><p>​通过使用终端服务会话实现快速用户切换。第一个登录用户使用会话0（零），下一个登录用户使用会话1    （一），依此类推。内核对象名称必须遵循为终端服务概述的准则，以便应用程序可以支持多个用户。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>如果函数成功，则返回值是新创建的文件映射对象的句柄。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言 内存映射 文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遍历、复制文件</title>
    <link href="/2022/05/04/%E9%81%8D%E5%8E%86%E3%80%81%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/05/04/%E9%81%8D%E5%8E%86%E3%80%81%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h1 id="一-、C-代码"><a href="#一-、C-代码" class="headerlink" title="一 、C++代码"></a>一 、C++代码</h1><p>直接放源码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">//文件传输速率 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLUSH_NUM 32768*16</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//复制文件</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CopyFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; FileNameIn, std::string &amp; FileNameOut)</span></span>;<br><br><span class="hljs-comment">//遍历输入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getAllFiles</span><span class="hljs-params">(string path, vector&lt;string&gt;&amp; files)</span></span>;<br><br><span class="hljs-comment">//遍历输出</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getAllHaveFiles</span><span class="hljs-params">(string path, std::string InFile)</span></span>;<br><br><span class="hljs-comment">//输出文件夹</span><br><span class="hljs-type">const</span> std::string outPath = <span class="hljs-string">&quot;D:/shuchu&quot;</span>;<br><span class="hljs-comment">//被复制文件夹</span><br><span class="hljs-type">const</span> std::string InPath2 = <span class="hljs-string">&quot;D:/shuru&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;string&gt; files;<br><span class="hljs-comment">//测试</span><br>std::string DistAll = <span class="hljs-string">&quot;AllFiles.txt&quot;</span>; <span class="hljs-comment">//记录文件个数</span><br><span class="hljs-built_in">getAllFiles</span>(InPath2, files);<span class="hljs-comment">//所有文件与文件夹的路径都输出</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofn</span><span class="hljs-params">(DistAll)</span></span>; <span class="hljs-comment">//输出文件流</span><br><span class="hljs-type">int</span> size = files.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> FaiNum = <span class="hljs-number">0</span>;<br>ofn &lt;&lt; size &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>ofn &lt;&lt; files[i] &lt;&lt; endl;<br>&#125;<br>ofn.<span class="hljs-built_in">close</span>();<br><br>std::<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CopyFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; FileNameIn,std::string &amp; FileNameOut)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(FileNameIn, ios::binary)</span></span>;<br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(FileNameOut, ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!in) <br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;open file error&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; FileNameIn &lt;&lt; <span class="hljs-string">&quot;   ----   失败&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!out) <br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;open file error&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; FileNameOut &lt;&lt; <span class="hljs-string">&quot;   ----   失败&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">char</span> flush[FLUSH_NUM];<br><span class="hljs-keyword">while</span> (!in.<span class="hljs-built_in">eof</span>()) <br>&#123;<br>in.<span class="hljs-built_in">read</span>(flush, FLUSH_NUM);<br>out.<span class="hljs-built_in">write</span>(flush, in.<span class="hljs-built_in">gcount</span>());<br><span class="hljs-comment">//printf(&quot;%d&quot;, in.gcount());</span><br>&#125;<br>std::cout &lt;&lt; FileNameIn &lt;&lt; <span class="hljs-string">&quot;   &gt;&gt;    &quot;</span>;<br>std::cout &lt;&lt; FileNameOut &lt;&lt;<span class="hljs-string">&quot;succeed&quot;</span>&lt;&lt; std::endl &lt;&lt; std::endl;<br>in.<span class="hljs-built_in">close</span>();<br>out.<span class="hljs-built_in">close</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getAllFiles</span><span class="hljs-params">(string path, vector&lt;string&gt;&amp; files)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//文件句柄 </span><br><span class="hljs-type">intptr_t</span>  hFile = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//文件信息 </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_finddata_t</span> fileinfo; <span class="hljs-comment">//很少用的文件信息读取结构</span><br>string p; <span class="hljs-comment">//string类很有意思的一个赋值函数:assign()，有很多重载版本</span><br><span class="hljs-keyword">if</span> ((hFile = _findfirst(p.<span class="hljs-built_in">assign</span>(path).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\\*&quot;</span>).<span class="hljs-built_in">c_str</span>(), &amp;fileinfo)) != <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">if</span> ((fileinfo.attrib &amp; _A_SUBDIR)) <span class="hljs-comment">//判断是否为文件夹</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(fileinfo.name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(fileinfo.name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//files.push_back(p.assign(path).append(&quot;/&quot;).append(fileinfo.name));//保存文件夹名字</span><br><span class="hljs-built_in">getAllFiles</span>(p.<span class="hljs-built_in">assign</span>(path).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-built_in">append</span>(fileinfo.name), files);<span class="hljs-comment">//递归当前文件夹</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">//文件处理</span><br>&#123;<br><span class="hljs-type">int</span> nameSize = <span class="hljs-built_in">strlen</span>(fileinfo.name);<br><br><span class="hljs-keyword">if</span> (nameSize &lt;= <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (fileinfo.name[nameSize <span class="hljs-number">-3</span>] == <span class="hljs-string">&#x27;m&#x27;</span>&amp;&amp;fileinfo.name[nameSize - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;p&#x27;</span>)<br>&#123;<br>files.<span class="hljs-built_in">push_back</span>(p.<span class="hljs-built_in">assign</span>(path).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-built_in">append</span>(fileinfo.name));<span class="hljs-comment">//文件名</span><br>std::string inFile = p.<span class="hljs-built_in">assign</span>(path).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-built_in">append</span>(fileinfo.name);<br>std::string outFile = outPath + <span class="hljs-string">&quot;/&quot;</span> + fileinfo.name;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">getAllHaveFiles</span>(outPath, fileinfo.name))<br>&#123;<br><span class="hljs-built_in">CopyFile</span>(inFile, outFile);<br>&#125;<br><br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (_findnext(hFile, &amp;fileinfo) == <span class="hljs-number">0</span>); <span class="hljs-comment">//寻找下一个，成功返回0，否则-1</span><br>_findclose(hFile);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getAllHaveFiles</span><span class="hljs-params">(string path, std::string InFile)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//文件句柄 </span><br><span class="hljs-type">intptr_t</span>  hFile = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//文件信息 </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_finddata_t</span> fileinfo; <span class="hljs-comment">//很少用的文件信息读取结构</span><br>string p; <span class="hljs-comment">//string类很有意思的一个赋值函数:assign()，有很多重载版本</span><br><span class="hljs-keyword">if</span> ((hFile = _findfirst(p.<span class="hljs-built_in">assign</span>(path).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\\*&quot;</span>).<span class="hljs-built_in">c_str</span>(), &amp;fileinfo)) != <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">if</span> ((fileinfo.attrib &amp; _A_SUBDIR)) <span class="hljs-comment">//判断是否为文件夹</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(fileinfo.name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(fileinfo.name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">getAllHaveFiles</span>(p.<span class="hljs-built_in">assign</span>(path).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-built_in">append</span>(fileinfo.name),InFile);<span class="hljs-comment">//递归当前文件夹</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">//文件处理</span><br>&#123;<br><span class="hljs-type">int</span> nameSize = <span class="hljs-built_in">strlen</span>(fileinfo.name);<br><br><span class="hljs-keyword">if</span> (nameSize &lt;= <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (fileinfo.name[nameSize - <span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;m&#x27;</span>&amp;&amp;fileinfo.name[nameSize - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;p&#x27;</span>)<br>&#123;<br>std::string outFile = p.<span class="hljs-built_in">assign</span>(path).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-built_in">append</span>(fileinfo.name);<br><span class="hljs-keyword">if</span> (fileinfo.name == InFile)<br>&#123;<br>std::cout &lt;&lt; InFile &lt;&lt; <span class="hljs-string">&quot; \t 已存在&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (_findnext(hFile, &amp;fileinfo) == <span class="hljs-number">0</span>); <span class="hljs-comment">//寻找下一个，成功返回0，否则-1</span><br>_findclose(hFile);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、通过Qt实现"><a href="#二、通过Qt实现" class="headerlink" title="二、通过Qt实现"></a>二、通过Qt实现</h2><figure class="highlight c++"><figcaption><span>qt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ui_mainwindow.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QDir&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QDebug&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QFileDialog&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QFile&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QTextStream&gt;</span></span><br><br>MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent)<br>    : <span class="hljs-built_in">QMainWindow</span>(parent)<br>    , <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<br>    _InPath = <span class="hljs-string">&quot;D:xxx1&quot;</span>;<span class="hljs-comment">//输入目录</span><br>    _OutPath = <span class="hljs-string">&quot;D:xxx2&quot;</span>;<span class="hljs-comment">//输出目录</span><br>    _MaxCount = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">SetMax</span>();<br>    _count = _MaxCount;<br>    <span class="hljs-built_in">CopyFile</span>();<br>&#125;<br><br>MainWindow::~<span class="hljs-built_in">MainWindow</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> ui;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::CopyFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;start copy!!!&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-comment">//目标</span><br>    QDir cfgPathDir2 = <span class="hljs-built_in">QDir</span>(_OutPath);<br>    <span class="hljs-keyword">if</span>(!cfgPathDir<span class="hljs-number">2.</span><span class="hljs-built_in">exists</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    QStringList filters2;<br>    filters2 &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;*.mp4&quot;</span>);<br>    <span class="hljs-comment">//cfgPathDir.setFilter(QDir::Files | QDir::NoSymLinks); //设置类型过滤器，只为文件格式</span><br>    cfgPathDir<span class="hljs-number">2.</span><span class="hljs-built_in">setNameFilters</span>(filters2);                   <span class="hljs-comment">//设置文件名称过滤器，只为filters格式</span><br>    <span class="hljs-type">int</span> dirCount2 = cfgPathDir<span class="hljs-number">2.</span><span class="hljs-built_in">count</span>();<br>    <span class="hljs-keyword">if</span>(dirCount2 &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dirCount2; i++)<br>    &#123;<br>        QString filName = cfgPathDir2[i];<br>        <span class="hljs-comment">//qDebug()&lt;&lt;filName;</span><br>        _ISCopyedName.<span class="hljs-built_in">push_back</span>(filName);<br>    &#125;<br><br>    <span class="hljs-comment">//源</span><br>    <span class="hljs-function">QDir <span class="hljs-title">indirectory</span><span class="hljs-params">(_InPath)</span></span>;<br>    indirectory.<span class="hljs-built_in">setFilter</span>(QDir::Dirs | QDir::NoDotAndDotDot);<br>    QFileInfoList list = indirectory.<span class="hljs-built_in">entryInfoList</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        QFileInfo fileInfo = list.<span class="hljs-built_in">at</span>(i);<br>        QString subDirectory = fileInfo.<span class="hljs-built_in">absoluteFilePath</span>();<br>        QDir currentDirectory = <span class="hljs-built_in">QDir</span>(subDirectory);<br>        QString currentDirectoryName = currentDirectory.<span class="hljs-built_in">dirName</span>();<br>        _AllFileName.<span class="hljs-built_in">push_back</span>(currentDirectoryName);<br>        <span class="hljs-comment">//复制</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">IsExt</span>(currentDirectoryName))<br>        &#123;<br>            QString Yuan = _InPath+<span class="hljs-string">&quot;/&quot;</span>+currentDirectoryName;<br>            QString Mu = _OutPath;<br>            QString Num = currentDirectoryName;<br>            <span class="hljs-built_in">Copy</span>(Yuan,Mu,currentDirectoryName);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MainWindow::Copy</span><span class="hljs-params">(QString Sou, QString Des,QString Num)</span></span><br><span class="hljs-function"></span>&#123;<br>    QString souFile;<br>    QString DesFile;<br>    QString OutName;<br>    <span class="hljs-comment">//组合源</span><br>    QDir cfgPathDir = <span class="hljs-built_in">QDir</span>(Sou);<br>    <span class="hljs-keyword">if</span>(!cfgPathDir.<span class="hljs-built_in">exists</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    QStringList filters;<br>    filters &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;*.mp4&quot;</span>);<br>    <span class="hljs-comment">//cfgPathDir.setFilter(QDir::Files | QDir::NoSymLinks); //设置类型过滤器，只为文件格式</span><br>    cfgPathDir.<span class="hljs-built_in">setNameFilters</span>(filters);                   <span class="hljs-comment">//设置文件名称过滤器，只为filters格式</span><br>    <span class="hljs-type">int</span> dirCount = cfgPathDir.<span class="hljs-built_in">count</span>();<br>    <span class="hljs-keyword">if</span>(dirCount &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;dirCount; i++)<br>    &#123;<br>        QString filName = cfgPathDir[i];<br>        <span class="hljs-comment">//qDebug() &lt;&lt; filName;</span><br>        souFile = Sou+<span class="hljs-string">&quot;/&quot;</span>+filName;<br>        OutName = filName;<br>    &#125;<br>    <span class="hljs-comment">//组合目</span><br>    QDir cfgPathDir2 = <span class="hljs-built_in">QDir</span>(Des);<br>    <span class="hljs-keyword">if</span>(!cfgPathDir<span class="hljs-number">2.</span><span class="hljs-built_in">exists</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    QStringList filters2;<br>    filters2 &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;*.mp4&quot;</span>);<br>    <span class="hljs-comment">//cfgPathDir.setFilter(QDir::Files | QDir::NoSymLinks); //设置类型过滤器，只为文件格式</span><br>    cfgPathDir<span class="hljs-number">2.</span><span class="hljs-built_in">setNameFilters</span>(filters2);                   <span class="hljs-comment">//设置文件名称过滤器，只为filters格式</span><br>    <span class="hljs-type">int</span> dirCount2 = cfgPathDir<span class="hljs-number">2.</span><span class="hljs-built_in">count</span>();<br>    <span class="hljs-keyword">if</span>(dirCount2 &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    _count++;<br>    <span class="hljs-built_in">UpdateMax</span>();<br>    DesFile = Des+<span class="hljs-string">&quot;/&quot;</span>+<span class="hljs-built_in">Num3</span>(_count)+<span class="hljs-string">&quot;_&quot;</span>+Num+<span class="hljs-string">&quot;_&quot;</span>+OutName;<br>    <span class="hljs-built_in">qDebug</span>()&lt;&lt;<span class="hljs-built_in">Num3</span>(_count)&lt;&lt;<span class="hljs-string">&quot;  Copying:   &quot;</span>&lt;&lt;OutName;<br><br>    <span class="hljs-keyword">if</span> (!QFile::<span class="hljs-built_in">copy</span>(souFile, DesFile))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MainWindow::IsExt</span><span class="hljs-params">(QString filename)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">//qDebug()&lt;&lt;_ISCopyedName.size();</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> file:_ISCopyedName)<br>    &#123;<br>        <span class="hljs-comment">//qDebug()&lt;&lt;filename;</span><br>        <span class="hljs-comment">//qDebug()&lt;&lt;file;</span><br><br>        <span class="hljs-keyword">if</span>(file.<span class="hljs-built_in">contains</span>(filename))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    _ISCopyedName.<span class="hljs-built_in">push_back</span>(filename);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::SetMax</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(_OutPath + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-string">&quot;maxRecord.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly  | QIODevice::Text))<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function">QTextStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br>    QString line = in.<span class="hljs-built_in">readAll</span>();<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Read from file:&quot;</span> &lt;&lt; line;<br>    _MaxCount = line.<span class="hljs-built_in">toInt</span>();<br>    file.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MainWindow::GetMax</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> _MaxCount;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::UpdateMax</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> Count = _count;<br><br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(_OutPath + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-string">&quot;maxRecord.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text))<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function">QTextStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;<br>    out &lt;&lt; QString::<span class="hljs-built_in">number</span>(Count);<br><br>    file.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function">QString <span class="hljs-title">MainWindow::Num3</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(number&gt;<span class="hljs-number">999</span>)<br>        <span class="hljs-keyword">return</span> QString::<span class="hljs-built_in">number</span>(number);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number&lt;<span class="hljs-number">999</span>&amp;&amp;number&gt;=<span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">return</span> QString::<span class="hljs-built_in">number</span>(number);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number&lt;<span class="hljs-number">99</span>&amp;&amp;number&gt;=<span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>+QString::<span class="hljs-built_in">number</span>(number);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number&gt;<span class="hljs-number">0</span>&amp;&amp;number&lt;=<span class="hljs-number">9</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00&quot;</span>+QString::<span class="hljs-built_in">number</span>(number);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++、fstream</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习C++、做做练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C11 新特性</title>
    <link href="/2022/04/30/C++11-characterastic/"/>
    <url>/2022/04/30/C++11-characterastic/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>C++11新特性</font></center><h4 id="所有STL容器支持初始化列表"><a href="#所有STL容器支持初始化列表" class="headerlink" title="所有STL容器支持初始化列表"></a>所有STL容器支持初始化列表</h4><p>例如： <code>std::vector&lt;int&gt; v = { 1, 2, 3 }</code></p><h4 id="自定义class支持初始化列表"><a href="#自定义class支持初始化列表" class="headerlink" title="自定义class支持初始化列表"></a>自定义class支持初始化列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> std::initializer_list&lt;<span class="hljs-type">int</span>&gt; &amp;items) : <span class="hljs-built_in">m_items</span>(items)&#123;<br>        <br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_items;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="forEach遍历方式"><a href="#forEach遍历方式" class="headerlink" title="forEach遍历方式"></a>forEach遍历方式</h4><p>对容器或者数组可以使用<code>forEach</code>遍历， <code>for(auto i: a){}</code></p><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4><p>传统 C++ 会把 <code>NULL</code>、<code>0 </code>视为同一种东西，这取决于编译器如何定义 <code>NULL</code>，有些编译器会将<code> NULL</code>定义为<code> ((void*)0)</code>，有些则会直接将其定义为 <code>0</code>，因此C++11 引入了<code> nullptr</code> 关键字，专门用来区分空指针与<code>0</code></p><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p><code>decltype</code>关键字是为解决<code>auto</code>关键字只能对变量进行类型推导的缺陷。用法与<code>sizeof</code>类似：<code>decltype(x + y) z;</code></p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p> 自动推导类型，<code> Map&lt;int, int&gt;::iterator itor = mmap.find();</code></p><ol><li><code>auto</code>声明的变量必须要初始化，否则编译器不能判断变量的类型。</li><li><code>auto</code>不能被声明为返回值，<code>auto</code>不能作为形参，<code>auto</code>不能被修饰为模板参数</li></ol><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p><code>lambda</code>表达式是匿名函数，可以认为是一个可执行体<code>functor</code>，语法：<code>[捕获区](参数区){代码区};</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl; <br></code></pre></td></tr></table></figure><h5 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h5><p>捕获即为将一些变量展开使得为<code>lambda</code>内部可见 </p><ul><li><p><code>[a,&amp;b]</code>其中 <code>a</code> 以复制捕获而 <code>b</code> 以引用捕获。</p></li><li><p><code>[this] </code>以引用捕获当前对象<code>(*this)</code></p></li><li><p><code>[&amp;] </code>以引用捕获所有用于 <code>lambda</code> 体内的自动变量，并以引用捕获当前对象，若存在</p><p> <code>auto f = [&amp;]() { std::cout &lt;&lt; i &lt;&lt; std::endl; }; </code></p></li><li><p><code>[=] </code>以复制捕获所有用于 <code>lambda</code> 体内的自动变量，并以引用捕获当前对象，若存在</p><p> <code>auto f = [=]() { std::cout &lt;&lt; i &lt;&lt; std::endl; }; </code></p></li><li><p><code>[]</code> 不捕获，大部分情况下不捕获就可以了</p></li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求： </p><ol><li>检查一个串是否包含某种形式的子串； </li><li>将匹配的子串替换；</li><li>从某个串中取出符合条件的子串。</li></ol><h4 id="统一的初始化方法"><a href="#统一的初始化方法" class="headerlink" title="统一的初始化方法"></a>统一的初始化方法</h4><p>可以统一使用大括号<code>{}</code>进行初始化。对构造函数的选择的优先级如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> std::initializer_list&lt;<span class="hljs-type">int</span>&gt; &amp;items) : <span class="hljs-built_in">m_items</span>(items)&#123;<br>    &#125;<br>    <br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> age) : <span class="hljs-built_in">age</span>(age) &#123;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_items;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a&#123;<span class="hljs-number">5</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认构造函数-default"><a href="#默认构造函数-default" class="headerlink" title="默认构造函数 default"></a>默认构造函数 <code>default</code></h4><p>有其他的构造函数的时候是不会有默认构造的，但是程序员希望有默认的时候可以写成是<code>A() = default; </code>当然 <code>A(){}</code>也是也可以的</p><h4 id="对枚举做了一个强类型枚举"><a href="#对枚举做了一个强类型枚举" class="headerlink" title="对枚举做了一个强类型枚举"></a>对枚举做了一个强类型枚举</h4><p>原来的枚举有两个缺点，因此引入了强类型枚举，使用的时候要加入 <code>Dir::Left</code></p><ol><li><p>不同的枚举类型但是名字起一样会编译报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Dir</span>&#123;<br>    left,Right<br>&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Pos</span>&#123;<br>    left,Right<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>不同的枚举类型可以判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(dir == pos)&#123;&#125;  <span class="hljs-comment">//dir和pos分类是两种枚举，但是这里可以判断，不合理</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="显式重写-override和final"><a href="#显式重写-override和final" class="headerlink" title="显式重写 override和final"></a>显式重写 <code>override</code>和<code>final</code></h4><ol><li>显示重写<code>override</code>：<code>void fun() override {}</code></li><li>显示重写<code>final</code>：<code>virtual void fun() final {}</code></li></ol><h4 id="delete关键字"><a href="#delete关键字" class="headerlink" title="delete关键字"></a><code>delete</code>关键字</h4><p><code>delete</code>关键字放在函数后面，表示函数不能被调用 。<code>A() = delete;</code></p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><ol><li><p><code>auto_ptr</code>（c++98的方案，cpp11已经抛弃）</p><p>采用所有权模式。<code>p2 = p1</code>，<code>p2</code>剥夺<code>p1</code>的所有权当程序运行时访问<code>p1</code>将会报错。因此其存在潜在的内存崩溃问题</p></li><li><p><code>unique_ptr</code>（替换<code>auto_ptr</code>）</p><p>实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。</p></li><li><p><code>shared_ptr</code></p><p>实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。它使用计数机制来表明资源被几个指针共享，使用<code>use_count()</code>来查看资源的所有者个数。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。当两个对象相互使用一个<code>shared_ptr</code>成员变量指向对方，会造成循环引用，使引用计数失效导致<strong>内存泄漏</strong>。使用<code>weak_ptr</code>解决</p></li><li><p><code>weak_ptr</code></p><p>是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象. 进行该对象的内存管理的是那个强引用的<code> shared_ptr</code>， <code>weak_ptr</code>只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助<code>shared_ptr</code> 工作, 它只可以从一个 <code>shared_ptr</code> 或另一个 <code>weak_ptr </code>对象构造, 它的构造和析构不会引起引用记数的增加或减少。<code>weak_ptr</code>是用来解决<code>shared_ptr</code>相互引用时的死锁问题,如果说两个<code>shared_ptr</code>相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和<code>shared_ptr</code>之间可以相互转化，<code>shared_ptr</code>可以直接赋值给它，它可以通过调用<code>lock函数</code>来获得<code>shared_ptr</code></p></li></ol><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p><code>std::pair&lt;std::string,int&gt;</code>的扩展版，可以当做一个通用的结构体来使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-type">char</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="语言级线程支持"><a href="#语言级线程支持" class="headerlink" title="语言级线程支持"></a>语言级线程支持</h4><p><a href="./c++parallel">链接</a></p><h4 id="右值引用-std-move-完美转发"><a href="#右值引用-std-move-完美转发" class="headerlink" title="右值引用&#x2F;std::move&#x2F;完美转发"></a>右值引用&#x2F;<code>std::move</code>&#x2F;完美转发</h4><p>C++中引入了右值引用和移动语义，可以避免无谓的复制，提高程序性能。</p><h5 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h5><p>C++中所有的值都必然属于左值、右值二者之一。</p><ol><li>左值是指表达式结束后依然存在的持久化对象，所有的具名变量或者对象都是左值，而右值不具名</li><li>右值是指表达式结束时就不再存在的临时对象</li></ol><p>简单区分方法：<strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong></p><h5 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h5><p>C++98中引用就是给变量取了个别名，C++11中，因为增加了<strong>右值引用</strong>的概念符号是<code>&amp;&amp;</code>，所以C++98中的引用都称为了<strong>左值引用</strong>。</p><ol><li>左值引用， 使用 <code>T&amp;</code>, 只能绑定<strong>左值</strong>，给变量取别名</li><li>右值引用， 使用 <code>T&amp;&amp;</code>， 只能绑定<strong>右值</strong>，可以取得临时对象的控制权，终于可以修改临时对象了！</li><li>常量左值， 使用 <code>const T&amp;</code>, 既可以绑定<strong>左值</strong>又可以绑定<strong>右值</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; refA = a; <span class="hljs-comment">// 左值引用</span><br><span class="hljs-type">int</span>&amp; refB = <span class="hljs-number">10</span>; <span class="hljs-comment">//编译错误，10是右值，不能够使用左值引用</span><br><span class="hljs-type">int</span>&amp;&amp; refC = <span class="hljs-number">10</span>; <span class="hljs-comment">// 右值引用</span><br><span class="hljs-type">int</span>&amp;&amp; refD = <span class="hljs-built_in">getTemp</span>(); <span class="hljs-comment">//getTemp返回一个临时变量是右值 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; refF = <span class="hljs-built_in">getTemp</span>(); <br></code></pre></td></tr></table></figure><h5 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h5><p><strong>目的</strong>：对于临时对象拷贝完就没什么用，造成了没有意义的资源申请和释放操作，如果能够直接使用临时对象已经申请的资源，既能节省资源，又能节省资源申请和释放的时间。而C++11新增加的<strong>移动语义</strong>就能够做到这一点。</p><img src="../images/image-20200820095014878.png"/><p><strong>原理</strong>：并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为<code>nullptr</code>，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源。C++11为了解决这个问题，提供了<code>std::move()</code>方法来将左值转换为右值，从而方便应用移动语义</p><p><strong>注意</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">MyString <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>; <span class="hljs-comment">//调用构造函数</span><br><span class="hljs-function">MyString <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>)</span></span>; <span class="hljs-comment">//调用构造函数</span><br><span class="hljs-function">MyString <span class="hljs-title">str3</span><span class="hljs-params">(str1)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span><br><span class="hljs-function">MyString <span class="hljs-title">str4</span><span class="hljs-params">(std::move(str1))</span></span>; <span class="hljs-comment">// 调用移动构造函数、</span><br><span class="hljs-comment">//    cout &lt;&lt; str1.get_c_str() &lt;&lt; endl; // 此时str1的内部指针已经失效了！不要使用</span><br><span class="hljs-comment">//注意：虽然str1中的m_dat已经称为了空，但是str1这个对象还活着，知道出了它的作用域才会析构！而不是move完了立刻析构</span><br>MyString str5;<br>str5 = str2; <span class="hljs-comment">//调用拷贝赋值函数</span><br>MyString str6;<br>str6 = std::<span class="hljs-built_in">move</span>(str2); <span class="hljs-comment">// str2的内容也失效了，不要再使用</span><br></code></pre></td></tr></table></figure><ol><li><code>str6 = std::move(str2)</code>，虽然将<code>str2</code>的资源给了<code>str6</code>，但是<code>str2</code>并没有立刻析构，只有在<code>str2</code>离开了自己的作用域的时候才会析构，所以，如果继续使用<code>str2</code>的<code>m_data</code>变量，可能会发生意想不到的错误。</li><li>如果我们没有提供移动构造函数，只提供了拷贝构造函数，<code>std::move()</code>会失效但是不会发生错误，因为编译器找不到移动构造函数就去寻找拷贝构造函数，也这是拷贝构造函数的参数是<code>const T&amp;</code>常量左值引用的原因！</li><li><code>c++11</code>中的所有容器都实现了<code>move</code>语义，<code>move</code>只是转移了资源的控制权，本质上是将左值强制转化为右值使用，以用于移动拷贝或赋值，避免对<strong>含有资源的对象</strong>发生无谓的拷贝。<code>move</code>对于拥有如内存、文件句柄等资源的成员的对象有效，如果是一些基本类型，如int和char[10]数组等，如果使用move，仍会发生拷贝（因为没有对应的移动构造函数），所以说<code>move</code>对含有资源的对象说更有意义。</li></ol><h5 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h5><p>右值引用和模板结合的时候。<code>T&amp;&amp;</code>并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。是左值引用还是右值引用却决于它的初始化，如果它被一个左值初始化，它就是一个左值引用；如果被一个右值初始化，它就是一个右值引用。一句话， 传递左值进去，就是左值引用，传递右值进去，就是右值引用。如它的名字，这种类型确实很”通用”</p><p><strong>注意：<strong>只有当</strong>发生自动类型推断</strong>时（如函数模板的类型自动推导，或auto关键字），<code>&amp;&amp;</code>才是一个<code>universal references</code>。</p><h5 id="引用折叠的规则"><a href="#引用折叠的规则" class="headerlink" title="引用折叠的规则"></a>引用折叠的规则</h5><ol><li>所有的右值引用叠加到右值引用上仍然使一个右值引用。</li><li>所有的其他引用类型之间的叠加都将变成左值引用。</li></ol><h5 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h5><p>所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的，c++中提供了一个<code>std::forward()</code>模板函数解决这个问题</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ base</title>
    <link href="/2022/04/30/C++base/"/>
    <url>/2022/04/30/C++base/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>C++基础</font></center><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="变量声明和定义"><a href="#变量声明和定义" class="headerlink" title="变量声明和定义"></a>变量声明和定义</h4><ul><li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间</li><li>相同变量可以再多处声明（外部变量<code>extern</code>），但只能在一处定义。例如：<code>extern int val;</code></li></ul><h4 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h4><p>放在赋值操作符左边为<strong>左值</strong>，可以放到赋值操作符右边为<strong>右值</strong>，当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份(在内存中的位置）</p><ol><li>有些变量即可以当左值，也可以当右值。</li><li>左值为Lvalue，L代表Location，表示内存可以寻址，可以赋值。</li><li>右值为Rvalue，R代表Read，就是可以知道它的值，比如<code>int temp = 10</code>; <code>temp</code>在内存中有地址，10没有，但是可以Read到它的值。</li></ol><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><ol><li><p><code>::</code> <strong>作用域运算符</strong></p><ul><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间. <code>::a使用全局变量a</code></li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul></li><li><p><strong>命名空间</strong></p><p>C++引入关键字<code>namespace</code>（命名空间&#x2F;名字空间&#x2F;名称空间），可以有效解决软件开发中<strong>命名冲突</strong>的工程问题。</p><ul><li>命名空间可以嵌套命名空间</li><li>声明和实现可以分开</li><li>命名空间别名：<code>namespace shortname =  veryLongName;</code></li><li>无名命名空间，即<code>namespace{}</code>，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static。</li></ul></li><li><p><code>using</code><strong>声明</strong> </p><p>使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了，使用方式如下：</p><ol><li><p><code>using</code> 声明语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。<code>using namespace_name::name;</code></p></li><li><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::Base;<br>    <span class="hljs-comment">/* ... */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h4><p>Run-Time Type Identification,<strong>运行时类型检查</strong>，在C++层面主要体现在<code>dynamic_cast</code>和<code>typeid</code>，虚函数表的-1位置存放了指向<code>type_info</code>的指针。对于存在虚函数的类型，<code>typeid</code>和<code>dynamic_cast</code>都会去查询<code>type_info</code></p><ol><li><p><strong>dynamic_cast</strong></p><p>用于多态类型的转换，目标类型和源对象有<strong>继承关系</strong>。 更准确的说用来检查两者是否有继承关系。语法：<code>dynamic_cast &lt;新类型&gt; (表达式)</code></p></li><li><p><strong>typeid</strong></p><ul><li><p><code>typeid </code><strong>运算符</strong>允许在运行时确定对象的类型， 返回一个<code>type_info</code> 对象的引用</p></li><li><p>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</p></li><li><p>只能获取对象的实际类型</p></li></ul></li><li><p><strong>type_info</strong></p><p>类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。<code> type_info</code> 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。头文件：<code>&lt;typeinfo&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>type_info &amp;info = <span class="hljs-built_in">typeid</span>(a); <br>    std::cout &lt;&lt; info.<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; info.<span class="hljs-built_in">raw_name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; info.<span class="hljs-built_in">hash_code</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="静态连接与动态链接"><a href="#静态连接与动态链接" class="headerlink" title="静态连接与动态链接"></a>静态连接与动态链接</h4><ol><li><strong>静态链接</strong>：所谓静态链接就是<strong>在编译链接时直接将需要的执行代码拷贝到调用处</strong>，优点就是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。</li><li><strong>动态链接</strong>：所谓动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系 统，<strong>操作系统负责将需要的动态库加载到内存中</strong>，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。</li></ol><h4 id="大端模式和小端模式的区别"><a href="#大端模式和小端模式的区别" class="headerlink" title="大端模式和小端模式的区别"></a>大端模式和小端模式的区别</h4><p>在C语言中除了8位的char型之外，还有16位的short型，32位的long型（要看具体的编译器），对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p><p>大端模式：</p><p>字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。</p><p>小端模式：</p><p>与大端存储模式相反，在小端存储模式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。</p><p>例如，16位宽的数0x1234在小端模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p><table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th></tr></thead><tbody><tr><td>存放内容</td><td>0x34</td><td>0x12</td></tr></tbody></table><p>而在大端模式CPU内存中的存放方式则为：</p><table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th></tr></thead><tbody><tr><td>存放内容</td><td>0x12</td><td>0x34</td></tr></tbody></table><h4 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h4><ol><li>函数指针的重点是指针。表示的是一个指针，它指向的是一个函数，例如：<code>int  (*pf)();</code></li><li>指针函数的点是函数。表示的是一个函数，它的返回值是指针。例如：<code>int*  fun();  </code></li></ol><h4 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h4><ol><li>指针数组的重点是数组。表示的是一个数组，它包含的元素是指针。例如：<code>int *ap[8];  </code></li><li>数组指针的重点是指针。表示的是一个指针，它指向的是一个数组，例如：<code>int  (*pa)[8];  </code></li></ol><h4 id="类模板与模板类"><a href="#类模板与模板类" class="headerlink" title="类模板与模板类"></a>类模板与模板类</h4><ol><li>类模板的重点是模板。表示的是一个模板，专门用于产生类的模子。例如：<code>vector，list</code></li><li>模板类的重点是类。表示的是由一个模板生成而来的类。例如：<code>vector&lt;int&gt;，vector&lt;char&gt;</code>，相当类与实例</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="基本内置数据类型"><a href="#基本内置数据类型" class="headerlink" title="基本内置数据类型"></a>基本内置数据类型</h4><p><code>1 字节 = 1 byte = 8bit, Byte通常写为大B, Bit通常写为小b</code></p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>其它</th></tr></thead><tbody><tr><td><code>char</code></td><td>1 字节</td><td>-128 到 127 或者 0 到 255</td></tr><tr><td><code>short</code></td><td>2 字节</td><td></td></tr><tr><td><code>int</code></td><td>4 字节</td><td>-2147483648 到 2147483647</td></tr><tr><td><code>long</code></td><td>4 字节 &#x2F; 8 字节</td><td>32位系统为占用4字节， 64位系统占用为8字节</td></tr><tr><td><code>float</code></td><td>4 字节</td><td>声明和定义：<code>float f = 0.1f</code><br><strong>浮点型存在精度问题的</strong><a href="https://www.cnblogs.com/SugarLSG/p/3534248.html">链接</a>， 在比较大小的时候，不能像int整数型那样，直接<code>if(a==b)</code></td></tr><tr><td><code>double</code></td><td>8 字节</td><td></td></tr><tr><td><code>void*</code>（任意类型指针）</td><td>4 字节 &#x2F; 8字节</td><td></td></tr><tr><td><code>bool</code></td><td>1 字节</td><td>只有两个值<code>true</code>(1值)&#x2F;<code>false</code>(0值)，给<code>bool</code>类型赋值时，会自动转换为<code>true</code>(1) &#x2F; <code>false</code>(0)</td></tr></tbody></table><p><strong>一些基本类型可以使用一个或多个类型修饰符进行修饰</strong>：</p><ul><li><code>signed</code></li><li><code>unsigned</code></li><li><code>short</code></li><li><code>long</code> : <code>long int</code>4字节 &#x2F; 8字节； <code>long long </code> 8 字节；<code>long long int</code> 8 字节</li></ul><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p>常见的自定义类型（即复合类型）有：</p><ol><li>结构体：<code>struct</code>，是由一批数据组合而成的一种新的数据类型。</li><li>共用体：<code>union</code>，有多个数据成员，但是在<strong>任意时刻只有一个数据成员可以有值</strong></li><li>枚举：<code>enum</code>，将变量的值一一列举出来</li></ol><p><strong>其它</strong>：使用关键字 <code>typedef</code> 可以定义一个新名字，但不能创建新类型</p><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><p>隐式转换指的是不需要用户干预，编译器私下进行的类型转换行为。</p><ol><li><p>对于<strong>内置类型</strong>，<strong>低精度的变量给高精度变量赋值</strong>会发生隐式类型转换，例如：<code>double a = int b;</code>，特别地使用<code>+=, -=</code>也会进行类型转换</p></li><li><p>对于只存在<strong>单个参数的构造函数的对象构造来说</strong>，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(A a)</span></span>&#123;<br>    cout &lt;&lt; a.a &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h5><p>多用于指针和引用的转换，语法：<code>xxxx_cast&lt;new_type&gt;(expression)</code></p><ol><li><p><code>const_cast</code>：用于将<code>const</code>变量转为非<code>const</code></p></li><li><p><code>static_cast </code>：用于各种隐式转换，比如非<code>const</code>转<code>const</code>，<code>void*</code>转指针等, <code>static_cast</code>能用于多态向上转化，如果向下转能成功但是不安全，结果未知</p><ul><li>向上转换：指的是子类向基类的转换</li><li>向下转换：指的是基类向子类的转换</li></ul></li><li><p><code>dynamic_cast</code>：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化，更准确的说用来检查两者是否有继承关系。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A derived B    -------    A -&gt; B</span><br>B *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>A *a = <span class="hljs-built_in">dynamic_cast</span>&lt;A *&gt;(b);<br></code></pre></td></tr></table></figure></li><li><p><code>reinterpret_cast</code>：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用</p></li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>关键字</strong>是C++中预先保留的单词（标识符）</p><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><h4 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h4><p><code>sizeof(object/type_name)</code>其作用是返回一个对象或类型所占的内存字节数。其是<strong>操作符不是函数</strong></p><ol><li><p>结构体<code>sizeof</code>：涉及到字节对齐问题。</p><p><code>#pragma pack(n)</code> 设定结构体、联合以及类成员变量以 n 字节方式对齐</p><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（即若有double成员，按8字节对齐）。</li></ul></li><li><p>数组<code>sizeof</code>值：等于数组所占用的内存字节数</p></li><li><p>指针<code>sizeof</code>：指针是用来记录另一个对象的地址，所以指针的内存大小等于计算机内部地址总线的宽度。在32位系统中指针变量的返回值必定是4字节</p></li><li><p><code>strlen</code>和<code>sizeof</code>区别：</p><ul><li><code>sizeof</code>是运算符，<code>strlen</code>是字符串操作的库函数 </li><li><code>sizeof</code>得到的是内存空间占用的大小，<code>strlen</code>得到是字符串的长度</li></ul></li></ol><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ol><li>修饰变量，修饰变量常量，该值不可以改变，语法：<code>const  数据类型 常量名 = 常量值</code></li><li>修饰指针存在三种情况<ol><li>常量指针：修饰指针 <code>const int *p = &amp;a</code>，此时指针指向可以改变，值不可以变，修饰的为<code>int *</code></li><li>指针常量：修饰常量<code>int * const p = &amp;a</code> ，此时指针指向不可以变，值可以改变 ，修饰的为<code>p</code></li><li>既修饰常量，又修饰指针<code>const int * const p = &amp;a</code>，此时都不可改变</li></ol></li><li><code>const</code>修饰成员函数，<strong>表明函数调用不会对对象做出任何更改</strong>，事实上，如果确认不会更改对象，就应该为函数加上<code>const</code>限定，无论<code>const</code>对象还是普通对象都可以调用该函数。</li></ol><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ol><li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给<code>this</code>指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName* const this</code>，这意味着不能给 this 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 this 指针：<ul><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如<code>list</code></li></ul></li></ol><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ol><li><strong>修饰普通变量</strong>，分为全局和局部，修改变量的存储区域和生命周期，使变量存储在静态区，在 <code>main 函数</code>运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li><strong>修饰普通函数</strong>，表明函数的作用范围，仅在定义该函数的文件内才能使用。防止与他人命名空间里的函数重名，可以将函数定位为 <code>static</code>。</li><li><strong>修饰成员变量</strong>，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li><strong>修饰成员函数</strong>，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 <code>static 函数</code>内不能访问非静态成员。</li></ol><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><ol><li>相当于把内联函数里面的内在调用内联函数处展开；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>一般不推荐包含循环、递归、<code>switch</code> 等复杂操作的内联函数；</li><li>在类声明中定义的函数，<strong>除了虚函数的其他函数都会自动隐式地当成内联函数。</strong></li></ol><h4 id="virtual与inline"><a href="#virtual与inline" class="headerlink" title="virtual与inline"></a>virtual与inline</h4><ol><li><p>虚函数可以是内联函数，内联是可以修饰虚函数的，<code>inline virtual</code></p></li><li><p><strong>虚函数表现多态性时不能内联</strong></p><p>内联是在编译期进行编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p></li></ol><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ol><li><code>volatile</code>定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。</li><li>多线程中被几个任务共享的变量需要定义为<code>volatile</code>类型。</li></ol><h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol><li><code>new</code>：在堆区开辟空间，返回地址<strong>即该数据对应的类型的指针</strong>，<code>delete</code>：释放空间</li><li>若使用<code>new[]</code>开辟空间，则对应需要<code>delete[]</code>释放空间</li><li>与<code>malloc</code>和<code>free</code>的区别<ul><li><code>malloc</code>和<code>free</code>是标准库函数，支持覆盖；<code>new</code>和<code>delete</code>是运算符，并且支持重载。</li><li><code>malloc</code>仅仅分配内存空间，<code>free</code>仅仅回收空间，不具备调用构造函数和析构函数功能，用<code>malloc</code>分配空间存储类的对象存在风险；<code>new</code>和<code>delete</code>除了分配回收功能外，还会调用构造函数和析构函数。</li><li><code>malloc</code>和<code>free</code>返回的是<code>void</code>类型指针（必须进行类型转换），<code>new</code>和<code>delete</code>返回的是具体类型指针。</li></ul></li><li>为什么C++没有实现垃圾回收，需要手动释放</li></ol><ul><li>实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。垃圾回收会使得C++不适合进行很多底层的操作</li></ul><h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>可以用<code> typedef</code> 为一个<strong>已有的类型</strong>取一个新的名字，不能创建新类型，发生于编译阶段。语法：<code>typedef type newname; </code></p><h4 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h4><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><h5 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h5><p><strong>由于c++中需要支持函数重载</strong>，所以c和c++中对同一个函数经过编译后生成的函数名是不相同的，这就导致了一个问题，如果在c++中调用一个使用c语言编写模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">c函数: <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span>()</span>&#123;&#125;， 被编译成函数: MyFunc<br>c++函数: <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span>()</span>&#123;&#125;， 被编译成函数: _Z6Myfuncv<br></code></pre></td></tr></table></figure><h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>用于修改函数<code> [extern] 函数类型 函数名(函数参数表)</code>，表示此函数是外部函数，可以被其他文件中的函数调用。一般情况下<code>extern</code>省略，即没<code>static</code>修饰都是外部函数</p><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><ol><li><p>即显式关键字，<strong>禁止通过构造函数进行的隐式转换</strong></p></li><li><p>声明为<code>explicit</code>的构造函数不能在隐式转换中使用，是<strong>针对单参数的构造函数</strong>(或者除了第一个参数外其余参数都有默认值的多参构造)而言。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> : a(a) &#123;</span>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(A a)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">function</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>语法：<code>decltype ( expression )</code>，<code>decltype </code>关键字用于检查实体的声明类型或表达式的类型及值分类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">decltype</span>(a) b = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导，类似的关键字还有<code>decltype</code>。</p><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h4><p>断言，是宏，而非函数。<code>assert</code> 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 <code>assert</code>，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p>该函数不会发生异常，<code>void function() noexcept { } </code></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>更加详细的内容请参考<a href="https://blog.csdn.net/qq_28114615/article/details/86434837">链接</a></p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>定义 <code>数据类型 数组名[] = {值1, 2}</code></p><p>在一维数组中，数组A的元素<code>A[i]</code>的地址<code>&amp;A[i]=A+L*i</code>,其中<code>A</code>为数组的标识符（数组名），也可用<code>A</code>来代表数组的首地址，<code>L</code>为数组<code>A</code>的数据类型，由此可见，对于一维数组，只需要知道数据类型大小和索引<code>i</code>，就可以知道<code>A[i]</code>的地址，从而访问<code>A[i]</code></p><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>定义 <code>数据类型 数组名[][列数] = {值1, 2, 3, 4}</code></p><p>二维数组，<strong>实际上也是一维数组</strong>，只不过这个一维数组的每个元素都是一个一维数组。因此，将二维数组的每一行看做一个元素（行指针），很容易可以知道<strong>二维数组中各元素在内存中是按行优先进行连续存储的</strong></p><p><img src="/../images/20190113211649482.png" alt="20190113211649482"></p><p>由此也可得到二维数组中元素<code>A[i][j]</code>的地址为<code>&amp;A[i][j]=A+L*（C*i+j)</code>，其中<code>A</code>为二维数组<code>A</code>的标识符（数组名），也就是数组的首地址，<code>L</code>为数组元素的数据类型，<code>C</code>为二维数组的列数。由此可见，要知道二维数组中某一元素的地址，<strong>必须知道数据类型大小以及二维数组的列数</strong></p><h4 id="利用指针访问数组"><a href="#利用指针访问数组" class="headerlink" title="利用指针访问数组"></a>利用指针访问数组</h4><h5 id="数组地址"><a href="#数组地址" class="headerlink" title="数组地址"></a>数组地址</h5><ol><li><code>A</code>是数组第一个<strong>元素的首地址</strong>，<code>&amp;A</code>是数组的地址，虽然二者值是一样，但含义不同</li><li><code>A+1</code>实际是加上<code>sizeof(元素类型)</code>访问下一个元素，而<code>&amp;A+1</code>则加上<code>sizeof(数组)</code></li><li>二维数组则<code>A</code>表示数组地址，<code>A[0]</code>则表示第一行，<code>A+i</code>就是第<code>i</code>行<code>A[i]</code>的行首地址了</li></ol><p>明白上述基础后，由于指针就是地址，后续指针访问数组也较好理解。</p><h5 id="通过指针访问一维数组"><a href="#通过指针访问一维数组" class="headerlink" title="通过指针访问一维数组"></a>通过指针访问一维数组</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> *p = a;<br></code></pre></td></tr></table></figure><h5 id="通过指针访问二维数组"><a href="#通过指针访问二维数组" class="headerlink" title="通过指针访问二维数组"></a>通过指针访问二维数组</h5><ol><li><p><strong>指向元素的指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<br><span class="hljs-type">int</span> *p = &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>二维数组是按行优先存储的, 对于数组元素的访问可类似于一维数组，所以可以通过访问，即<code>a[i][j]=*(p+i*c+j)</code>,<code>c</code>为二维数组的列数</p></li><li><p><strong>指向行指针</strong></p><p>数组实际上都是一维的，<code>a</code>一定是数组第一个元素的地址，将<code>a</code>看做一维数组后它的每一个元素实际上是每一行，因此如果让指针变量<code>p</code>指向<code>a</code>，就相当于让p指向第0行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<br><span class="hljs-type">int</span> *p[i] = a[i]; <span class="hljs-comment">//随意写，每一行都有一个指针</span><br></code></pre></td></tr></table></figure><p>因此，对于有<code>r</code>行的二维数组，就需要定义<code>r</code>个指针指向每一行，这样其实就可以定义一个装有<code>r</code>个指针的数组，其中每一个指针分别指向二维数组的每一行, 因此<code>p[i]</code>即指向数组的第i行，即<code>a[i][j]=*(p[i]+j)</code></p><p>这里<code>p</code>是以指针作为元素的数组，也就是<strong>指针数组</strong>。</p></li><li><p><strong>指向数组指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">4</span>] = a;<br></code></pre></td></tr></table></figure><p>这里<code>p</code>的含义也就不难得出了：<strong>指向一个有四个元素的数组的首地址</strong>。可以理解为<code>(*p)[4] 和 a[4]</code>,<code>a[i][j]</code>的地址就是<code>(p+i)+j，a[i][j]=*(*(p+i)+j)</code></p></li></ol><h4 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h4><ol><li><p><strong>指针数组</strong>：首先它是一个数组**，数组的元素都是指针**，它是“储存指针的数组”的简称。</p></li><li><p><strong>数组指针</strong>，<strong>首先它是一个指针</strong>，它指向一个数组。</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>同一个作用域下，<strong>函数名可以相同</strong>，函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>，返回值不可以作为函数重载的条件</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，例如：当碰到<code>void func(int x)</code>,编译器可能将函数名修饰为<code>_func_int</code></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li><p><strong>引用</strong>可作为重载条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数重载碰到函数<strong>默认参数</strong>，可能会产生歧义需要避免</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">(string a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">(string a, <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-built_in">MyFunc</span>(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">//同时匹配以上两个函数，产生二义性</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ol><li>在C语言中，<code>int fun() </code>表示返回值为<code>int</code>，接受任意参数的函数，<code>int fun(void)</code> 表示返回值为int的无参函数。</li><li>在C++ 中，<code>int fun() </code>和<code>int fun(void)</code> 具有相同的意义，都表示返回值为<code>int</code>的无参函数。</li><li>函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数</li><li>在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明<code>int fun(int a, int)</code>。一般情况下，在函数体内部无法使用占位参数。</li></ol><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ol><li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>**函数指针是指向函数的指针变量。**函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</p></li><li><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>调用函数和做函数的参数，比如回调函数。</p></li><li><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> * p)</span> </span>&#123;…&#125;    <span class="hljs-comment">// 函数fun</span><br><span class="hljs-type">char</span>* (*pf)(<span class="hljs-type">char</span> * p);     <span class="hljs-comment">// 函数指针pf</span><br>pf = fun;            <span class="hljs-comment">// 函数指针pf指向函数fun</span><br><span class="hljs-built_in">pf</span>(p);              <span class="hljs-comment">// 通过函数指针pf调用函数fun</span><br></code></pre></td></tr></table></figure></li><li><p><strong>指针函数与函数指针</strong></p><ul><li><strong>指针函数</strong>：其实是返回值为指针的函数，例如<code>char *fun()</code></li><li><strong>函数指针</strong>：每个函数都有一个入口地址，将该入口地址赋值给一个指针，通过该指针即可以调用这个函数 <code>char (*fp)(int x)</code></li></ul></li></ol><h4 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h4><ol><li><p><code>strcpy</code>：将字符串<code>str2</code>复制到字符串<code>str1</code>中，并覆盖<code>str1</code>原始字符串，可以用来为字符串变量赋值</p></li><li><p><code>strlen</code>：计算字符串<code>str1</code>的长度</p></li><li><p><code>strcat</code>：将字符串<code>str2</code>添加到字符串<code>str1</code>的尾部，也就是拼接两个字符串</p></li><li><p><code>strcmp</code>：比较两个字符串，如果两个字符串相等，则返回0</p></li><li><p><code>strchr</code>：在<code>str</code>字符串中查找首次出现字符<code>c</code>的位置（从字符串的首地址开始查找）</p></li><li><p>常出现如何实现上述函数的实现代码？</p><p>…</p></li></ol><h4 id="其它函数-C的进程管理"><a href="#其它函数-C的进程管理" class="headerlink" title="其它函数(C的进程管理)"></a>其它函数(C的进程管理)</h4><ol><li><p><code>fork</code></p><p>创建一个和当前进程映像一样的进程可以通过<code>fork()</code>系统调用，由<code>fork</code>创建的新进程被称为子进程。<code>fork</code>函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。</p></li><li><p><code>wait</code></p><p>等待进程，调用了<code>wait</code>的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。</p></li><li><p><code>exec</code></p><p>在用<code>fork</code>函数创建子进程后，子进程往往要调用一个<code>exec</code>函数以执行另一个程序，根据指定的文件名找到可执行文件，并用它来取代调用进程的内容。<code>exec</code>执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p></li></ol><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>指针的作用：</strong> 简单的说指针就是地址，可以通过指针间接访问内存，</p><p>**野指针：**就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p><strong>头文件</strong>：<code>#include &lt;memory&gt;</code>，智能指针的作用是管理一个指针，<strong>可以避免申请的空间在函数结束时忘记释放</strong>，造成内存泄漏。</p><p>C++里面的四个智能指针: <code>auto_ptr, shared_ptr, weak_ptr, unique_ptr</code>其中<strong>后三个是c++11支持</strong>，而<strong>第一个已经被C++11弃用</strong></p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><strong>智能指针就是一个类</strong>，<strong>当超出了类的作用域类会自动调用析构函数</strong>，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，<strong>不需要手动释放内存空间</strong>。智能指针：它的一种通用实现方法是采用引用计数的方法。智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPointer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* _ptr;<br>    <span class="hljs-type">size_t</span>* _count;<br><span class="hljs-keyword">public</span>:<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ol><li><p><code>auto_ptr</code>（c++98的方案，cpp11已经抛弃）</p><p>采用所有权模式。<code>p2 = p1</code>，<code>p2</code>剥夺<code>p1</code>的所有权当程序运行时访问<code>p1</code>将会报错。因此其存在潜在的内存崩溃问题</p></li><li><p><code>unique_ptr</code>（替换<code>auto_ptr</code>）</p><p>实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。</p></li><li><p><code>shared_ptr</code></p><p>实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。它使用计数机制来表明资源被几个指针共享，使用<code>use_count()</code>来查看资源的所有者个数。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。当两个对象相互使用一个<code>shared_ptr</code>成员变量指向对方，会造成循环引用，使引用计数失效导致<strong>内存泄漏</strong>。使用<code>weak_ptr</code>解决</p></li><li><p><code>weak_ptr</code></p><p>是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象. 进行该对象的内存管理的是那个强引用的<code> shared_ptr</code>， <code>weak_ptr</code>只是提供了对管理对象的一个访问手段。<code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助<code>shared_ptr</code> 工作, 它只可以从一个 <code>shared_ptr</code> 或另一个 <code>weak_ptr </code>对象构造, 它的构造和析构不会引起引用记数的增加或减少。<code>weak_ptr</code>是用来解决<code>shared_ptr</code>相互引用时的死锁问题,如果说两个<code>shared_ptr</code>相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和<code>shared_ptr</code>之间可以相互转化，<code>shared_ptr</code>可以直接赋值给它，它可以通过调用<code>lock函数</code>来获得<code>shared_ptr</code></p></li></ol><h4 id="易混概念"><a href="#易混概念" class="headerlink" title="易混概念"></a>易混概念</h4><ol><li><code>int *p[10]</code>表示<strong>指针数组</strong>，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向<code>int</code>类型的指针变量</li><li><code>int (*p)[10]</code>表示<strong>数组指针</strong>，强调是指针，只有一个变量，是指针类型，不过指向的是一个<code>int</code>类型的数组，这个数组大小是10</li><li><code>int *p(int)</code>是<strong>函数声明</strong>，函数名是<code>p</code>，参数是<code>int</code>类型的，返回值是<code>int </code>类型的。</li><li><code>int (*p)(int)</code>是<strong>函数指针</strong>，强调是指针，该指针指向的函数具有<code>int</code>类型参数，并且返回值是<code>int</code>类型的</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>实质</strong>上是一段连续内存空间的别名，<strong>语法：</strong><code>数据类型 &amp;别名 = 原名</code></p><p><strong>引用的本质</strong>：就是在c++内部实现是一个指针常量<code>Type * const p = &amp;a</code></p><ol><li>必须在声明引用变量时进行初始化，初始化后值不可以改变（我理解为<code>p</code>始终指向<code>a</code>的地址）</li><li>引用做函数参数</li><li>引用做函数返回值，不可返回局部变量引用</li></ol><h5 id="左值与右值-1"><a href="#左值与右值-1" class="headerlink" title="左值与右值"></a>左值与右值</h5><ol><li>左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象</li><li>当一个对象被用作右值的时候，用的是对象的值<code>int temp = 10</code>；当对象被用作左值的时候，用的是对象的身份(在内存中的位置）</li><li>需要右值的地方可以用左值代替，但不能把右值当成左值使用。</li></ol><h5 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h5><p>左值引用就是我们平常使用的引用。引用是为对象起的别名，必须被初始化，与变量空间绑定到一起且将一直绑定在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;j = i; <span class="hljs-comment">//j将一直接指向i的内存空间</span><br></code></pre></td></tr></table></figure><h5 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h5><p>透彻讲解右值引用、移动语义、完美转发链接：<a href="https://www.jianshu.com/p/d19fc8447eaa">https://www.jianshu.com/p/d19fc8447eaa</a></p><p>右值引用<a href="./c++11-characterastic">详情</a>就是必须绑定到右值（<strong>一个临时对象、将要销毁的对象</strong>）的引用，一般表示对象的值。右值引用的符号一般为<code>&amp;&amp;</code></p><ol><li><strong>左值引用、右值引用和通用引用</strong>。左值引用只能绑定左值，右值引用只能绑定右值，通用引用由初始化时绑定的值的类型确定。</li><li>左值和右值是独立于他们的类型的，右值引用可能是左值可能是右值，如果这个右值引用已经被命名了，他就是左值。</li><li><strong>引用折叠规则</strong>：所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用。当<code>T&amp;&amp;</code>为模板参数时，输入左值，它将变成左值引用，输入右值则变成具名的右值应用。</li><li><strong>移动语义</strong>可以减少无谓的内存拷贝，要想实现移动语义，需要实现移动构造函数和移动赋值函数。<code>std::move()</code>将一个左值转换成一个右值，强制使用移动拷贝和赋值函数，这个函数本身并没有对这个左值什么特殊操作。</li><li><strong>完美转发</strong>。将类型传递给模板参数时，保留所有实参类型的细节（如<code>const</code>，具名右值引用，无名右值引用、左值引用），主要通过<code>std::forward()</code>和<code>universal references</code>通用引用共同实现</li></ol><h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><ul><li>常引用可以理解为常量指针，形式为<code>const typename &amp; refname = varname</code></li><li>常引用下，原变量值不会被别名所修改，原变量的值可以通过原名修改</li><li>常引用通常用作只读变量别名或是形参传递</li></ul><h5 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h5><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><h5 id="指针与引用的区别"><a href="#指针与引用的区别" class="headerlink" title="指针与引用的区别"></a>指针与引用的区别</h5><ol><li>指针有自己的一块空间，而引用只是一个别名；</li><li>使用<code>sizeof</code>看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>指针可以被初始化为<code>NULL</code>，而引用必须被初始化且必须是一个已有对象的引用；</li><li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li><li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</li><li>指针可以有多级指针<code>**p</code>，而引用至于一级；</li><li>指针和引用使用<code>++</code>运算符的意义不一样；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li></ol><h2 id="联合体-共用体"><a href="#联合体-共用体" class="headerlink" title="联合体&#x2F;共用体"></a>联合体&#x2F;共用体</h2><ol><li>联合体union是共用存储空间的</li><li>大端模式和小端模式数据的存储</li></ol><p>联合<code>union</code>是一种<strong>节省空间的特殊的类</strong>，<code>union </code>可以有多个数据成员，但是在任意时刻只有<strong>一个数据成员可以有值</strong>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 <code>public</code></li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 <code>union</code> 在定义所在作用域可直接访问 <code>union</code> 成员</li><li>匿名 <code>union</code> 不能包含 <code>protected</code> 成员或<code>private</code>成员</li><li>全局匿名联合必须是静态<code>static</code>的</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p><ol><li>在枚举值表中应列出所有可用值，也称为枚举元素。</li><li>枚举值是常量，不能在程序中用赋值语句再对它赋值。</li><li>枚举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …</li></ol><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是由一批数据组合而成的一种新的数据类型。</p><h4 id="结构体创建"><a href="#结构体创建" class="headerlink" title="结构体创建"></a>结构体创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tag</span> &#123; <br>    member-list<br>    member-list <br>    member-list  <br>    ...<br>&#125; variable-list ;<br></code></pre></td></tr></table></figure><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><h5 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h5><p>一旦结构体定义下来，则结构体的成员内存布局也定下来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFun</span><span class="hljs-params">()</span></span>&#123;<br>    stu *s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">stu</span>();<br>    <span class="hljs-type">int</span> offsize1 = (<span class="hljs-type">int</span>)&amp;(s-&gt;b) - (<span class="hljs-type">int</span>)s;<span class="hljs-comment">//输出结果都为4， 为b属性成员相对首地址的偏移</span><br>    <span class="hljs-type">int</span> offsize2 = <span class="hljs-built_in">offsetof</span>(stu, b);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h5><p>理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列， 而不是简单地顺序排列，这就是<strong>内存对齐。</strong></p><p>**原因：**cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等，如果没有对齐，为了避免访问一个变量可能产生二次访问。</p><p><strong>手动设定：</strong><code>#pragma pack(4)</code>，强行按照4字节进行对齐</p><p><strong>未设定：<strong>首先按最大属性占用的内存进行对齐，其它属性内存占用则看成是</strong>连续的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stu</span> &#123;<span class="hljs-comment">//按最大字节double为8字节进行对齐， int + char = 5字节，按8字节对齐，因此sizeof(stu) = 16;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">double</span> c;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stu</span> &#123;   <span class="hljs-comment">//按最大字节double为8字节进行对齐， int与char不连续，都需要按8字节对齐，因此sizeof(stu) = 24;</span><br>    <span class="hljs-type">int</span> a;<br>   <span class="hljs-type">double</span> c;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>类可以将其（非静态）数据成员定义为位域，语法：<code>Bit mode : 2</code>, <code>mode占 2 位</code>，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stu</span> &#123;<br>  <span class="hljs-type">int</span> a : <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> b : <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符<code>（&amp;）</code>不能作用于位域，任何指针都无法指向类的位域</li></ol><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p><code>#incude&lt;&gt;</code>和<code>#include &quot;&quot;</code>区别：</p><ul><li><p><code>&quot;&quot;</code> 表示系统先在<code>file1.c</code>所在的当前目录找<code>file1.h</code>，如果找不到，再按系统指定的目录检索。</p></li><li><p><code>&lt; &gt; </code>表示系统直接按系统指定的目录检索。</p></li></ul><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>宏在编译时完成替换 ，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</p><ol><li><h5 id="宏定义和函数区别"><a href="#宏定义和函数区别" class="headerlink" title="宏定义和函数区别"></a>宏定义和函数区别</h5><ul><li>宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</li><li>宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。</li><li>宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li><li>宏函数不要在最后加分号。</li></ul></li><li><h5 id="宏定义和const区别"><a href="#宏定义和const区别" class="headerlink" title="宏定义和const区别"></a>宏定义和const区别</h5><ul><li>宏替换发生在编译阶段之前，属于文本插入替换；<code>const</code>作用发生于编译过程中。</li><li>宏不检查类型；<code>const</code>会检查数据类型。</li><li>宏定义的数据没有分配内存空间，只是插入替换掉；<code>const</code>定义的变量只是值不能改变，但要分配内存空间。</li></ul></li><li><h5 id="宏定义和typedef区别"><a href="#宏定义和typedef区别" class="headerlink" title="宏定义和typedef区别"></a>宏定义和typedef区别</h5><ul><li>宏主要用于定义常量及书写复杂的内容；<code>typedef</code>主要用于定义类型别名。</li><li>宏替换发生在编译阶段之前，属于文本插入替换；<code>typedef</code>是编译的一部分。</li><li>宏不检查类型；<code>typedef</code>会检查数据类型。</li><li>宏不是语句，不在在最后加分号；<code>typedef</code>是语句，要加分号标识结束。</li><li>注意对指针的操作，<code>typedef char * p_char</code>和<code>#define p_char char *</code>区别巨大。</li></ul></li><li><h5 id="宏定义和内联函数区别"><a href="#宏定义和内联函数区别" class="headerlink" title="宏定义和内联函数区别"></a>宏定义和内联函数区别</h5><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li>内联函数本身是函数，强调函数特性，具有重载等功能。</li><li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</li></ul></li></ol><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>让编译器只对满足条件的代码进行编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>     标识符</span><br>     语句序列<br>[<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>     语句序列]<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><ol><li><p><strong>文本文件</strong> - 文件以文本的<strong>ASCII码形式存储在计算机中</strong></p></li><li><p><strong>二进制文件</strong> - 文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</p></li></ol><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><ol><li><p>输入&#x2F;输出流</p><p> <code>iostream</code>标准库，它提供了 <code>cin </code>和 <code>cout</code> 方法分别用于从标准输入读取流和向标准输出写入流。</p></li><li><p>文件流</p><ul><li><code>ofstream</code>：该数据类型表示输出文件流，用于创建文件并向文件写入信息。</li><li><code>ifstream</code>：该数据类型表示输入文件流，用于从文件读取信息。</li><li><code>fstream</code>：该数据类型通常表示文件流，且同时具有<code>ofstream</code>和<code>ifstream</code>两种功能，可以创建文件，向文件写入信息，从文件读取信息。</li></ul></li></ol><h4 id="文件打开模型"><a href="#文件打开模型" class="headerlink" title="文件打开模型"></a>文件打开模型</h4><table><thead><tr><th>模式标志</th><th>描述</th></tr></thead><tbody><tr><td>ios::app</td><td>追加模式。所有写入都追加到文件末尾。</td></tr><tr><td>ios::ate</td><td>文件打开后定位到文件末尾。</td></tr><tr><td>ios::in</td><td>打开文件用于读取。</td></tr><tr><td>ios::out</td><td>打开文件用于写入。</td></tr><tr><td>ios::trunc</td><td>如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td></tr></tbody></table><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>三个关键字：<code>try、catch、throw</code></p><ul><li><code>throw</code>: 当问题出现时，程序会抛出一个异常。这是通过使用<code> throw</code> 关键字来完成的。</li><li><code>catch</code>: 在您想要处理问题的地方，通过异常处理程序捕获异常。<code>catch</code> 关键字用于捕获异常。</li><li><code>try</code>: <code>try</code> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 <code>catch</code> 块。</li></ul><h4 id="标准的异常"><a href="#标准的异常" class="headerlink" title="标准的异常"></a>标准的异常</h4><img src="../images/image-20200815094236854.png" /><table><thead><tr><th align="left">异常</th><th>描述</th></tr></thead><tbody><tr><td align="left">std::exception</td><td>该异常是所有标准 C++ 异常的父类。</td></tr><tr><td align="left">std::bad_alloc</td><td>该异常可以通过 <code>new</code> 抛出。</td></tr><tr><td align="left">std::bad_cast</td><td>该异常可以通过 <code>dynamic_cast</code> 抛出。</td></tr><tr><td align="left">std::bad_exception</td><td>这在处理 C++ 程序中无法预期的异常时非常有用。</td></tr><tr><td align="left">std::bad_typeid</td><td>该异常可以通过 <code>typeid</code>抛出。</td></tr><tr><td align="left">std::logic_error</td><td>理论上可以通过读取代码来检测到的异常。</td></tr><tr><td align="left">std::domain_error</td><td>当使用了一个无效的数学域时，会抛出该异常。</td></tr><tr><td align="left">std::invalid_argument</td><td>当使用了无效的参数时，会抛出该异常。</td></tr><tr><td align="left">std::length_error</td><td>当创建了太长的 <code>std::string</code> 时，会抛出该异常。</td></tr><tr><td align="left">std::out_of_range</td><td>该异常可以通过方法抛出，例如 <code>std::vector</code> 和 <code>std::bitset&lt;&gt;::operator[]()</code>。</td></tr><tr><td align="left">std::runtime_error</td><td>理论上不可以通过读取代码来检测到的异常。</td></tr><tr><td align="left">std::overflow_error</td><td>当发生数学上溢时，会抛出该异常。</td></tr><tr><td align="left">std::range_error</td><td>当尝试存储超出范围的值时，会抛出该异常。</td></tr><tr><td align="left">std::underflow_error</td><td>当发生数学下溢时，会抛出该异常。</td></tr></tbody></table><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>可以通过继承和重载 <code>exception</code> 类来定义新的异常。下面的实例演示了如何使用 <code>std::exception </code>类来实现自己的异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> exception &#123;<br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">what</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;C++ Exception&quot;</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p><code>makefile</code>定义了一系列的规则来指定哪些文件需要编译，配和<code>make</code>命令一起配合使用的</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL（较全）</title>
    <link href="/2022/04/30/C++STL/"/>
    <url>/2022/04/30/C++STL/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>STL</font></center><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>STL(Standard Template Library,<strong>标准模板库</strong>)，STL 从广义上分为: <strong>容器，算法， 迭代器</strong>，<strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。)</p><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ol><li><p><strong>容器</strong></p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来，常用的数据结构：数组，链表，树， 栈， 队列，集合，映射表等</p><p><strong>容器分类：</strong></p><ul><li><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置</li><li><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</li></ul></li><li><p><strong>算法</strong></p><ul><li><strong>质变算法</strong>：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</li><li><strong>非质变算法</strong>：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li></ul></li><li><p><strong>迭代器</strong></p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素。每个容器都有自己专属的迭代器，迭代器使用非常类似于指针</p><p>**迭代器种类：**输入迭代器，输出迭代器，前向迭代器，<strong>双向迭代器，随机访问迭代器</strong></p></li><li><p><strong>仿函数</strong>：行为类似函数，可作为算法的某种策略。</p></li><li><p><strong>适配器</strong>：一种用来修饰容器或者仿函数或迭代器接口的东西</p></li><li><p><strong>空间配置器</strong>：负责空间的配置与管理。</p></li></ol><h2 id="内存管理与优化"><a href="#内存管理与优化" class="headerlink" title="内存管理与优化"></a>内存管理与优化</h2><p>STL的分配器用于封装STL容器在内存管理上的底层细节</p><h4 id="分配与释放"><a href="#分配与释放" class="headerlink" title="分配与释放"></a>分配与释放</h4><p>在C++中，其内存配置和释放如下：</p><ol><li><p><code>new</code>运算</p><p>分两个阶段：(1)调用<code>::operator new</code>配置内存；(2)调用对象构造函数构造对象内容</p></li><li><p><code>delete</code>运算</p><p>分两个阶段：(1)调用对象析构函数；(2)调用<code>::operator delete</code>释放内存</p></li></ol><p>其中内存配置有<code>alloc::allocate()</code>负责，内存释放由<code>alloc::deallocate()</code>负责；对象构造由<code>::construct()</code>负责，对象析构由<code>::destroy()</code>负责。</p><h4 id="二级配置器结构"><a href="#二级配置器结构" class="headerlink" title="二级配置器结构"></a>二级配置器结构</h4><ol><li><p><strong>第一级配置器</strong></p><p>分配的空间大小超过128B时；第一级空间配置器直接使用<code>malloc()</code>、<code>realloc()</code>、<code>free()</code>函数进行内存空间的分配和释放</p></li><li><p><strong>第二级配置器</strong></p><p>分配的空间大小小于128B时；而第二级空间配置器采用了内存池技术避免太多小区块造成的内存碎片。主要通过空闲链表来管理内存，每次配置一大块内存，并维护对应的16个空闲链表，分别管理大小为8、16、24……120、128的数据块。下次若有相同大小的内存需求，则直接从<code>free-list</code>中取，如果有小额区块被释放，则由配置器回收到<code>free-list</code>中</p></li></ol><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>Iterator</code>（迭代器）模式，用于提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p><ol><li>类似于数据库中的游标（cursor）,屏蔽了底层存储空间的不连续性，在上层使容器元素维持一种“逻辑连续”的假象</li><li>指针代表真正的内存地址，即对象在内存中的存储位置；迭代器则代表元素在容器中的相对位置</li><li>迭代器返回的是对象引用而不是对象的值，所以<code>cout</code>只能输出迭代器使用<code>*</code>取值后的值而不能直接输出其自身。</li></ol><p><code>Iterator</code>模式是运用于聚合对象的模式，因此仅用于底层聚合支持类，如STL的<code>list</code>、<code>vector</code>、<code>stack</code>等容器类及<code>ostream_iterator</code>等扩展<code>iterator</code></p><h4 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h4><ol><li>对于序列容器<code>vector</code>,<code>deque</code>来说，使用<code>erase(itertor)</code>后，后边的每个元素的迭代器都会失效，这是因为删除一个元素将导致后边每个元素都会往前移动一个位置，但是还好<code>erase</code>会返回下一个有效的迭代器</li><li>对于关联容器<code>map</code>,<code>set</code>来说，使用了<code>erase(iterator)</code>后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用<code>erase</code>之前，记录下一个元素的迭代器即可。</li><li>对于<code>list</code>来说，它使用了不连续分配的内存，并且它的<code>erase</code>方法也会返回下一个有效的<code>iterator</code>，因此上面两种正确的方法都可以使用。</li></ol><h2 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h2><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><strong><code>string</code></strong></td><td><code>char *</code></td><td></td><td>有序</td><td>可重复</td><td></td></tr><tr><td><strong><code>array</code></strong></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><strong><code>vector</code></strong></td><td>动态数组</td><td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问<br/>VS2015中以1.5倍扩容，GCC以2倍扩容。</td></tr><tr><td><strong><code>tuple</code></strong></td><td></td><td>类似于结构体或pair类型的模板。其中每个成员变量各自可以是任意类型</td><td></td><td></td><td><code>tuple&lt;int,int，float&gt; tp(1,2,3.1);</code></td></tr><tr><td><strong><code>deque</code></strong></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><code>forward_list</code></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><strong><code>list</code></strong></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><code>stack</code></td><td><code>deque / list</code></td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td><code>deque</code> 或 <code>list</code> 封闭头端开口，不用 <code>vector</code> 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><code>queue</code></td><td><code>deque / list</code></td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td><code>deque</code> 或 <code>list</code> 封闭头端开口，不用 <code>vector</code> 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><code>priority_queue</code></td><td><code>vector + max-heap</code></td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td><code>vector</code>容器+<code>heap</code>处理规则</td></tr><tr><td><strong><code>set</code></strong></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><code>multiset</code></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><strong><code>map</code></strong></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><code>multimap</code></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><strong><code>unordered_set</code></strong></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><code>unordered_multiset</code></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><strong><code>unordered_map</code></strong></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><code>unordered_multimap</code></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><h4 id="vector与list"><a href="#vector与list" class="headerlink" title="vector与list"></a>vector与list</h4><p><code>vector</code>连续存储的容器，底层实现是动态数组，每次扩容基本以两倍容量增长，在堆上分配空间</p><p><code>list</code>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间</p><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ol><li><code>vector</code>底层实现是数组；<code>list</code>是双向 链表</li><li><code>vector</code>支持随机访问，<code>list</code>不支持</li><li><code>vector</code>是顺序内存，<code>list</code>不是</li><li><code>vector</code>在中间节点进行插入删除会导致内存拷贝，<code>list</code>不会</li><li><code>vector</code>一次性分配好内存，不够时才进行2倍扩容；<code>list</code>每次插入新节点都会进行内存申请</li><li><code>vector</code>随机访问性能好，插入删除性能差；<code>list</code>随机访问性能差，插入删除性能好</li></ol><h4 id="resize与reserve"><a href="#resize与reserve" class="headerlink" title="resize与reserve"></a>resize与reserve</h4><ol><li><p><code>resize()</code>：改变当前容器内含有元素的数量</p><p><code>vector&lt;int&gt;v; v.resize(len);</code>，<code>v</code>的<code>size</code>变为<code>len</code>，如果原来<code>v</code>的<code>size</code>小于<code>len</code>，那么容器新增<code>len-size</code>个元素</p></li><li><p><code>reserve()</code>：改变当前容器的最大容量，它不会生成元素，只是确定这个容器允许放入多少对象，</p><p>如果<code>reserve(len)</code>的值大于当前的最大容量，那么会重新分配一块能存<code>len</code>个对象的空间，然后把之前<code>v.size()</code>个对象通过copy <code>construtor</code>复制过来，销毁之前的内存</p></li></ol><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h4><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p><h4 id="map与set"><a href="#map与set" class="headerlink" title="map与set"></a>map与set</h4><p><code>map</code>和<code>set</code>都是关联容器，其底层实现都是红黑树。所以几乎所有的<code>map</code>和<code>set</code>的操作行为，都只是转调<code>RB-tree</code>的操作行为。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ol><li><code>map</code>中的元素是<code>key-value</code>对：关键字起到索引的作用，值则表示与索引相关联的数据；<code>set</code>与之相对就是关键字的简单集合，<code>set</code>中每个元素只包含一个关键字</li><li><code>set</code>的迭代器是<code>const</code>的，不允许修改元素的值；<code>map</code>允许修改<code>value</code>，但不允许修改<code>key</code>。原因是<code>map</code>和<code>set</code>是根据关键字排序来保证其有序性的</li><li><code>map</code>支持下标操作，<code>set</code>不支持下标操作。<code>map</code>可以用<code>key</code>做下标，<code>map</code>的下标运算符<code>[]</code>将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和<code>mapped_type</code>类型默认值的元素至<code>map</code>中，因此下标运算符<code>[]</code>在<code>map</code>需要慎用</li></ol><h4 id="set与unordered-set区别"><a href="#set与unordered-set区别" class="headerlink" title="set与unordered_set区别"></a>set与unordered_set区别</h4><ol><li><code>set</code>基于红黑树实现，红黑树具有<strong>自动排序的功能</strong>，因此<code>set</code>内部所有的数据，在任何时候，都是有序的。当我们需要有序数据（不同的元素），或必须打印&#x2F;访问数据（按排序顺序），或需要元素的前身&#x2F;后继者，需要使用<code>set</code></li><li><code>unordered_set</code>基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，<strong>无自动排序功能</strong>。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用<code>hash</code>函数对<code>key</code>进行映射到不同区域进行保存。当我们需要保留一组不同的元素，不需要排序，或我们需要单个元素访问，即没有遍历</li></ol><h4 id="deque的实现"><a href="#deque的实现" class="headerlink" title="deque的实现"></a>deque的实现</h4><img src="../images/image-20200920140323287.png"/><p><code>deque</code>作用是允许在其首尾两端快速插入及删除元素</p><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p><code>deque</code>系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的借口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构</p><p><code>deque</code>模板需要<code>map，start，finish</code>来管理整个内存空间</p><ol><li><code>map</code>是指针数组，里面成员是分配空间<code>Node</code>的地址，如何明白如何动态分配二维数组，那么这个map就很容易理解；</li><li>迭代器，迭代器里面含有4个成员，连续空间开始地址<code>first</code>，结束地址<code>last</code>，空间中当前元素的地址<code>cur</code>以及连续空间地址在<code>map</code>中的位置<code>node</code>），如上图所示</li></ol><p>deque在插入数据(头部或者尾部)， 如果缓冲区不足，那么为触发分配新的缓冲区，这和<code>vector</code>不一样</p><img src="../images/20180621202744746"/><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p><code>string</code>封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器。即<code>string</code>容器里面元素的数据类型是<code>char*</code></p><h5 id="与char-的类型转换"><a href="#与char-的类型转换" class="headerlink" title="与char*的类型转换"></a>与<code>char*</code>的类型转换</h5><ol><li><p><code>string</code>转换<code>char*</code></p><ul><li><code>data()</code>:  <code>const char *p = str.data();</code></li><li><code>c_str()</code>: <code>const char *p = str.c_str();</code></li><li><code>copy()</code>: <code>char p[50]; str.copy(p, 5, 0);</code></li></ul></li><li><p><code>char *</code>转换 <code>string</code></p><p>可以直接赋值进行转换</p></li></ol><h5 id="存值取值"><a href="#存值取值" class="headerlink" title="存值取值"></a>存值取值</h5><p><code>operator[]</code>和<code>at()</code>均返回当前字符串中第n个字符，二者是有区别的。</p><ol><li><p><code>at()</code>在越界时会抛出异常，<code>[]</code>在刚好越界时会返回<code>(char)0</code>，再继续越界时，编译器直接出错。</p></li><li><p>如果你的程序希望可以通过<code>try,catch</code>捕获异常，建议采用<code>at()</code>。</p></li></ol><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h5 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h5><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态，即可以有成员变量</li><li>函数对象可以作为参数传递</li></ul><h5 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h5><p><strong>返回bool类型的仿函数</strong>称为<strong>谓词</strong>，<strong>如果operator()接受一个参数</strong>，那么叫做<strong>一元谓词</strong>，接受两个参数，那么叫做<strong>二元谓词</strong></p><h5 id="STL内建函数对象"><a href="#STL内建函数对象" class="headerlink" title="STL内建函数对象"></a>STL内建函数对象</h5><p>这些仿函数所产生的对象，用法和一般函数完全相同，引入头文件<code>#include&lt;functional&gt;</code></p><ol><li><p><strong>算术仿函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T plus&lt;T&gt;`          <span class="hljs-comment">//加法仿函数</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T minus&lt;T&gt;`         <span class="hljs-comment">//减法仿函数</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T multiplies&lt;T&gt;`    <span class="hljs-comment">//乘法仿函数</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T divides&lt;T&gt;`       <span class="hljs-comment">//除法仿函数</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T modulus&lt;T&gt;`       <span class="hljs-comment">//取模仿函数</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; T negate&lt;T&gt;`        <span class="hljs-comment">//取反仿函数</span><br></code></pre></td></tr></table></figure></li><li><p><strong>关系仿函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> equal_to&lt;T&gt;`                <span class="hljs-comment">//等于</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> not_equal_to&lt;T&gt;`            <span class="hljs-comment">//不等于</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> greater&lt;T&gt;`                 <span class="hljs-comment">//大于</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> greater_equal&lt;T&gt;`           <span class="hljs-comment">//大于等于</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> less&lt;T&gt;`                    <span class="hljs-comment">//小于</span><br>- `<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> less_equal&lt;T&gt;`              <span class="hljs-comment">//小于等于</span><br></code></pre></td></tr></table></figure></li><li><p><strong>逻辑仿函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_and&lt;T&gt;`              <span class="hljs-comment">//逻辑与         </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_or&lt;T&gt;`               <span class="hljs-comment">//逻辑或        </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-type">bool</span> logical_not&lt;T&gt;`              <span class="hljs-comment">//逻辑非</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="容器API"><a href="#容器API" class="headerlink" title="容器API"></a>容器API</h2><p>无需强行记忆，根据各容器底层数据结构便可知道其可以进行操作，关键还是在底层数据结构</p><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p> Array 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>begin</td><td>返回指向数组容器中第一个元素的迭代器</td></tr><tr><td>end</td><td>返回指向数组容器中最后一个元素之后的理论元素的迭代器</td></tr><tr><td>rbegin</td><td>返回指向数组容器中最后一个元素的反向迭代器</td></tr><tr><td>rend</td><td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td></tr><tr><td>cbegin</td><td>返回指向数组容器中第一个元素的常量迭代器（const_iterator）</td></tr><tr><td>cend</td><td>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td></tr><tr><td>crbegin</td><td>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>crend</td><td>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>size</td><td>返回数组容器中元素的数量</td></tr><tr><td>max_size</td><td>返回数组容器可容纳的最大元素数</td></tr><tr><td>empty</td><td>返回一个布尔值，指示数组容器是否为空</td></tr><tr><td>operator[]</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>at</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>front</td><td>返回对容器中第一个元素的引用</td></tr><tr><td>back</td><td>返回对容器中最后一个元素的引用</td></tr><tr><td>data</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>fill</td><td>用 val（参数）填充数组所有元素</td></tr><tr><td>swap</td><td>通过 x（参数）的内容交换数组的内容</td></tr><tr><td>get（array）</td><td>形如 <code>std::get&lt;0&gt;(myarray)</code>；传入一个数组容器，返回指定位置元素的引用</td></tr><tr><td>relational operators (array)</td><td>形如 <code>arrayA &gt; arrayB</code>；依此比较数组每个元素的大小关系</td></tr></tbody></table><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector 是表示可以改变大小的数组的序列容器。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>vector</td><td>构造函数</td></tr><tr><td>~vector</td><td>析构函数，销毁容器对象</td></tr><tr><td>operator&#x3D;</td><td>将新内容分配给容器，替换其当前内容，并相应地修改其大小</td></tr><tr><td>begin</td><td>返回指向容器中第一个元素的迭代器</td></tr><tr><td>end</td><td>返回指向容器中最后一个元素之后的理论元素的迭代器</td></tr><tr><td>rbegin</td><td>返回指向容器中最后一个元素的反向迭代器</td></tr><tr><td>rend</td><td>返回一个反向迭代器，指向中第一个元素之前的理论元素</td></tr><tr><td>cbegin</td><td>返回指向容器中第一个元素的常量迭代器（const_iterator）</td></tr><tr><td>cend</td><td>返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td></tr><tr><td>crbegin</td><td>返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>crend</td><td>返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>size</td><td>返回容器中元素的数量</td></tr><tr><td>max_size</td><td>返回容器可容纳的最大元素数</td></tr><tr><td>resize</td><td>调整容器的大小，使其包含 n（参数）个元素</td></tr><tr><td>capacity</td><td>返回当前为 vector 分配的存储空间（容量）的大小</td></tr><tr><td>empty</td><td>返回 vector 是否为空</td></tr><tr><td>reserve</td><td>请求 vector 容量至少足以包含 n（参数）个元素</td></tr><tr><td>shrink_to_fit</td><td>要求容器减小其 capacity（容量）以适应其 size（元素数量）</td></tr><tr><td>operator[]</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>at</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>front</td><td>返回对容器中第一个元素的引用</td></tr><tr><td>back</td><td>返回对容器中最后一个元素的引用</td></tr><tr><td>data</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>assign</td><td>将新内容分配给 vector，替换其当前内容，并相应地修改其 size</td></tr><tr><td>push_back</td><td>在容器的最后一个元素之后添加一个新元素</td></tr><tr><td>pop_back</td><td>删除容器中的最后一个元素，有效地将容器 size 减少一个</td></tr><tr><td>insert</td><td>通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小</td></tr><tr><td>erase</td><td>从 vector 中删除单个元素（<code>position</code>）或一系列元素（<code>[first，last)</code>），这有效地减少了被去除的元素的数量，从而破坏了容器的大小</td></tr><tr><td>swap</td><td>通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象</td></tr><tr><td>clear</td><td>从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器</td></tr><tr><td>emplace</td><td>通过在 position（参数）位置处插入新元素 args（参数）来扩展容器</td></tr><tr><td>emplace_back</td><td>在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td></tr><tr><td>get_allocator</td><td>返回与vector关联的构造器对象的副本</td></tr><tr><td>swap(vector)</td><td>容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同</td></tr><tr><td>relational operators (vector)</td><td>形如 <code>vectorA &gt; vectorB</code>；依此比较每个元素的大小关系</td></tr></tbody></table><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>deque</td><td>构造函数</td></tr><tr><td>push_back</td><td>在当前的最后一个元素之后 ，在 deque 容器的末尾添加一个新元素</td></tr><tr><td>push_front</td><td>在 deque 容器的开始位置插入一个新的元素，位于当前的第一个元素之前</td></tr><tr><td>pop_back</td><td>删除 deque 容器中的最后一个元素，有效地将容器大小减少一个</td></tr><tr><td>pop_front</td><td>删除 deque 容器中的第一个元素，有效地减小其大小</td></tr><tr><td>emplace_front</td><td>在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前</td></tr><tr><td>emplace_back</td><td>在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td></tr></tbody></table><h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h4><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>forward_list</td><td>返回指向容器中第一个元素之前的位置的迭代器</td></tr><tr><td>cbefore_begin</td><td>返回指向容器中第一个元素之前的位置的 const_iterator</td></tr></tbody></table><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。</p><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>stack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。</p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。</p><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set 是按照特定顺序存储唯一元素的容器。</p><h4 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h4><p>multiset容器中允许有重复的元素</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>map</td><td>构造函数</td></tr><tr><td>begin</td><td>返回引用容器中第一个元素的迭代器</td></tr><tr><td>end</td><td>返回指向容器中最后一个元素之后的理论元素的迭代器</td></tr><tr><td>key_comp</td><td>返回容器用于比较键的比较对象的副本</td></tr><tr><td>value_comp</td><td>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前</td></tr><tr><td>find</td><td>在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器</td></tr><tr><td>count</td><td>在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量</td></tr><tr><td>lower_bound</td><td>返回一个非递减序列 <code>[first, last)</code>（参数）中的第一个大于等于值 val（参数）的位置的迭代器</td></tr><tr><td>upper_bound</td><td>返回一个非递减序列 <code>[first, last)</code>（参数）中第一个大于 val（参数）的位置的迭代器</td></tr><tr><td>equal_range</td><td>获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（<code>pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;</code>）</td></tr></tbody></table><h4 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h4><h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><h4 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a>unordered_multiset</h4><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><h4 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h4><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><p>这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 简单查找算法，要求输入迭代器（input iterator）</span><br><span class="hljs-built_in">find</span>(beg, end, val); <span class="hljs-comment">// 返回一个迭代器，指向输入序列中第一个等于 val 的元素，未找到返回 end</span><br><span class="hljs-built_in">find_if</span>(beg, end, unaryPred); <span class="hljs-comment">// 返回一个迭代器，指向第一个满足 unaryPred 的元素，未找到返回 end</span><br><span class="hljs-built_in">find_if_not</span>(beg, end, unaryPred); <span class="hljs-comment">// 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 end</span><br><span class="hljs-built_in">count</span>(beg, end, val); <span class="hljs-comment">// 返回一个计数器，指出 val 出现了多少次</span><br><span class="hljs-built_in">count_if</span>(beg, end, unaryPred); <span class="hljs-comment">// 统计有多少个元素满足 unaryPred</span><br><span class="hljs-built_in">all_of</span>(beg, end, unaryPred); <span class="hljs-comment">// 返回一个 bool 值，判断是否所有元素都满足 unaryPred</span><br><span class="hljs-built_in">any_of</span>(beg, end, unaryPred); <span class="hljs-comment">// 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPred</span><br><span class="hljs-built_in">none_of</span>(beg, end, unaryPred); <span class="hljs-comment">// 返回一个 bool 值，判断是否所有元素都不满足 unaryPred</span><br><br><span class="hljs-comment">// 查找重复值的算法，传入向前迭代器（forward iterator）</span><br><span class="hljs-built_in">adjacent_find</span>(beg, end); <span class="hljs-comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span><br><span class="hljs-built_in">adjacent_find</span>(beg, end, binaryPred); <span class="hljs-comment">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span><br><span class="hljs-built_in">search_n</span>(beg, end, count, val); <span class="hljs-comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span><br><span class="hljs-built_in">search_n</span>(beg, end, count, val, binaryPred); <span class="hljs-comment">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span><br><br><span class="hljs-comment">// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器</span><br><span class="hljs-built_in">search</span>(beg1, end1, beg2, end2); <span class="hljs-comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span><br><span class="hljs-built_in">search</span>(beg1, end1, beg2, end2, binaryPred); <span class="hljs-comment">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span><br><span class="hljs-built_in">find_first_of</span>(beg1, end1, beg2, end2); <span class="hljs-comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span><br><span class="hljs-built_in">find_first_of</span>(beg1, end1, beg2, end2, binaryPred); <span class="hljs-comment">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span><br><span class="hljs-built_in">find_end</span>(beg1, end1, beg2, end2); <span class="hljs-comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span><br><span class="hljs-built_in">find_end</span>(beg1, end1, beg2, end2, binaryPred); <span class="hljs-comment">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span><br><br><span class="hljs-comment">// 其他只读算法，传入输入迭代器</span><br>for_each(beg, end, unaryOp); <span class="hljs-comment">// 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略</span><br><span class="hljs-built_in">mismatch</span>(beg1, end1, beg2); <span class="hljs-comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span><br><span class="hljs-built_in">mismatch</span>(beg1, end1, beg2, binaryPred); <span class="hljs-comment">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span><br><span class="hljs-built_in">equal</span>(beg1, end1, beg2); <span class="hljs-comment">// 比较每个元素，确定两个序列是否相等。</span><br><span class="hljs-built_in">equal</span>(beg1, end1, beg2, binaryPred); <span class="hljs-comment">// 比较每个元素，确定两个序列是否相等。</span><br><br><span class="hljs-comment">// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。</span><br><span class="hljs-built_in">lower_bound</span>(beg, end, val); <span class="hljs-comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span><br><span class="hljs-built_in">lower_bound</span>(beg, end, val, comp); <span class="hljs-comment">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span><br><span class="hljs-built_in">upper_bound</span>(beg, end, val); <span class="hljs-comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span><br><span class="hljs-built_in">upper_bound</span>(beg, end, val, comp); <span class="hljs-comment">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span><br><span class="hljs-built_in">equal_range</span>(beg, end, val); <span class="hljs-comment">// 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器</span><br><span class="hljs-built_in">binary_search</span>(beg, end, val); <span class="hljs-comment">// 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。</span><br><br><span class="hljs-comment">// 只写不读算法，要求输出迭代器（output iterator）</span><br><span class="hljs-built_in">fill</span>(beg, end, val); <span class="hljs-comment">// 将 val 赋予每个元素，返回 void</span><br><span class="hljs-built_in">fill_n</span>(beg, cnt, val); <span class="hljs-comment">// 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器</span><br><span class="hljs-built_in">genetate</span>(beg, end, Gen); <span class="hljs-comment">// 每次调用 Gen() 生成不同的值赋予每个序列，返回 void</span><br><span class="hljs-built_in">genetate_n</span>(beg, cnt, Gen); <span class="hljs-comment">// 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器</span><br><br><span class="hljs-comment">// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中</span><br><span class="hljs-built_in">copy</span>(beg, end, dest); <span class="hljs-comment">// 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列</span><br><span class="hljs-built_in">copy_if</span>(beg, end, dest, unaryPred); <span class="hljs-comment">// 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列</span><br><span class="hljs-built_in">copy_n</span>(beg, n, dest); <span class="hljs-comment">// 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列</span><br><span class="hljs-built_in">move</span>(beg, end, dest); <span class="hljs-comment">// 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中</span><br><span class="hljs-built_in">transform</span>(beg, end, dest, unaryOp); <span class="hljs-comment">// 调用给定操作（一元操作），并将结果写到dest中</span><br><span class="hljs-built_in">transform</span>(beg, end, beg2, dest, binaryOp); <span class="hljs-comment">// 调用给定操作（二元操作），并将结果写到dest中</span><br><span class="hljs-built_in">replace_copy</span>(beg, end, dest, old_val, new_val); <span class="hljs-comment">// 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_val</span><br><span class="hljs-built_in">replace_copy_if</span>(beg, end, dest, unaryPred, new_val); <span class="hljs-comment">// 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_val</span><br><span class="hljs-built_in">merge</span>(beg1, end1, beg2, end2, dest); <span class="hljs-comment">// 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中</span><br><span class="hljs-built_in">merge</span>(beg1, end1, beg2, end2, dest, comp); <span class="hljs-comment">// 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中</span><br><br><span class="hljs-comment">// 使用前向迭代器的写算法，要求前向迭代器</span><br><span class="hljs-built_in">iter_swap</span>(iter1, iter2); <span class="hljs-comment">// 交换 iter1 和 iter2 所表示的元素，返回 void</span><br><span class="hljs-built_in">swap_ranges</span>(beg1, end1, beg2); <span class="hljs-comment">// 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。</span><br><span class="hljs-built_in">replace</span>(beg, end, old_val, new_val); <span class="hljs-comment">// 用 new_val 替换等于 old_val 的每个匹配元素</span><br><span class="hljs-built_in">replace_if</span>(beg, end, unaryPred, new_val); <span class="hljs-comment">// 用 new_val 替换满足 unaryPred 的每个匹配元素</span><br><br><span class="hljs-comment">// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）</span><br><span class="hljs-built_in">copy_backward</span>(beg, end, dest); <span class="hljs-comment">// 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。</span><br><span class="hljs-built_in">move_backward</span>(beg, end, dest);  <span class="hljs-comment">// 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。</span><br><span class="hljs-built_in">inplace_merge</span>(beg, mid, end); <span class="hljs-comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。</span><br><span class="hljs-built_in">inplace_merge</span>(beg, mid, end, comp); <span class="hljs-comment">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。</span><br><br><span class="hljs-comment">// 划分算法，要求双向选代器（bidirectional iterator）</span><br><span class="hljs-built_in">is_partitioned</span>(beg, end, unaryPred); <span class="hljs-comment">// 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 true</span><br><span class="hljs-built_in">partition_copy</span>(beg, end, dest1, dest2, unaryPred); <span class="hljs-comment">// 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。</span><br><span class="hljs-built_in">partitioned_point</span>(beg, end, unaryPred); <span class="hljs-comment">// 输入序列必须是已经用 unaryPred 划分过的。返回满足  unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred</span><br><span class="hljs-built_in">stable_partition</span>(beg, end, unaryPred); <span class="hljs-comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span><br><span class="hljs-built_in">partition</span>(beg, end, unaryPred); <span class="hljs-comment">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span><br><br><span class="hljs-comment">// 排序算法，要求随机访问迭代器（random-access iterator）</span><br><span class="hljs-built_in">sort</span>(beg, end); <span class="hljs-comment">// 排序整个范围</span><br><span class="hljs-built_in">stable_sort</span>(beg, end); <span class="hljs-comment">// 排序整个范围（稳定排序）</span><br><span class="hljs-built_in">sort</span>(beg, end, comp); <span class="hljs-comment">// 排序整个范围</span><br><span class="hljs-built_in">stable_sort</span>(beg, end, comp); <span class="hljs-comment">// 排序整个范围（稳定排序）</span><br><span class="hljs-built_in">is_sorted</span>(beg, end); <span class="hljs-comment">// 返回一个 bool 值，指出整个输入序列是否有序</span><br><span class="hljs-built_in">is_sorted</span>(beg, end, comp); <span class="hljs-comment">// 返回一个 bool 值，指出整个输入序列是否有序</span><br><span class="hljs-built_in">is_sorted_until</span>(beg, end); <span class="hljs-comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span><br><span class="hljs-built_in">is_sorted_until</span>(beg, end, comp); <span class="hljs-comment">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span><br><span class="hljs-built_in">partial_sort</span>(beg, mid, end); <span class="hljs-comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span><br><span class="hljs-built_in">partial_sort</span>(beg, mid, end, comp); <span class="hljs-comment">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span><br><span class="hljs-built_in">partial_sort_copy</span>(beg, end, destBeg, destEnd); <span class="hljs-comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span><br><span class="hljs-built_in">partial_sort_copy</span>(beg, end, destBeg, destEnd, comp); <span class="hljs-comment">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span><br><span class="hljs-built_in">nth_element</span>(beg, nth, end); <span class="hljs-comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span><br><span class="hljs-built_in">nth_element</span>(beg, nth, end, comp); <span class="hljs-comment">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span><br><br><span class="hljs-comment">// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列</span><br><span class="hljs-built_in">remove</span>(beg, end, val); <span class="hljs-comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><br><span class="hljs-built_in">remove_if</span>(beg, end, unaryPred); <span class="hljs-comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><br><span class="hljs-built_in">remove_copy</span>(beg, end, dest, val); <span class="hljs-comment">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><br><span class="hljs-built_in">remove_copy_if</span>(beg, end, dest, unaryPred); <span class="hljs-comment">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><br><span class="hljs-built_in">unique</span>(beg, end); <span class="hljs-comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><br><span class="hljs-built_in">unique</span> (beg, end, binaryPred); <span class="hljs-comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><br><span class="hljs-built_in">unique_copy</span>(beg, end, dest); <span class="hljs-comment">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><br><span class="hljs-built_in">unique_copy_if</span>(beg, end, dest, binaryPred); <span class="hljs-comment">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><br><span class="hljs-built_in">rotate</span>(beg, mid, end); <span class="hljs-comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span><br><span class="hljs-built_in">rotate_copy</span>(beg, mid, end, dest); <span class="hljs-comment">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span><br><br><span class="hljs-comment">// 使用双向迭代器的重排算法</span><br><span class="hljs-built_in">reverse</span>(beg, end); <span class="hljs-comment">// 翻转序列中的元素，返回 void</span><br><span class="hljs-built_in">reverse_copy</span>(beg, end, dest);; <span class="hljs-comment">// 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置</span><br><br><span class="hljs-comment">// 使用随机访问迭代器的重排算法</span><br><span class="hljs-built_in">random_shuffle</span>(beg, end); <span class="hljs-comment">// 混洗输入序列中的元素，返回 void</span><br><span class="hljs-built_in">random_shuffle</span>(beg, end, rand); <span class="hljs-comment">// 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 void</span><br><span class="hljs-built_in">shuffle</span>(beg, end, Uniform_rand); <span class="hljs-comment">// 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void</span><br><br><span class="hljs-comment">// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较</span><br><span class="hljs-built_in">min</span>(val1, va12); <span class="hljs-comment">// 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略</span><br><span class="hljs-built_in">min</span>(val1, val2, comp);<br><span class="hljs-built_in">min</span>(init_list);<br><span class="hljs-built_in">min</span>(init_list, comp);<br><span class="hljs-built_in">max</span>(val1, val2);<br><span class="hljs-built_in">max</span>(val1, val2, comp);<br><span class="hljs-built_in">max</span>(init_list);<br><span class="hljs-built_in">max</span>(init_list, comp);<br><span class="hljs-built_in">minmax</span>(val1, val2); <span class="hljs-comment">// 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略</span><br><span class="hljs-built_in">minmax</span>(vall, val2, comp);<br><span class="hljs-built_in">minmax</span>(init_list);<br><span class="hljs-built_in">minmax</span>(init_list, comp);<br><span class="hljs-built_in">min_element</span>(beg, end); <span class="hljs-comment">// 返回指向输入序列中最小元素的迭代器</span><br><span class="hljs-built_in">min_element</span>(beg, end, comp); <span class="hljs-comment">// 返回指向输入序列中最小元素的迭代器</span><br><span class="hljs-built_in">max_element</span>(beg, end); <span class="hljs-comment">// 返回指向输入序列中最大元素的迭代器</span><br><span class="hljs-built_in">max_element</span>(beg, end, comp); <span class="hljs-comment">// 返回指向输入序列中最大元素的迭代器</span><br><span class="hljs-built_in">minmax_element</span>(beg, end); <span class="hljs-comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span><br><span class="hljs-built_in">minmax_element</span>(beg, end, comp); <span class="hljs-comment">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span><br><br><span class="hljs-comment">// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。</span><br><span class="hljs-built_in">lexicographical_compare</span>(beg1, end1, beg2, end2);<br><span class="hljs-built_in">lexicographical_compare</span>(beg1, end1, beg2, end2, comp)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 面向对象（较全）</title>
    <link href="/2022/04/30/C++object-oriented/"/>
    <url>/2022/04/30/C++object-oriented/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>C++面向对象</font></center><p><img src="/./../images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png" alt="面向对象基本特征"></p><p>C++面向对象的三大特性为：<strong>封装、继承、多态</strong></p><p><strong>类和对象</strong>的理解：类是某种类型的事物的特征表现，对象是类的实例，万事万物都皆为对象，对象上有其属性和行为</p><h2 id="类-class"><a href="#类-class" class="headerlink" title="类(class)"></a>类(class)</h2><p><strong>类</strong>是某一种类型的事物的特征表现，语法：<code>class 类名{访问权限：属性/方法};</code></p><p><strong>默认函数：<strong>C++编译器至少给一个类</strong>添加3个默认函数</strong>，<strong>默认构造函数</strong>，<strong>默认析构函数</strong>，<strong>默认拷贝构造函数（对属性进行值拷贝</strong>，<strong>赋值运算符）</strong></p><p>如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造</p><p>如果用户定义拷贝构造函数，C++不会再提供其他构造函数</p><h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><p><strong>分类</strong>：成员包括<strong>成员变量和成员函数</strong></p><h5 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h5><ol><li>类内的成员变量和成员函数分开存储，只有<strong>非静态成员变量</strong>才属于类的对象上占用对象空间，<strong>函数和静态成员</strong>不占对象空间。</li><li>编译器加入的额外成员变量（例如：指向虚函数表的指针)</li><li>为了字节对齐优化加入的padding</li></ol><h5 id="const修饰成员"><a href="#const修饰成员" class="headerlink" title="const修饰成员"></a><code>const</code>修饰成员</h5><ol><li><strong>修饰成员变量</strong>：该成员变量不可改变，最好在类内部进行初始化</li><li><strong>修饰成员函数</strong>：<code>virtual void fun() const;</code>称为这个函数为<strong>常函数</strong>，常函数内不可以修改成员属性，但成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改。声明对象前加<code>const</code>称该对象为常对象，常对象只能调用常函数</li></ol><h5 id="类对象作为成员"><a href="#类对象作为成员" class="headerlink" title="类对象作为成员"></a>类对象作为成员</h5><p>数据成员一般是基本数据类型。但是也可以是对象，叫做<strong>对象成员</strong>。</p><p>构造函数初始化列表：先调用对象成员的构造函数，再调用本身的构造函数。析构函数和构造函数调用顺序相反，先构造，后析构。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>主要作用在于<strong>创建对象</strong>时为对象的<strong>成员属性赋值</strong>，编译器默认提供构造函数（空实现）</p><ol><li><p><strong>语法：</strong><code>类名(){}</code>，其函数名称与类名相同，没有返回值也不写<code>void</code>，可以有参数可发生重载</p></li><li><p><strong>分类</strong></p><ol><li><p><strong>有参构造</strong></p></li><li><p><strong>无参构造</strong></p></li><li><p><strong>普通构造</strong></p></li><li><p><strong>拷贝构造</strong> ，如果存在动态成员，那么浅拷贝就会出问题将会指向了堆里的同一个空间</p><p>调用的时机：</p><p>（1）对象以值传递的方式传给函数参数；</p><p>（2）对象以值传递的方式从函数返回</p><p>（3）用一个对象初始化另一个对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">A b = a; <span class="hljs-comment">// 调用构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)&#123;<span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-keyword">this</span>-&gt;age = p.age;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>调用方式</strong></p><ol><li>显示法：<code>Person p = Person(10);</code></li><li>括号法：<code>Person p1(10);</code></li><li>隐式转换法<code>Person p1 = 10; // 就是Person p = Person(10);</code></li></ol><p>特别地：</p><ol><li><p><strong>无参构造函数不能加括号</strong>，加了编译器认为这是一个函数声明；例如：<code>Person p();</code>不会创建对象</p></li><li><p><strong>不能利用拷贝构造函数初始化匿名对象</strong>，匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。例如: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Cat</span>();  <span class="hljs-comment">//调用后生命周期结束，直接调用析构函数</span><br>    Cat cc = <span class="hljs-built_in">Cat</span>(); <span class="hljs-comment">//变成了cc对象的生命周期</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>初始化方式</strong></p><ul><li><p><strong>传统方式</strong></p></li><li><p><strong>初始化列表方式</strong>，语法： <code>构造函数(参数1, 参数2, ...)：属性1(参数1),属性2（参数2）... {}</code>，以下情况必须采用初始化构造列表。（使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些）</p><ul><li>初始化一个<code>const</code>或<code>reference</code>成员，原因是<code>const</code>对象或引用只能初始化但是不能赋值</li><li>调用一个基类的构造函数，而该函数有一组参数。<code>B(int v) : p(v), Base(v) {}</code></li><li>调用一个数据成员对象的构造函数，而该函数有一组参数</li></ul></li></ul></li></ol><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作</p><ol><li><p><strong>语法</strong>：<code>~类名(){}</code>其函数名称与类名相同前面加上<code>~</code>符号，没有返回值也不写<code>void</code>，不能重载。</p></li><li><p><strong>执行顺序</strong></p><p>派生类本身的析构函数；对象成员析构函数；基类析构函数。</p></li><li><p><strong>虚析构函数</strong></p><p>语法：<code>virtual ~类名(){}</code>，将父类的析构函数设置为虚函数可以保证当我们<code>new</code>一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p><p>此外，C++默认的析构函数不是虚函数是因为虚函数需要额外的<strong>虚函数表和虚表指针</strong>，<strong>占用额外的内存</strong>。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p></li></ol><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字<code>static</code>，称为静态成员，也称类成员。调用方式：<code>类名::静态成员</code>，不需要创建实例对象</p><ol><li>静态成员变量：所有对象共享同一份数据；在编译阶段分配内存；类内声明，类外初始化</li><li>静态成员函数：所有对象共享同一个函数；静态成员函数只能访问静态成员变量</li></ol><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h4><ol><li><code>this指针</code>指向被调用的成员函数所属的对象</li><li><strong>作用：</strong><ol><li>当形参和成员变量同名时，可用<code>this</code>指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code></li></ol></li></ol><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ol><li><p><strong>空类</strong></p><ul><li>首先，空类大小为1字节，空类中编译器插入一个char类型，用来标识这个class不同实体在内存中配置独一无二地址</li><li>默认函数有：（1）构造函数；（2）析构函数；（3）拷贝构造函数；（4）赋值运算符</li></ul></li><li><h5 id="struct与class的区别"><a href="#struct与class的区别" class="headerlink" title="struct与class的区别"></a><code>struct</code>与<code>class</code>的区别</h5><p>在C++中，都可以用<code>struct</code>和<code>class</code>定义类，都可以继承。</p><p>区别在于：</p><ol><li><strong>访问权限</strong>：<code>struct</code>的默认<strong>继承权限和默认访问权限</strong>是<code>public</code>，而<code>class</code>的默认继承权限和默认访问权限是<code>private</code></li><li><strong>扩展</strong>：<code>class</code>还可以定义模板类形参，例如<code>template &lt;class T, int i&gt;</code>。</li></ol></li><li><h5 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h5><p><strong>浅拷贝</strong>：简单的赋值拷贝操作</p><p><strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝操作</p></li><li><p><code>=</code><strong>赋值还是调用拷贝函数</strong></p><p>如果一个新对象未被定义，调用的是拷贝构造函数  <code>Class c1 = c2</code></p><p>如果没有新对象被定义，则调用的是赋值操作 <code>Class c1;   c1 = c2;</code></p></li><li><p><strong>空指针对象调用</strong></p><p>空指针，可以调用成员函数，但是如果成员函数中用到了<code>this指针</code>就不可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> method&#123;<br>    Person *p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">methodName</span>(); <span class="hljs-comment">// 空指针，可以调用成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>如何定义一个只能在堆上（栈上）生成对象的类</strong></p><ol><li><p><strong>只能在堆上</strong>：将析构函数设置为私有</p><p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p></li><li><p><strong>只能在栈上</strong>：将<code>new</code>和<code>delete</code>重载为私有</p><p>原因：在堆上生成对象，使用<code>new</code>关键词操作，其过程分为两阶段：第一阶段，使用<code>new</code>在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将<code>new</code>操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p></li></ol></li><li><p><strong><code>delete this</code>合法</strong></p><ol><li>必须保证<code>this</code>对象是通过 <code>new</code>（不是 <code>new[]</code>、不是<code>placement new</code>、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 <code>this</code> 的成员函数，必须是最后调用的</li></ol></li><li><p><strong>如何让一个类不能实例化？</strong></p><p>将类定义为抽象基类或者将构造函数声明为<code>private</code></p></li><li><p><strong>如何让main函数之前执行函数？</strong></p><ul><li><p>C++中在<code>main函数</code>之前定义一个全局对象，调用构造函数。</p></li><li><p>C语言中使用gcc的<code>attribute</code>关键字，声明<code>constructor</code>和<code>destructor</code></p></li></ul></li></ol><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元的目的就是让一个函数或者类<strong>访问另一个类中私有成员</strong>，关键字<code>friend</code>，友元能访问私有成员，破坏封装性，友元声明的形式及数量不受限制</p><p><strong>特性：</strong></p><ol><li>友元函数不是类的成员，不带<code>this指针</code></li><li>友元关系<strong>不能被继承</strong>，友元关系是<strong>单向的</strong>，友元关系<strong>不具有传递性</strong></li></ol><p>友元的<strong>三种实现</strong>：<strong>全局函数做友元，类做友元，成员函数做友元</strong></p><ol><li><p><strong>全局函数做友元</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">friendMethod</span><span class="hljs-params">(Clazz *clazz)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    string value;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">friendMethod</span><span class="hljs-params">(Clazz *clazz)</span></span>&#123;<br>    cout &lt;&lt; clazz-&gt;value &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类做友元</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clazz</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Claxx</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>成员函数做友元</strong></p></li></ol><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载概念：<strong>对已有的运算符重新进行定义</strong>，赋予其另一种功能，以适应不同的数据类型</p><table><thead><tr><th>可重载的运算符</th><th></th><th>不可重载运算符</th><th></th></tr></thead><tbody><tr><td>双目运算符</td><td><code>+ - * / %</code></td><td>成员访问运算符</td><td><code>.</code></td></tr><tr><td>关系运算符</td><td><code>== != &gt;= &lt;= &gt; &lt; </code></td><td>成员指针访问运算符</td><td><code>.*  -&gt;</code></td></tr><tr><td>逻辑运算符</td><td>&#96;</td><td></td><td>&amp;&amp; !&#96;</td></tr><tr><td>单目运算符</td><td><code>+ - * &amp;</code></td><td>条件运算符</td><td><code>? :</code></td></tr><tr><td>自增运算符</td><td><code>++ —</code></td><td>长度运算符</td><td><code>sizeof</code></td></tr><tr><td>位运算符</td><td>&#96;</td><td>&amp; ~ ^ &lt;&lt; &gt;&gt;&#96;</td><td>预处理符号</td></tr><tr><td>赋值运算符</td><td>&#96;&#x3D; +&#x3D; - &#x3D; *&#x3D; &#x2F;&#x3D; &amp;&#x3D;</td><td>&#x3D; ^&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;&#96;</td><td></td></tr><tr><td>空间申请与释放</td><td><code>new delete new[] delete[]</code></td><td></td><td></td></tr><tr><td>其它运算符</td><td><code>() -&gt; , []</code></td><td></td><td></td></tr></tbody></table><p><strong>类成员函数</strong>作双目运算符重载时，参数一般只为一个，左侧实参由this指针表现出来</p><p>特别地：<strong>调用运算符重载重载运算符<code>()</code></strong>,相当于可以将类做为函数使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Complex complex;<br>    cout &lt;&lt; <span class="hljs-built_in">complex</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &lt;&lt; endl; <span class="hljs-comment">//对象做函数来使用</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>相同优先级中，按结合性进行结合。大多数运算符结合性是<strong>从左到右</strong>，只有三个优先级是<strong>从右至左</strong>结合的，它们是<strong>单目运算符、条件运算符、赋值运算符</strong></p><p><strong>基本的优先级（共十八级）</strong>：</p><ol><li>指针最优，单目运算优于双目运算。如正负号。</li><li>先算术运算，后移位运算，最后位运算。请特别注意：1 &lt;&lt; 3 + 2 &amp; 7等价于 (1 &lt;&lt; (3 + 2))&amp;7.</li><li>逻辑运算最后结合。</li></ol><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><ol><li><strong>逻辑左移</strong>与<strong>算数左移</strong>，右边统一添0</li><li>逻辑右移，左边统一添0</li><li>算数右移，左边添加的数和符号有关，例如 <code>[1]0110</code> 左移一位 <code>[1]1011</code></li></ol><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<strong>关键字</strong>：<code>public, protected, private</code>。不写默认为 <code>private</code></p><ol><li><code>public</code>：可以被任意实体访问</li><li><code>protected</code>：只允许被子类及本类的成员函数访问</li><li><code>private</code>：只允许被本类的成员函数、友元类或友元函数访问</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>下级别的成员除了拥有上一级的共性，还有自己的特性。<strong>可以减少重复的代码</strong></p><p><strong>语法：</strong><code>class 子类 : 继承方式 父类;</code></p><p><strong>继承模型</strong>：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p><p>**构造与析构：**继承后先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p><p><strong>同名成员：</strong></p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中</li></ol><h5 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h5><ol><li><strong>公共继承</strong><code>public</code>：基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的</li><li><strong>保护继承</strong><code>protect</code>：基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的</li><li><strong>私有继承</strong><code>private</code>：基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问</li></ol><p><strong>继承源</strong></p><ol><li>单继承：指个每个派生类只能直接继承一个基类的特征</li><li>多继承：<code>class 子类 : 继承方式 父类1, 继承方式 父类2, ...</code>，多继承可能会引发子类中有同名成员出现，需要加作用域区分</li></ol><p><strong>虚继承</strong></p><p><code>class Sheep : virtual public Animal {};</code></p><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性)。被虚继承的类被称为<strong>虚基类</strong></p><p><strong>实现原理</strong>：通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针和虚基类表（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。实际上，vbptr 指的是虚基类表指针，该指针指向了一个虚基类表，虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><p><strong>无法被继承</strong>：有三类成员函数不能被子类继承，分别是：构造函数（包括拷贝构造）、析构函数、赋值运算符重载函数。对于静态成员基类和其派生类共享该基类的静态成员变量内存！</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h4 id="多态分类："><a href="#多态分类：" class="headerlink" title="多态分类："></a><strong>多态分类：</strong></h4><ol><li><p>**静态多态：**重载， 函数重载和运算符重载属于静态多态，复用函数名，编译阶段确定函数地址</p></li><li><p><strong>动态多态：</strong> <strong>动态多态是用虚函数机制实现的</strong>。一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;animal speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;cat speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>();<br>    animal-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// cout &lt;&lt; cat speak &lt;&lt; endl;</span><br>    <span class="hljs-keyword">delete</span> animal;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>参数多态性</strong>（编译期）：类模板、函数模板</p></li><li><p><strong>强制多态</strong>（编译期&#x2F;运行期）：基本类型转换、自定义类型转换</p></li></ol><h4 id="动态绑定实现原理"><a href="#动态绑定实现原理" class="headerlink" title="动态绑定实现原理"></a>动态绑定实现原理</h4><ol><li><strong>虚函数指针</strong>：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li><strong>虚函数表</strong>：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li><li>编译器发现我们的类中有虚函数的时候，编译器会创建一张<strong>虚函数表</strong>，把虚函数的函数入口地址放到虚函数表中，并且在类中添加一个指针，即<strong>虚函数指针</strong>(缩写<code>vptr</code>)，指向对象的虚函数表。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。在多态调用的时候，根据<code>vptr</code>指针，找到虚函数表来实现动态绑定。使用了虚函数，会增加访问内存开销，降低效率。</li></ol><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>虚函数的实现<code>virtual 类型 函数名(参数列表)</code>：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个<strong>虚函数表，表中放了虚函数的地址</strong>，实际的虚函数在代码段中。</p><p>静态函数不能定义为虚函数：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他不归某一个对象所有，所以它没有动态绑定的必要，不能定义为虚函数</p><ul><li><code>final</code>修饰的函数必须是虚函数，加了<code>final</code>表示虚函数无法重写了</li><li><code>override</code>,声明重写父类的方法，前提是要有virtual关键字修饰函数。</li></ul><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p><strong>语法：</strong><code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。一个函数一旦声明为虚函数，那么不管你是否加上virtual 修饰符，它在所有派生类中都成为虚函数。</p><h4 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h4><ol><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li><li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li><li>虚基类是虚继承中的基类，具体见下文虚继承。</li></ol><h4 id="重写-重载-重定义"><a href="#重写-重载-重定义" class="headerlink" title="重写 重载 重定义"></a>重写 重载 重定义</h4><ol><li><strong>重载</strong>：同一作用域的同名函数<ul><li>同一个作用域</li><li>参数个数，参数顺序，参数类型不同</li><li>和函数返回值，没有关系</li><li><code>const</code>也可以作为重载条件 <code>//do(const Teacher&amp; t){} do(Teacher&amp; t)</code></li></ul></li><li><strong>重定义</strong>（隐藏）<ul><li>有继承</li><li>子类（派生类）重新定义父类（基类）的同名成员（非<code>virtual</code>函数）</li></ul></li><li><strong>重写</strong>（覆盖）<ul><li>有继承</li><li>子类（派生类）重写父类（基类）的<code>virtual函数</code></li><li>函数返回值，函数名字，函数参数，必须和基类中的虚函数一致</li><li>子类中函数跟基类中函数名字相同，基类中无virtual关键字，则无论函数参数是否一样，基类中函数都将被子类函数隐藏，此时，子类无法直接调用基类同名函数，但可以通过作用域::来调用基类中被隐藏的函数</li></ul></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong>。<strong>当类中有了纯虚函数，这个类也称为抽象类</strong></p><p><strong>特点：</strong></p><ol><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ol><h5 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h5><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，将父类中的析构函数改为虚析构或者纯虚析构</p><ol><li>**相同点：**用来解决通过父类指针释放子类对象</li><li><strong>区别：</strong><ul><li>虚析构语法：<code>virtual ~类名(){}</code>，纯虚析构语法：<code>virtual ~类名() = 0; </code></li><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul></li></ol><h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><p>可以理解为仅含有纯虚函数的抽象类，C++中没有为接口提供语言元素（例如Java的Interface），因此所说的接口一般是指概念上的设计</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>为了提高复用性，<strong>将类型参数化</strong>。作用：(1)实现泛型；(2)对参数进行限制；(3)根据参数进行优化；</p><p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。<code> &lt;&gt;</code>括号中的参数叫模板形参，<code>template</code>和<code>class</code>是关键字，<code>class</code>可以用<code>typename </code>关键字代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> </span>&#123;&#125;<span class="hljs-comment">//函数声明或定义</span><br></code></pre></td></tr></table></figure><h5 id="使用函数模板"><a href="#使用函数模板" class="headerlink" title="使用函数模板"></a>使用函数模板</h5><ol><li>自动类型推导</li><li>显示指定类型 <code>mySwap&lt;int&gt;(a, b); </code></li></ol><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>建立一个通用类，类中的成员数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。用于解决多个功能相同、数据类型不同的类需要重复定义的问题。类模板中的成员函数在调用时才创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-comment">//类</span><br></code></pre></td></tr></table></figure><h5 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h5><ol><li><p><strong>指定传入的类型</strong> <code>void myPrint(Person&lt;string, int&gt; &amp;p) </code>,使用比较广泛</p></li><li><p><strong>参数模板化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(Person&lt;T1, T2&gt; &amp;p)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>整个类模板化</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">myPrint</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h5><p>当子类继承的父类是一个类模板时，子类在声明的时候存在两种情况</p><ol><li>要指定出父类中T的类型，如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ol><h5 id="类模板与虚函数"><a href="#类模板与虚函数" class="headerlink" title="类模板与虚函数"></a>类模板与虚函数</h5><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h5 id="类模板与模板类"><a href="#类模板与模板类" class="headerlink" title="类模板与模板类"></a>类模板与模板类</h5><ul><li>类模板的重点是模板，建立一个通用类专门产生类，例如：<code>vector, list, map</code></li><li>模板类的重点是类。表示的是由一个模板生成而来的类。例如：<code>vector&lt;int&gt; , vector&lt;string&gt;</code></li></ul><h4 id="函数模板与类模板的区别"><a href="#函数模板与类模板的区别" class="headerlink" title="函数模板与类模板的区别"></a>函数模板与类模板的区别</h4><ol><li><p>类模板没有自动类型推导的使用方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Person p1(&quot;name&quot;, 20) //错误， 类模板使用时候，不可以使用自动类型推导</span><br><span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">20</span>)</span> <span class="hljs-comment">//正确，必须使用显示类型指定方式</span></span><br></code></pre></td></tr></table></figure></li><li><p>类模板在模板参数列表中可以有默认参数， 即<code>template&lt;class ageType, class nameType = string&gt;</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ more</title>
    <link href="/2022/04/30/C++more/"/>
    <url>/2022/04/30/C++more/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>C++深入</font></center><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p><ol><li><strong>预处理阶段</strong>：对源代码文件中文件包含关系（<strong>头文件</strong>）、预编译语句（<strong>宏定义</strong>）进行分析和替换，生成预编译文件。</li><li><strong>编译阶段</strong>：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</li><li><strong>汇编阶段</strong>：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</li><li><strong>链接阶段</strong>：将多个目标文件及所需要的库连接成最终的可执行目标文件</li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h4 id="C-内存管理分配"><a href="#C-内存管理分配" class="headerlink" title="C++内存管理分配"></a>C++内存管理分配</h4><p>在C++中将内存分为5个区：栈区、堆区、自由存储区、全局&#x2F;静态存储区、常量存储区</p><ol><li><strong>栈</strong>：在执行函数时，<strong>函数内局部变量</strong>的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</li><li><strong>堆</strong>：由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li><li><strong>程序代码区</strong>：存放函数体（类的成员函数、全局函数） 的二进制代码</li><li><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区</li><li><strong>常量存储区</strong>：存放的是常量，不允许修改</li></ol><h4 id="程序在内存中的分区"><a href="#程序在内存中的分区" class="headerlink" title="程序在内存中的分区"></a>程序在内存中的分区</h4><ol><li><strong>BSS段(bss segment)</strong>：通常是指用来存放程序中未初始化的全局变量的一块内存区域， 为0也为未初始化。</li><li><strong>数据段(data segment)</strong>：通常是指用来存放程序中已初始化的全局变量的一块内存区域。</li><li><strong>代码段(code segment&#x2F;text segment)</strong>：代码段（通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li><li><strong>堆（heap）</strong>：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li><strong>栈(stack)</strong>：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。</li></ol><h4 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h4><ol><li>**管理方式：**栈是由编译器自动管理；堆分配释放工作由程序员控制，容易产生memory leak。</li><li>**空间大小：**一般来讲在 32 位系统下，堆内存可以达到4G的空间，堆内存几乎是没有什么限制的。栈有一定的空间大小的</li><li>**碎片问题：**堆中频繁的<code>new/delete</code>势必会造成内存空间的不连续，从而造成大量的碎片。栈是先进后出的队列，不可能有内存块从栈中间弹出</li><li>**生长方向：**堆的生长方向是向上的，向着内存地址增加的方向；栈的生长方向是向下的，向着内存地址减小的方向增长。</li><li>**分配方式：**堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li><li>**分配效率：**栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C&#x2F;C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</li></ol><h4 id="内存泄露（memory-leak）"><a href="#内存泄露（memory-leak）" class="headerlink" title="内存泄露（memory leak）"></a>内存泄露（memory leak）</h4><p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><h5 id="内存泄漏的分类："><a href="#内存泄漏的分类：" class="headerlink" title="内存泄漏的分类："></a>内存泄漏的分类：</h5><ol><li><strong>堆内存泄漏</strong> (Heap leak)：对内存指的是程序运行中根据需要分配通过<code>malloc,realloc new</code>等从堆中分配的一块内存，再是完成后必须通过调用对应的 <code>free</code>或者<code>delete</code> 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生<code>Heap Leak</code>.</li><li><strong>系统资源泄露</strong>(Resource Leak)：主要指程序使用系统分配的资源比如<code>Bitmap,handle ,SOCKET</code>等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li><li><strong>没有将基类的析构函数定义为虚函数</strong>：当基类指针指向子类对象时，如果基类的析构函数不是<code>virtual</code>，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li></ol><h5 id="判断内存泄露"><a href="#判断内存泄露" class="headerlink" title="判断内存泄露"></a>判断内存泄露</h5><ol><li>可以使用linux环境下的内存泄漏检查工具Valgrind，mtrace</li><li>写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，</li></ol><h4 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h4><p>段错误通常<strong>发生在访问非法内存地址</strong>的时候，具体来说分为以下几种情况：</p><ol><li>使用野指针</li><li>试图修改字符串常量的内容</li></ol><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p><code>malloc</code>函数用于动态分配内存</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ol><li><strong>内存申请</strong>：<code>malloc</code>其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。</li><li><strong>链式管理</strong>：<code>malloc</code>采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</li><li><strong>分配合并</strong>：当进行内存分配时，<code>malloc</code>会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，<code>malloc</code>采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</li></ol><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p><code>malloc</code>在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配</p><h2 id="网络编程——NIO"><a href="#网络编程——NIO" class="headerlink" title="网络编程——NIO"></a>网络编程——NIO</h2><h4 id="Socket连接"><a href="#Socket连接" class="headerlink" title="Socket连接"></a>Socket连接</h4><p><strong>socket</strong>：顾名思义就是套接字的意思，用于描述地址和端口，是一个通信链的句柄。应用程序通过socket向网络发出请求或者回应。</p><p><strong>服务端</strong>：建立socket，声明自身的port和IP，并绑定到socket，使用listen监听，然后不断用accept去查看是否有连接。如果有，捕获socket，并通过recv获取消息的内容，通信完成后调用closeSocket关闭这个对应accept到的socket。如果不需要等待任何客户端连接，那么用closeSocket直接关闭自身的socket。</p><p><strong>客户端</strong>：建立socket，通过端口号和地址确定目标服务器，使用Connect连接到服务器，send发送消息，等待处理，通信完成后调用closeSocket关闭socket。</p><h4 id="传统多线程模型"><a href="#传统多线程模型" class="headerlink" title="传统多线程模型"></a>传统多线程模型</h4><ol><li><strong>原始型</strong>：每个请求都将导致服务器阻塞。即服务器用一个while循环，不断监听端口是否有新的套接字连接，如果有，那么就调用一个处理函数处理，那么后面的请求只能被阻塞。导致无法并发，效率太低，服务器的吞吐量太低</li><li><strong>多线程并发模型</strong>：对于每一个请求都分发给一个线程，每个线程中都独自处理上面的流程。但是创建线程是需要比较高的系统资源的，如果连接数太高，系统无法承受，而且线程的反复创建-销毁也需要代价</li><li><strong>多线程并发模型连接池</strong>：使用一个连接池来管理上述的线程，避免反复创建和销毁</li></ol><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO复用模型在阻塞IO模型上多了一个<code>select</code>函数，<code>select</code>函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。在单线程模型中，可以采用I&#x2F;O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件</p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>IO多路复用就是我们说的<code>select，poll，epoll。select/epoll</code>的好处就在于单个进程就可以同时处理多个网络连接的IO。它的基本原理就是<code>select，poll，epoll</code>这些函数会不断的轮询所负责的所有<code>socket</code>。也就是说，I&#x2F;O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select()</code>函数就可以返回。</p><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><ol><li><p><code>select</code></p><p><code>select</code>：是最初解决IO阻塞问题的方法。用结构体<code>fd_set</code>来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p><p><strong>问题</strong>：</p><ul><li>内置数组的形式使得<code>select</code>的最大文件数与<code>FD_SIZE</code>受限</li><li>每次调用<code>select</code>前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用<code>select</code>后，都需要将fd从内核态拷贝到用户态；</li><li>轮寻排查当文件描述符个数很多时，效率很低；</li></ul></li><li><p><code>poll</code></p><p><code>poll</code>通过一个<strong>可变长度的数组</strong>解决了<code>select</code>文件描述符受限的问题。<strong>数组中元素是结构体</strong>，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。<code>poll</code>解决了<code>select</code>重复初始化的问题，但是轮寻排查的问题未能解决。</p></li><li><p><code>epoll</code></p><p>轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，<code>epoll</code>采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。<code>epoll</code>对文件描述符的操作有两种模式：<code>LT</code>和<code>ET</code></p><p><strong>模式</strong></p><ul><li><p><code>LT</code>模式，默认模式</p><p><code>LT(level triggered)</code>是缺省的工作方式，并且同时支持<code>block</code>和<code>no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p></li><li><p><code>ET</code>模式</p><p><code>ET(edge-triggered)</code>是高速工作方式<code>only-once</code>，只支持<code>no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过<code>epoll</code>告诉你。然后它会假设你知道文件描述符已经就绪，并且不会为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 并发</title>
    <link href="/2022/04/30/C++parallel/"/>
    <url>/2022/04/30/C++parallel/</url>
    
    <content type="html"><![CDATA[<center><font size = 45>C++并发</font></center><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p><strong>并发</strong>：同一时间段，多个任务都在执行 (单位时间内不一定同时执行)，宏观上同时执行</p></li><li><p><strong>并行</strong>：单位时间内，多个任务同时执行</p></li><li><p><strong>进程</strong></p><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p></li><li><p><strong>线程</strong></p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的资源</p></li><li><p><strong>上下文切换</strong></p><p>CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p></li><li><p><strong>同步</strong></p><p>发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做，等前一件做完了才能做下一件事.</p></li><li><p><strong>异步</strong></p><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者</p></li><li><p><strong>阻塞</strong> ：阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p></li><li><p><strong>非阻塞</strong>：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p></li><li><p><strong>死锁</strong>：一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。</p></li><li><p><strong>饥饿</strong>：一个进程由于其他进程总是优先于它而被无限期拖延。</p></li><li><p><strong>临界资源</strong>：是一次仅允许一个进程使用的共享资源。</p></li></ol><h5 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h5><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p><h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h5><ol><li><p><strong>悲观锁</strong>，<strong>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁</strong>，确保数据不会被别的线程修改</p></li><li><p><strong>乐观锁</strong> ，**乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，**只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，<strong>最常采用的是CAS算法</strong></p></li><li><p><strong>CAS</strong>（Compare And Swap）</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。即每次修改时都需要拿期望值去比较</p></li></ol><h5 id="阻塞非阻塞同步异步的区别"><a href="#阻塞非阻塞同步异步的区别" class="headerlink" title="阻塞非阻塞同步异步的区别"></a>阻塞非阻塞同步异步的区别</h5><p>同步和异步关注的是消息通信机制，而阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态</p><h2 id="进程的互斥、同步、通信"><a href="#进程的互斥、同步、通信" class="headerlink" title="进程的互斥、同步、通信"></a>进程的互斥、同步、通信</h2><h4 id="互斥——竞争关系"><a href="#互斥——竞争关系" class="headerlink" title="互斥——竞争关系"></a>互斥——竞争关系</h4><p>系统中的多个进程之间彼此无关，它们并不知道其他进程的存在，并且也不受其他进程执行的影响。由于这些进程共用了一套计算机系统资源，因而， 必然要出现多个进程竞争资源的问题。当多个进程竞争共享硬设备、存储器、处理器 和文件等资源时，操作系统必须协调好进程对资源的争用。<br>进程的互斥（mutual exclusion ）是解决进程间竞争关系( 间接制约关系) 的手段。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p><h4 id="同步——协作关系"><a href="#同步——协作关系" class="headerlink" title="同步——协作关系"></a>同步——协作关系</h4><p>某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协 调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行。这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。</p><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，通过修改信号量，进程之间可建立起联系，相互协调运行和协同工作。但是信号量与PV操作只能传递信号，没有传递数据的能力。有些情况下进程之间交换的信息量虽很少，例如，仅仅交换某个状态信息，但很多情况下进程之间需要交换大批数据，例如，传送一批信息或整个文件，这可以通过一种新的通信机制来完成，<strong>进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。</strong></p><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><ol><li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h4 id="线程间的同步的方式"><a href="#线程间的同步的方式" class="headerlink" title="线程间的同步的方式"></a>线程间的同步的方式</h4><ol><li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操</li></ol><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><h4 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h4><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol><li>新建状态：创建了一个线程之后,该线程就处于新建状态</li><li>就绪状态：启动方法之后,该线程处于就绪状态</li><li>运行状态 ：处于就绪状态的线程获得了CPU资源，开始运行</li><li>阻塞状态：线程主动放弃CPU资源 </li><li>线程死亡：线程结束</li></ol><h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><strong>死锁必须具备以下四个条件</strong>：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ol><h4 id="避免线程死锁"><a href="#避免线程死锁" class="headerlink" title="避免线程死锁"></a>避免线程死锁</h4><p>我上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p><ol><li><p><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><h2 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h2><h5 id="pthread-h"><a href="#pthread-h" class="headerlink" title="pthread.h"></a><code>pthread.h</code></h5><p><code>pthread.h</code>是标准库，C++11没有添加多线程之前的在Linux上用的多线程库</p><h5 id="windows-h"><a href="#windows-h" class="headerlink" title="windows.h"></a><code>windows.h</code></h5><p>在windows上的多线程支持要包含<code>windows.h</code></p><h5 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a><code>std::thread</code></h5><p>原先使用多线程只能用系统的API，无法解决跨平台问题。从C++11开始语言层面上的多线程，标准库里已经包含了对线程的支持，<code>std::thread</code>是C++11标准库中的多线程的支持库C++11 新标准中引入了五个头文件来支持多线程编程</p><p>它们分别是 <code>&lt;thread&gt;, &lt;mutex&gt;, &lt;condition_variable&gt;</code> 和 <code>&lt;future&gt; &lt;atomic&gt;,</code>。</p><img src="../images/image-20200814171948633.png"/><ol><li><code>&lt;thread&gt;</code>：该头文件主要声明了 <code>std::thread</code> <strong>线程类</strong>，另外 <code>std::this_thread</code> 命名空间也在该头文件中。</li><li><code>&lt;future&gt;</code>：<strong>异步类相关</strong>，该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类，另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中。</li><li><code>&lt;mutex&gt;</code>：该头文件主要声明了<strong>与互斥量(Mutex)相关的类</strong>，包括 <code>std::mutex_*</code> 一系列类，<code>std::lock_guard</code>, <code>std::unique_lock</code>, 以及其他的类型和函数，主要用于线程同步</li><li><code>&lt;condition_variable&gt;</code>：该头文件主要声明了<strong>与条件变量相关的类</strong>，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</li><li><code>&lt;atomic&gt;</code>：该头文主要声明了两个类, <code>std::atomic</code> 和 <code>std::atomic_flag</code>，另外还声明了一套 C 风格的原子类型和与 C 兼容的<strong>原子操作的函数</strong>。</li></ol><h2 id="thread-线程"><a href="#thread-线程" class="headerlink" title="thread 线程"></a>thread 线程</h2><p><code>std::thread</code> <strong>代表了一个线程对象，</strong> 在 <code>&lt;thread&gt;</code> 头文件中声明。<code>&lt;thread&gt;</code> 头文件主要声明了 <code>std::thread</code> 类，声明了 <code>swap</code>，<code>get_id</code>，<code>yield</code>，<code>sleep_until</code> 以及 <code>sleep_for</code> 等辅助函数</p><table><thead><tr><th>构造函数</th><th>声明</th><th>意义</th></tr></thead><tbody><tr><td>默认构造函数</td><td>thread() noexcept;</td><td>创建一个空的 <code>std::thread</code> 执行对象</td></tr><tr><td>初始化构造函数</td><td>template &lt;class Fn, class… Args&gt; explicit thread(Fn&amp;&amp; <strong>fn</strong>, Args&amp;&amp;… <strong>args</strong>);</td><td>创建一个 <code>std::thread</code> 对象，该 <code>std::thread</code> 对象可被 <code>joinable</code>，新产生的线程会调用 <code>fn</code> 函数，该函数的参数由 <code>args</code> 给出。</td></tr><tr><td>拷贝构造函数 [deleted]</td><td>thread(const thread&amp;) &#x3D; delete;</td><td>被禁用，意味着 <code>std::thread</code> 对象不可拷贝构造。</td></tr><tr><td><code>Move</code> 构造函数</td><td>thread(thread&amp;&amp; x) noexcept;</td><td><code>move </code>构造函数，调用成功之后 <code>x</code> 不代表任何 <code>std::thread</code> 执行对象。详情见右值引用、<code>std::move</code></td></tr></tbody></table><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ol><li><p><code>std::thread  joinable()</code>函数，用于检测线程是否有效。相同线程不能被<code>join()</code>和<code>detach()</code>两次</p><p><code>joinable</code>：代表该线程是可执行线程。</p><p><code>not-joinable </code>：通常一下几种情况会导致线程成为<code>not-joinable</code></p><ul><li>由<code>thread</code>的缺省构造函数构造而成(<code>thread()</code>没有参数)</li><li>该<code>thread</code>被<code>move</code>过（包括<code>move</code>构造和<code>move</code>赋值）</li><li>该线程调用过<code>join</code>或者<code>detach</code></li></ul></li><li><p><code>join</code>：创建线程执行线程函数，调用该函数会阻塞当前线程，直到线程执行完<code>join</code>才返回。主线程等待子线程</p></li><li><p><code>detach</code>: 将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。<code>detach</code>调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的<code>std::thread</code>对象失去对目标线程的关联，无法再通过<code>std::thread</code>对象取得该线程的控制权。主线程不等子线程</p></li><li><p><code>get_id</code>：得到当前线程ID</p></li><li><p><code>swap</code>: 交换两个线程对象所代表的底层句柄。</p></li></ol><h4 id="std-this-thread-函数"><a href="#std-this-thread-函数" class="headerlink" title="std::this_thread 函数"></a><code>std::this_thread</code> 函数</h4><ol><li><code>get_id</code>：得到当前线程ID</li><li><code>yield</code>: 当前线程放弃执行，操作系统调度另一线程继续执行。</li><li><code>sleep</code>：<code>sleep_until</code> 以及 <code>sleep_for</code> 线程休眠至某个指定的时刻或某个时间片段，该线程才被重新唤醒。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; executing\n&quot;</span>;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 2 executing\n&quot;</span>;<br>        ++n;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    std::thread t1; <span class="hljs-comment">// t1 is not a thread</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(f1, n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// pass by value</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(f2, std::ref(n))</span></span>; <span class="hljs-comment">// pass by reference</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t4</span><span class="hljs-params">(std::move(t3))</span></span>; <span class="hljs-comment">// t4 is now running f2(). t3 is no longer a thread</span><br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">4.</span><span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Final value of n is &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mutex-互斥量"><a href="#Mutex-互斥量" class="headerlink" title="Mutex 互斥量"></a>Mutex 互斥量</h2><h4 id="互斥量与信号量"><a href="#互斥量与信号量" class="headerlink" title="互斥量与信号量"></a>互斥量与信号量</h4><ol><li><p><strong>互斥量</strong></p><p><code>Mutex</code> <strong>又称互斥量</strong>也称之为互斥锁，用来保证在任一时刻只能有一个线程访问该对象，每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束后解锁，C++11 中与<code>Mutex</code><strong>相关的类（包括锁类型）和函数</strong>都声明在 <code>&lt;mutex&gt;</code> 头文件中</p></li><li><p><strong>信号量</strong></p><p><strong>互斥量用于线程的互斥</strong>，<strong>信号量用于线程的同步。<strong>信号量是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源，因此</strong>互斥量值只能为0&#x2F;1，信号量值可以为非负整数</strong></p></li></ol><h4 id="Mutex-系列类"><a href="#Mutex-系列类" class="headerlink" title="Mutex 系列类"></a>Mutex 系列类</h4><ol><li><p><code>std::mutex</code></p><p>**最基本的 Mutex 类，**该类提供了最基本的上锁和解锁操作。同时，基本的互斥量不允许某个线程在已获得互斥量的情况下重复对该互斥量进行上锁操作，所以重复上锁将会导致死锁（结果通常未定义的）</p></li><li><p><code>std::recursive_mutex</code></p><p><strong>递归 Mutex 类</strong>，与 <code>std::mutex</code> 功能基本相同，但是允许互斥量的拥有者（通常是某个线程）重复对该互斥量进行上锁操作而不会产生死锁，但必须保证上锁和解锁的次数相同</p></li><li><p><code>std::time_mutex</code></p><p>**定时 Mutex 类，**与 <code>std::mutex</code> 功能基本相同，但是提供了两个额外的定时上锁操作，<code>try_lock_for</code> 和 <code>try_lock_until</code>，即某个线程在规定的时间内对互斥量进行上锁操作，如果在规定的时间内获得了锁则返回 <code>true</code>, 超时则返回 <code>false</code>，在本章后面的内容中我会介绍<code>try_lock_for</code> 和 <code>try_lock_until</code>两个上锁函数之间细微的差异</p></li><li><p><code>std::recursive_timed_mutex</code></p><p><strong>定时递归 Mutex 类</strong>，既提供了重复上锁功能，又提供了定时上锁的特性（即在规定的时间内没有获得锁则返回 <code>false</code>），相当于 <code>std::recursive_mutex</code> 和 <code>std::time_mutex</code> 的组合</p></li></ol><h4 id="Lock-类"><a href="#Lock-类" class="headerlink" title="Lock 类"></a>Lock 类</h4><p>C++11 标准中定义了两种与互斥量相关的 RAII（资源获取即初始化）技术。</p><p>RAII原理：如果希望保持对某个重要资源的跟踪，那么创建一个对象，并将资源生命周期与对象的生命周期相关联。最简单的RAII形式是创建这样一个对象：构造函数中获取一份资源，析构函数中则释放资源</p><ol><li><p><code>std::lock_guard</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>与 Mutex RAII 相关，方便线程对互斥量上锁。即在某个 <code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code> 的生命周期结束之后，它所管理的锁对象会被解锁。<code>lock_guard</code> 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 <code>lock_guard</code>的生命周期结束之后，它所管理的锁对象会被解锁，类似于智能指针，这也就是RAII</p></li><li><p><code>std::unique_lock</code></p><p>对象以独占所有权的方式管理 <code>mutex</code> 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权。与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。提供更多的函数因此更加灵活</p><ul><li>上锁&#x2F;解锁操作：<code>lock</code>，<code>try_lock</code>，<code>try_lock_for</code>，<code>try_lock_until</code> 和 <code>unlock</code></li><li>修改操作：移动赋值(<code>move assignment</code>)(前面已经介绍过了)，交换(<code>swap</code>)（与另一个 <code>std::unique_lock</code> 对象交换它们所管理的 <code>Mutex</code> 对象的所有权），释放(<code>release</code>)（返回指向它所管理的 Mutex 对象的指针，并释放所有权）</li><li>获取属性操作：<code>owns_lock</code>（返回当前 <code>std::unique_lock</code> 对象是否获得了锁）、<code>operator bool()</code>（与 <code>owns_lock</code> 功能相同，返回当前 <code>std::unique_lock</code> 对象是否获得了锁）、<code>mutex</code>（返回当前 <code>std::unique_lock</code> 对象所管理的 <code>Mutex</code> 对象的指针）。</li></ul></li></ol><h4 id="锁类型相关的Tag类"><a href="#锁类型相关的Tag类" class="headerlink" title="锁类型相关的Tag类"></a>锁类型相关的Tag类</h4><ol><li><code>std::adopt_lock_t</code>，一个空的标记类，定义如下：<code>struct adopt_lock_t {};</code>，该类型的常量对象<code>adopt_lock</code>（<code>adopt_lock</code> 是一个常量对象，定义如下：<code>constexpr adopt_lock_t adopt_lock {};</code>，<code>constexpr</code> 是 C++11 中的新关键字） 通常作为参数传入给 <code>unique_lock</code> 或 <code>lock_guard</code> 的构造函数。</li><li><code>std::defer_lock_t</code>，一个空的标记类，定义如下：<code>struct defer_lock_t {};</code>，该类型的常量对象<code>defer_lock</code>（<code>defer_lock</code> 是一个常量对象，定义如下：<code>constexpr defer_lock_t defer_lock {};</code>） 通常作为参数传入给<code>unique_lock</code> 或 <code>lock_guard</code> 的构造函数。</li><li><code>std::try_to_lock_t</code>，一个空的标记类，定义如下：<code>struct try_to_lock_t {};</code>，该类型的常量对象<code>try_to_lock</code>（<code>try_to_lock</code> 是一个常量对象，定义如下：<code>constexpr try_to_lock_t try_to_lock {};</code>） 通常作为参数传入给<code>unique_lock</code> 或 <code>lock_guard</code> 的构造函数。。</li></ol><h4 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h4><ol><li><code>std::try_lock</code>，尝试同时对多个互斥量上锁。线程调用也会出现<code>lock</code>的三种情况</li><li><code>std::lock</code>，同时对多个互斥量上锁。调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：<ul><li>如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。</li><li>如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住</li><li>如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)</li></ul></li><li><code>unlock</code>， 解锁，释放对互斥量的所有权。</li><li><code>std::call_once</code>，如果多个线程需要同时调用某个函数，<code>call_once</code> 可以保证多个线程对该函数只调用一次</li></ol><h2 id="Condition-条件变量"><a href="#Condition-条件变量" class="headerlink" title="Condition 条件变量"></a>Condition 条件变量</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>条件变量是线程的另外一种同步机制</strong>，这些同步对象为线程提供了会合的场所，即线程交互时的一个线程给另外的一个或者多个线程发送消息，我们指定在条件变量这个地方发生，一个线程用于修改这个变量使其满足其它线程继续往下执行的条件，其它线程则接收条件已经发生改变的信号。C++11利用条件变量 <code>std::condition_variable</code> 进行线程同步的应用实例，<code>Linux</code> 下使用 <code>pthread</code> 库中的 <code>pthread_cond_*()</code> 函数提供了与条件变量相关的功能</p><p>当 <code>std::condition_variable</code> 对象的某个 <code>wait</code> 函数被调用的时候，它使用 <code>std::unique_lock</code>(封装 <code>std::mutex</code>) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 <code>std::condition_variable</code> 对象上调用了 <code>notification</code> 函数来唤醒当前线程</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol><li><p><code>wait()</code>函数</p><ul><li><p><code>void wait (unique_lock&lt;mutex&gt;&amp; lck);</code></p><p>当前线程调用 <code>wait()</code> 后将被阻塞(此时当前线程应该获得了锁（<code>lck</code>）, 直到另外某个线程调用 <code>notify_*</code> 唤醒了当前线程，在线程被阻塞时，该函数会自动调用 <code>lck.unlock()</code> 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。</p></li><li><p><code>template &lt;class Predicate&gt; void wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred);</code></p><p>设置了 <code>Predicate</code>，只有当 <code>pred</code> 条件为 <code>false</code> 时调用 <code>wait()</code> 才会阻塞当前线程，并且在收到其他线程的通知后只有当 <code>pred</code> 为 <code>true</code> 时才会被解除阻塞。</p></li></ul></li><li><p><code>std::condition_variable::notify_one()</code></p><p>唤醒某个等待(<code>wait</code>)线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的</p></li><li><p><code>std::condition_variable::notify_all()</code> </p><p>唤醒所有的等待(<code>wait</code>)线程。如果当前没有等待线程，则该函数什么也不做</p></li><li><p><code>std::notify_all_at_thread_exit</code></p><p>当调用该函数的线程退出时，所有在 cond 条件变量上等待的线程都会收到通知</p></li><li><p>唤醒所有的等待(<code>wait</code>)线程。如果当前没有等待线程，则该函数什么也不做</p></li></ol><h2 id="Future-异步"><a href="#Future-异步" class="headerlink" title="Future 异步"></a>Future 异步</h2><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。与C++ 11异步任务相关的类主要在<code>&lt;future&gt;</code>头文件中，此外 <code>std::async</code> 也可以作为异步任务的提供者，不过 <code>std::async</code> 并不是类，而是函数</p><h4 id="主要类和函数"><a href="#主要类和函数" class="headerlink" title="主要类和函数"></a>主要类和函数</h4><ol><li>Providers 类：<code>std::promise</code>, <code>std::package_task</code></li><li>Futures 类：<code>std::future</code>, <code>std::shared_future</code>.</li><li>Providers 函数：<code>std::async()</code></li><li>其他类型：<code>std::future_error</code>, <code>std::future_errc</code>, <code>std::future_status</code>, <code>std::launch</code>.</li></ol><h4 id="异步任务提供者（Providers"><a href="#异步任务提供者（Providers" class="headerlink" title="异步任务提供者（Providers)"></a>异步任务提供者（Providers)</h4><ol><li><p><code>std::promise</code>：它可以在某一时刻设置共享状态的值，它可以在某一时刻设置共享状态的值。</p><p><code>std::promise</code> 对象可以保存某一类型 T 的值，该值可被 future 对象读取（可能在另外一个线程中），因此 promise 也提供了一种线程同步的手段，在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(<code>std::future</code>)上保存一个类型为 T 的值。</p></li><li><p><code>std::package_task</code>：它在某一时刻通过调用被包装的任务来设置共享状态的值</p><p><code>std::packaged_task</code> 包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果</p></li><li><p><code>std::async()</code> ：是一个函数</p></li></ol><h4 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h4><p><code>std::future </code>用来获取异步任务的结果，对象可以异步返回共享状态的值。因此可以把它当成一种简单的线程间同步的手段。一个有效(<code>valid</code>)的 <code>std::future</code> 对象通常由三种 Provider 创建，并和某个共享状态相关类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_int</span><span class="hljs-params">(std::future&lt;<span class="hljs-type">int</span>&gt;&amp; fut)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = fut.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 获取共享状态的值.</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 打印 value: 10.</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; prom; <span class="hljs-comment">// 生成一个 std::promise&lt;int&gt; 对象.</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; fut = prom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">// 和 future 关联.</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_int, std::ref(fut))</span></span>; <span class="hljs-comment">// 将 future 交给另外一个线程t.</span><br>    prom.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 设置共享状态的值, 此处和线程t保持同步.</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Atomic-原子类型"><a href="#Atomic-原子类型" class="headerlink" title="Atomic 原子类型"></a>Atomic 原子类型</h2><p>原子类型对象的主要特点就是从不同线程访问不会导致数据竞争，意味着多个线程访问同一个资源时，有且仅有一个线程能对资源进行操作。通常情况下原子操作可以通过互斥的访问方式来保证</p><ol><li><p><code>std::atomic_flag</code></p><p><code>atomic_flag</code> 一种简单的原子布尔类型，只支持两种操作，<code>test_and_set</code> 和 <code>clear</code>。</p></li><li><p><code>std::atomic</code></p><p>满足其他需求(如 <code>store</code>, <code>load</code>, <code>exchange</code>, <code>compare_exchange</code></p></li></ol><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li><strong>静态内存模型</strong>：主要是类(或结构)对象在内存中的布局。也就是类(或结构)成员在内存中是如何存放的。C++11有一些定义及工具用来对内存布局进行操作，更复杂的类(或结构)对象的内存布局请参考Stanley B.Lippman的《深度探索C++对象模型》。</li><li><strong>动态内存模型</strong>：是从行为方面来看，多个线程对同一个对象同时读写时所做的约束，该模型理解起来要复杂一些，涉及了内存、Cache、CPU各个层次的交互，尤其是在多核系统中为了保证多线程环境下执行的正确性，需要对读写事件加以严格限制。std::memory_order就是这用来做这事的，它实际上是程序员、编译器以及CPU之间的契约，遵守契约后大家各自优化，从而可能提高程序性能。</li></ol><h4 id="为什么需要内存模型"><a href="#为什么需要内存模型" class="headerlink" title="为什么需要内存模型"></a>为什么需要内存模型</h4><img src="../images/image-20200819214836498.png"/><p>多核情况下为了获取更高的性能，会对语句进行执行顺序上的优化(类似CPU乱序)。避免方案当然是<code>std::mutex</code>，但是当程序对代码执行效率要求很高，<code>std::mutex</code>不满足时，就需要<code>std::atomic</code>，但<code>std::atomic</code>无法发现错误</p><h4 id="C-11的内存模型"><a href="#C-11的内存模型" class="headerlink" title="C++11的内存模型"></a>C++11的内存模型</h4><p>在正式介绍memory_order之前，我们先来看两个概念：synchronized-with和happends-before。</p><ul><li><p>行为：<strong>synchronized-with</strong></p><p>这是std::atomic生效的前提之一。假设X是一个atomic变量。如果线程A写了变量X, 线程B读了变量X，那么我们就说线程A、B间存在synchronized-with关系。C++11默认的原子操作(memory_order_seq_cst)就是synchronized-with的，保证了对X的读和写是互斥的，不会同时发生。</p><img src="../images/image-20200819215555351.png"/></li><li><p>结果：<strong>happens-before</strong></p><p> happens-before指明了后发生的动作会看到先发生的动作的结果。还是上图，当线程B读取X时，读到的一定是写入后的X值，而不会是其它情况。happends-before具有<em>传递性</em>。如果A happens-before B，B happens-before C，那么A happends-before C</p></li><li><p><strong>4种内存模型</strong></p><table><thead><tr><th>序号</th><th>内存模型</th><th>memory_order值</th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>1</td><td>宽松</td><td>memory_order_relaxed</td><td></td></tr><tr><td>2</td><td>释放-获取</td><td>memory_order_acquire<br/>memory_order_release<br/>memory_order_acq_rel</td><td></td></tr><tr><td>3</td><td>释放-消费</td><td>memory_order_consume</td><td>C++20起</td></tr><tr><td>4</td><td>顺序一致</td><td>memory_order_seq_cst</td><td></td></tr></tbody></table><ol><li><p><strong>宽松</strong></p><p>在原子变量上采用relaxed ordering的操作不参与synchronized-with关系。Relaxed ordering的限定范围是同线程，在同一线程内对<strong>同一原子变量</strong>的访问不可以被重排，仍保持happens-before关系，但这与别的线程无关(不同线程间的同一原子变量的操作没有happens-before关系)。Relaxed ordering适用于<strong>只要求原子操作，不需要其它同步保障</strong>的情况。该操作典型的应用场景是程序计数器：</p></li><li><p><strong>释放-获取</strong></p><p>Release-acquire中没有全序关系，但它提供了一些同步方法。在这种序列模型下，原子操作对应的内存操作为：</p><table><thead><tr><th align="center">序号</th><th align="center">原子操作</th><th>对应的内存操作</th><th>memory_order枚举值</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">load</td><td>acquire</td><td>memory_order_acquire</td></tr><tr><td align="center">2</td><td align="center">store</td><td>release</td><td>memory_order_release</td></tr><tr><td align="center">3</td><td align="center">fetch_add exchange</td><td>acquire 或 release 或 两者都是</td><td>memory_order_acquire memory_order_release memory_order_acq_rel</td></tr><tr><td align="center">…</td><td align="center">…</td><td>…</td><td>…</td></tr></tbody></table><p>Release-acquire中同步是成对出现的，仅建立在释放和获取同一原子对象的线程之间。其它线程有可能看到不一样的内存访问顺序。在我们常用的x86系统(强顺序系统)上，释放-获取顺序对于多数操作是自动进行的，无需为此同步模式添加额外的CPU指令。但在弱顺序系统(如ARM)上，必须使用特别的CPU加载或内存栅栏指令。</p><p>Release-acquire有一个特点：线程A中所有发生在release x之前的写操作(包括非原子或宽松原子)，对在线程B acquire x之后都可见。本来A、B间读写操作顺序不定。这么一同步，在x这个点前后，A、B线程之间有了个顺序关系，称作inter-thread happens-before。</p><p>一个释放-获取同步的例子是<code>std::mutex</code>：线程A释放锁而线程B获得它时，发生于线程A环境的临界区(释放之前)中的所有内存写入操作，对于线程B(获得之后)均可见。</p></li><li><p><strong>释放-消费</strong></p><p>释放-消费顺序的规范正在修订中，C++标准暂不鼓励使用memory_order_consume。此处不过多介绍</p></li><li><p><strong>顺序一致</strong></p><p>顺序一致性原子操作是全序的，可以看作是释放-获取操作的加强版，它与释放-获取顺序相同的方式排序内存(在一个线程中先发生于存储的任何结果都变成进行加载的线程中的可见副效应)的同时，还对所有内存操作建立单独全序。它意味着将程序看做是一个简单的序列。如果对于一个原子变量的所有操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序执行。</p></li></ol></li></ul><h2 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h2><p>理解底层数据结构 ，理解底层机制是，加锁还是写CAS，锁的粒度是什么，还是写时拷贝</p><ol><li><code>concurrentqueue</code></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><ol><li><p>单对单</p></li><li><p>单对多</p></li><li><p>多对单</p></li><li><p>多对多</p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>C++11多线程-内存模型：<a href="https://www.jianshu.com/p/7d237771dc94">https://www.jianshu.com/p/7d237771dc94</a></p><p>Cplusplus-Concurrency-In-Practice：<a href="https://github.com/forhappy/Cplusplus-Concurrency-In-Practice">https://github.com/forhappy/Cplusplus-Concurrency-In-Practice</a></p><p>C++并发编程-博客园：<a href="https://www.cnblogs.com/huty/p/8516997.html">https://www.cnblogs.com/huty/p/8516997.html</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/2022/04/30/C++%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/30/C++%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1、hello-world"><a href="#1、hello-world" class="headerlink" title="1、hello world"></a>1、hello world</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、注释"><a href="#2、注释" class="headerlink" title="2、注释"></a>2、注释</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">行 <span class="hljs-comment">//</span><br>多行 <span class="hljs-comment">/*  */</span><br></code></pre></td></tr></table></figure><h2 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">数据类型 变量名 <span class="hljs-operator">=</span> 变量初始值；<br>int a <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="4、常量"><a href="#4、常量" class="headerlink" title="4、常量"></a>4、常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// # define宏常量： </span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> 变量名 变量值</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> Max 10</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; Max &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//const修饰变量：</span><br><span class="hljs-comment">//const 数据类型 常量名=常量值</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>cout &lt;&lt; a &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5、标识符（常量、变量）命名规则"><a href="#5、标识符（常量、变量）命名规则" class="headerlink" title="5、标识符（常量、变量）命名规则"></a>5、标识符（常量、变量）命名规则</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1、只能由字母、数字、下划线构成<br>2、第一个字符只能是字母或者下划线<br>3、标识符不能是关键字<br>4、标识符区分大小写的<br></code></pre></td></tr></table></figure><h2 id="6、数据类型"><a href="#6、数据类型" class="headerlink" title="6、数据类型"></a>6、数据类型</h2><h3 id="6-1-整型"><a href="#6-1-整型" class="headerlink" title="6_1 整型"></a>6_1 整型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">short</span> num1 = <span class="hljs-number">32768</span>;<br><span class="hljs-type">int</span> num2 = <span class="hljs-number">2100000000</span>;<br><span class="hljs-type">long</span> num3 = <span class="hljs-number">12</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num4 = <span class="hljs-number">13</span>;<br>cout &lt;&lt; num1 &lt;&lt; endl;<br>cout &lt;&lt; num2 &lt;&lt; endl;<br>cout &lt;&lt; num3 &lt;&lt; endl;<br>cout &lt;&lt; num4 &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-sizeof关键字"><a href="#6-2-sizeof关键字" class="headerlink" title="6_2 sizeof关键字"></a>6_2 sizeof关键字</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">short</span> )&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>) &lt;= <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">long</span>) &lt;= <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span>)<br><br><span class="hljs-meta"># include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br><span class="hljs-built_in">int</span> num1 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(num1); <span class="hljs-comment">//返回字节</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-实型（float）"><a href="#6-3-实型（float）" class="headerlink" title="6_3 实型（float）"></a>6_3 实型（float）</h3><p>1、单精度float</p><p>2、双精度double</p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>有效数字范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15到16位有效数字</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">float</span> Pi = <span class="hljs-number">1234563.1415926f</span>;<span class="hljs-comment">//小数默认显示6位有效数字，再用科学计数法</span><br><span class="hljs-type">double</span> Pj = <span class="hljs-number">1234563.1415926</span>;<span class="hljs-comment">//小数默认显示6位有效数字，再用科学计数法</span><br>cout &lt;&lt; Pi &lt;&lt; endl;<br>cout &lt;&lt; Pj &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="taps：-科学计数法"><a href="#taps：-科学计数法" class="headerlink" title="taps： 科学计数法"></a>taps： 科学计数法</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf">double <span class="hljs-literal">Pi</span> = <span class="hljs-number">3</span>e4 + <span class="hljs-number">38</span>;<br>cout &lt;&lt; <span class="hljs-literal">Pi</span> &lt;&lt; <span class="hljs-literal">endl</span>;<span class="hljs-comment">//30038</span><br></code></pre></td></tr></table></figure><h3 id="6-4-字符型"><a href="#6-4-字符型" class="headerlink" title="6_4 字符型"></a>6_4 字符型</h3><ol><li><p>并非存储数据本身，而是存储对应的Ascll码</p></li><li><p>C和C++中char只占一个字节</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">char</span> ch1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>cout &lt;&lt; ch1 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(ch1) &lt;&lt; endl;<br>cout &lt;&lt; (<span class="hljs-type">int</span>)ch1 &lt;&lt; endl;         <span class="hljs-comment">//输出对应的Ascll码值</span><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="taps："><a href="#taps：" class="headerlink" title="taps："></a>taps：</h4><ol><li><p>创建字符型变量只能放一个字符（多的string）</p></li><li><p>只能用单引号</p></li></ol><h3 id="6-5-转义字符"><a href="#6-5-转义字符" class="headerlink" title="6_5 转义字符"></a>6_5 转义字符</h3><table><thead><tr><th>\n</th><th>换行</th></tr></thead><tbody><tr><td>\v</td><td>垂直制表</td></tr><tr><td>\\</td><td>代表反斜线字符“\”</td></tr><tr><td>\t</td><td>水平制表</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;aaa\thello&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;aaaaa\thello&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;aaaa\thello&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-6-字符串型"><a href="#6-6-字符串型" class="headerlink" title="6_6  字符串型"></a>6_6  字符串型</h3><p>两种都能用</p><ol><li><p>沿用C的风格</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char 变量名[] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>C++风格</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">char</span> ch[] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>string ch1 = <span class="hljs-string">&quot;hello world&quot;</span>;<br>cout &lt;&lt; ch &lt;&lt; endl;<br>cout &lt;&lt; ch1 &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="taps"><a href="#taps" class="headerlink" title="taps:"></a>taps:</h4><ol><li>字符串用双引号</li><li>C风格必须要中括号</li></ol><h3 id="6-7-布尔类型"><a href="#6-7-布尔类型" class="headerlink" title="6_7 布尔类型"></a>6_7 布尔类型</h3><p>只有两个值</p><p>true （本质是1）</p><p>false（本质是0）</p><p>占一位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; flag &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-8-数据的输入"><a href="#6-8-数据的输入" class="headerlink" title="6_8 数据的输入"></a>6_8 数据的输入</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-meta"># <span class="hljs-keyword">include</span> &lt;iostream&gt;</span><br><br>using namespace std;<br><br>int main() &#123;<br>int a = <span class="hljs-number">0</span>;<br>double <span class="hljs-literal">pi</span> = <span class="hljs-number">10.5</span>;<br>char ch1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>string <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello world&quot;</span>;<br>bool <span class="hljs-built_in">flag</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//整型</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cin &gt;&gt; a;<br><span class="hljs-comment">//浮点型</span><br>cout &lt;&lt; <span class="hljs-string">&quot;pi&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cin &gt;&gt; <span class="hljs-literal">pi</span>;<br><span class="hljs-comment">//字符型</span><br>cout &lt;&lt; <span class="hljs-string">&quot;ch1&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cin &gt;&gt; ch1;<br><span class="hljs-comment">//字符串型</span><br>cout &lt;&lt; <span class="hljs-string">&quot;str&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cin &gt;&gt; <span class="hljs-built_in">str</span>;<br><span class="hljs-comment">//布尔型</span><br>cout &lt;&lt; <span class="hljs-string">&quot;flag&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cin &gt;&gt; <span class="hljs-built_in">flag</span>;<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-literal">endl</span>;<br>cout &lt;&lt; <span class="hljs-literal">pi</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cout &lt;&lt; ch1 &lt;&lt; <span class="hljs-literal">endl</span>;<br>cout &lt;&lt; <span class="hljs-built_in">str</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cout &lt;&lt; <span class="hljs-built_in">flag</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7 运算符"></a>7 运算符</h2><h3 id="7-1-算术运算符"><a href="#7-1-算术运算符" class="headerlink" title="7_1 算术运算符"></a>7_1 算术运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10+1</td><td>11</td></tr><tr><td>-</td><td>减</td><td>10-1</td><td>9</td></tr><tr><td>*</td><td>乘</td><td>5*6</td><td>30</td></tr><tr><td>&#x2F;</td><td>除</td><td>10&#x2F;3</td><td>3</td></tr><tr><td>%</td><td>取模（取余）</td><td>10%3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a&#x3D;2;b&#x3D;++a;</td><td>a&#x3D;3;b&#x3D;3;</td></tr><tr><td>++</td><td>后置递增</td><td>a&#x3D;2;b&#x3D;a++;</td><td>a&#x3D;3;b&#x3D;2;</td></tr><tr><td>–</td><td>前置递减</td><td>a&#x3D;2;b&#x3D;–a;</td><td>a&#x3D;1;b&#x3D;1;</td></tr><tr><td>–</td><td>后置递减</td><td>a&#x3D;2;b&#x3D;a–;</td><td>a&#x3D;1;b&#x3D;2;</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//取余、取模</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br><span class="hljs-type">double</span> c = <span class="hljs-number">1.01</span>;<br><span class="hljs-type">double</span> d = <span class="hljs-number">0.07</span>;<br>cout &lt;&lt; a / b &lt;&lt; endl;  <span class="hljs-comment">//3</span><br>cout &lt;&lt; c / d &lt;&lt; endl;  <span class="hljs-comment">//14.4286可以为小数</span><br><span class="hljs-comment">//cout &lt;&lt; c % d &lt;&lt; endl;//无法取模</span><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br> <br><br><br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//前置递增和后置递增</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>b = ++a;  <span class="hljs-comment">//前置递增：先让变量+1 ，再进行表达式的运算</span><br>cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">//  1 1 </span><br><span class="hljs-type">int</span> c = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>d = c++;  <span class="hljs-comment">//后置递增：进行表达式运算，后让变量+1</span><br>cout &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="hljs-comment">//  0 1  </span><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​&#x2F;&#x2F;前置递减和后置递减<br>​<br>​# include <iostream><br>​<br>​using namespace std;<br>​</p><pre><code class="hljs">int main() {int a = 0, b = 0;b = --a;  //前置递减：先让变量-1 ，再进行表达式的运算cout &lt;&lt; b &lt;&lt; &quot;   &quot; &lt;&lt; a &lt;&lt; endl; //-1 -1int c = 0, d = 0;d = c--;  //后置递减：进行表达式运算，后让变量-1cout &lt;&lt; d &lt;&lt; &quot;   &quot; &lt;&lt; c &lt;&lt; endl; //0 -1system(&quot;pause&quot;);return 0;}</code></pre><h4 id="taps-1"><a href="#taps-1" class="headerlink" title="taps:"></a>taps:</h4><ol><li>取余，取模除数不能为0</li><li>小数无法取模</li><li>小数之间除不尽 相除为小数</li></ol><h3 id="7-2-赋值运算符"><a href="#7-2-赋值运算符" class="headerlink" title="7_2 赋值运算符"></a>7_2 赋值运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td><td>a&#x3D;2;b&#x3D;3;</td><td>a&#x3D;2;b&#x3D;3;</td></tr><tr><td>+&#x3D;</td><td>加等于</td><td>a&#x3D;0;a+&#x3D; 2;</td><td>a&#x3D;2;</td></tr><tr><td>-&#x3D;</td><td>减等于</td><td>a&#x3D;5;a-&#x3D;3;</td><td>a&#x3D;2;</td></tr><tr><td>*&#x3D;</td><td>乘等于</td><td>a&#x3D;2;a*&#x3D;2;</td><td>a&#x3D;4;</td></tr><tr><td>&#x2F;&#x3D;</td><td>除等于</td><td>a&#x3D;4;a&#x2F;&#x3D;2;</td><td>a&#x3D;2;</td></tr><tr><td>%&#x3D;</td><td>模等于</td><td>a&#x3D;3;a%&#x3D;2;</td><td>a&#x3D;1;</td></tr></tbody></table><h3 id="7-3-比较运算符"><a href="#7-3-比较运算符" class="headerlink" title="7_3 比较运算符"></a>7_3 比较运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果0或者1</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>4&#x3D;&#x3D;3</td><td>0</td></tr><tr><td>!&#x3D;</td><td></td><td></td><td></td></tr><tr><td>&lt;&#x3D;</td><td></td><td></td><td></td></tr><tr><td>&gt;&#x3D;</td><td></td><td></td><td></td></tr><tr><td>&lt;</td><td></td><td></td><td></td></tr><tr><td>&gt;</td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">include &lt;iostream&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>cout &lt;&lt; (a==b) &lt;&lt; endl;   <span class="hljs-comment">//加括号，优先级（先运算是否相等，在输出结果，不然报错）</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="7-4-逻辑运算符"><a href="#7-4-逻辑运算符" class="headerlink" title="7_4 逻辑运算符"></a>7_4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>！</td><td>非</td><td>!a</td><td>a真为假，a假为真</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a&amp;&amp;b</td><td>都真为真，否则为假</td></tr><tr><td>||</td><td>或</td><td>a||b</td><td>至少一真为真，都不真为假</td></tr></tbody></table><h2 id="8-程序流程结构"><a href="#8-程序流程结构" class="headerlink" title="8 程序流程结构"></a>8 程序流程结构</h2><p>顺序结构，选择结构，循环结构</p><h3 id="8-1-选择结构"><a href="#8-1-选择结构" class="headerlink" title="8_1 选择结构"></a>8_1 选择结构</h3><h4 id="8-1-1多行if"><a href="#8-1-1多行if" class="headerlink" title="8_1_1多行if"></a>8_1_1多行if</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> &lt;iostream&gt;</span><br><br>using namespace std;<br><br>int main() &#123;<br><span class="hljs-comment">//选择结构，单行if语句</span><br>int <span class="hljs-built_in">score</span> = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入你的分数: &quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>cin &gt;&gt; <span class="hljs-built_in">score</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;你的分数为：&quot;</span> &lt;&lt; <span class="hljs-built_in">score</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br><span class="hljs-keyword">if</span> ((<span class="hljs-built_in">score</span> &lt;= <span class="hljs-number">0</span>) || (<span class="hljs-built_in">score</span> &gt;= <span class="hljs-number">750</span>))<br>cout &lt;&lt; <span class="hljs-string">&quot;warning!!!!请输入0到750分&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">score</span> &gt; <span class="hljs-number">600</span>)<br>cout &lt;&lt; <span class="hljs-string">&quot;恭喜你考入了一本&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">score</span> &gt; <span class="hljs-number">500</span>)<br>cout &lt;&lt; <span class="hljs-string">&quot;恭喜你考入了二本&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;你没考上大学&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>return <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h5 id="taps-单行可以不加花括号"><a href="#taps-单行可以不加花括号" class="headerlink" title="taps:单行可以不加花括号"></a>taps:单行可以不加花括号</h5><p>嵌套if语句</p><h4 id="8-1-2-三目运算符"><a href="#8-1-2-三目运算符" class="headerlink" title="8_1_2 三目运算符"></a>8_1_2 三目运算符</h4><p>(a&gt;b? a:b)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">12</span>, c = <span class="hljs-number">5</span>, d = <span class="hljs-number">88</span>, e ;<br>e = a &gt; b ? c : d;<br>cout &lt;&lt; e &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="8-1-3-switch结构"><a href="#8-1-3-switch结构" class="headerlink" title="8_1_3 switch结构"></a>8_1_3 switch结构</h4><p>只能是具体的数字或者字符，不能是区间</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-meta"># <span class="hljs-keyword">include</span> &lt;iostream&gt;</span><br><br>using namespace std;<br><br>int main() &#123;<br>int <span class="hljs-built_in">score</span> = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入你的评分(0-10): &quot;</span> ;<br>cin &gt;&gt; <span class="hljs-built_in">score</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;你输入的分数为：&quot;</span> &lt;&lt; <span class="hljs-built_in">score</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">score</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;你认为它是好电影&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;你认为它是好电影&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;你认为它是好电影&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;你认为它是一般好电影&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;你认为它是一般好电影&quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        cout &lt;&lt; <span class="hljs-string">&quot;烂片 &quot;</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>    &#125;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    return <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-循环结构"><a href="#8-2-循环结构" class="headerlink" title="8_2 循环结构"></a>8_2 循环结构</h3><h4 id="8-2-1-while循环"><a href="#8-2-1-while循环" class="headerlink" title="8_2_1 while循环"></a>8_2_1 while循环</h4><p>while(循环条件){<br>循环语句<br>}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>) &#123;<br>++num;<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="while循环案例"><a href="#while循环案例" class="headerlink" title="while循环案例"></a>while循环案例</h5><p>猜数字，随机产生一个0到100的数字，让玩家猜测，返回猜大了或者猜小了，直到猜测正确 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-type">int</span> num_suiji, num_caice = <span class="hljs-number">0</span>;<br>num_suiji = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入猜测值：&quot;</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>cin &gt;&gt; num_caice;<br><span class="hljs-keyword">if</span> (num_caice &gt; num_suiji)<br>cout &lt;&lt; <span class="hljs-string">&quot;猜大了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num_caice &lt; num_suiji)<br>cout &lt;&lt; <span class="hljs-string">&quot;猜小了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜对了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-2-2-do…while"><a href="#8-2-2-do…while" class="headerlink" title="8_2_2 do…while"></a>8_2_2 do…while</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">do</span>&#123;循环语句&#125;<span class="hljs-keyword">while</span>(循环条件);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">include &lt;iostream&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span>&#123;<br>num++;<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">while</span> (num&lt;<span class="hljs-number">10</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="案例：水仙花数"><a href="#案例：水仙花数" class="headerlink" title="案例：水仙花数"></a>案例：水仙花数</h5><p>水仙花数是指一个3的倍数，它的每个各位上的数字的三次幂等于它本身，</p><p>例如：1^3+5^3+3^3 &#x3D; 153</p><p>用do…while语句求出三位数中所有的水仙花数</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs maxima"># include &lt;iostream&gt;<br><br>using namespace <span class="hljs-built_in">std</span>;<br><br>int main() &#123;<br>int <span class="hljs-built_in">num</span> = <span class="hljs-number">100</span>;<br>int ge, shi, bai,<span class="hljs-built_in">sum</span>;<br><span class="hljs-keyword">do</span>&#123;<br><span class="hljs-built_in">num</span>++;<br>ge = <span class="hljs-built_in">num</span> <span class="hljs-symbol">%</span> <span class="hljs-number">10</span>;<br>shi = <span class="hljs-built_in">num</span>/<span class="hljs-number">10</span><span class="hljs-symbol">%</span><span class="hljs-number">10</span>;<br>bai = <span class="hljs-built_in">num</span>/<span class="hljs-number">100</span>;<br><span class="hljs-built_in">sum</span> = ge*ge*ge + shi*shi*shi + bai*bai*bai;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> == <span class="hljs-built_in">sum</span>)<br>cout &lt;&lt; <span class="hljs-built_in">sum</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">num</span>&lt;<span class="hljs-number">999</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求圆周率"><a href="#求圆周率" class="headerlink" title="求圆周率"></a>求圆周率</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> PI = <span class="hljs-number">0</span>; <br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> fenmu = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-number">1.0</span>/fenmu)&gt;=<span class="hljs-number">1e-6</span>)<br>    &#123;<br>        PI = a * (<span class="hljs-number">1</span> / fenmu) + PI;<br>        fenmu += <span class="hljs-number">2</span>;<br>        a = -a;<br>    &#125;<br>    PI = PI * <span class="hljs-number">4</span>;<br>    cout &lt;&lt; PI &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="8-2-3-for-循环语句"><a href="#8-2-3-for-循环语句" class="headerlink" title="8_2_3 for 循环语句"></a>8_2_3 for 循环语句</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(起始表达式（<span class="hljs-number">1</span>）;条件表达式（<span class="hljs-number">2</span>）;末尾循环体（<span class="hljs-number">4</span>）)</span></span>&#123;<br>循环语句（<span class="hljs-number">3</span>）；<br>&#125;<br><span class="hljs-comment">//括号里面数字表示优先级</span><br><br><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># include &lt;iostream&gt;</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-built_in">int</span> main() &#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br><span class="hljs-keyword">sum</span> = <span class="hljs-keyword">sum</span> + i;<br>&#125;<br>cout &lt;&lt; <span class="hljs-keyword">sum</span> &lt;&lt; endl;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//变种，最好不这么用，方便理解</span><br><span class="hljs-meta"># include &lt;iostream&gt;</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-built_in">int</span> main() &#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; ; ) &#123;<br>i++;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">101</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">sum</span> = <span class="hljs-keyword">sum</span> + i;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-keyword">sum</span> &lt;&lt; endl;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="案例：敲桌子"><a href="#案例：敲桌子" class="headerlink" title="案例：敲桌子"></a>案例：敲桌子</h5><p>案例描述：从1数到100，如果数字个位含有7，或者十位含有7，或者是7的倍数我们打印敲桌子，其余数字直接打印输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span> ;i++ ) &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>) || (i % <span class="hljs-number">10</span> == <span class="hljs-number">7</span>) || (i / <span class="hljs-number">10</span> == <span class="hljs-number">7</span>))<br>            cout &lt;&lt; <span class="hljs-string">&quot;敲桌子&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="8-2-4-嵌套循环"><a href="#8-2-4-嵌套循环" class="headerlink" title="8_2_4 嵌套循环"></a>8_2_4 嵌套循环</h4><p>再循环体内再嵌套一层循环</p><p>九九乘法表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= j; i++) &#123;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;= &quot;</span> &lt;&lt; i * j&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br><br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-3-跳转语句"><a href="#8-3-跳转语句" class="headerlink" title="8_3 跳转语句"></a>8_3 跳转语句</h3><h4 id="8-3-1-break"><a href="#8-3-1-break" class="headerlink" title="8_3_1 break"></a>8_3_1 break</h4><ol><li>出现在switch语句中，作用是终止case并跳出switch；</li><li>出现在循环语句中，作用是跳出当前的循环语句；</li><li>出现在嵌套循环中，跳出最近的内层循环语句。</li></ol><h4 id="8-3-2-continue语句"><a href="#8-3-2-continue语句" class="headerlink" title="8_3_2 continue语句"></a>8_3_2 continue语句</h4><p>在循环语句中，跳过本次循环中尚未执行的语句，进入下一次循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>cout &lt;&lt; j&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-3-goto语句"><a href="#8-3-3-goto语句" class="headerlink" title="8_3_3 goto语句"></a>8_3_3 goto语句</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">goto 标记<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a;<br>AGI:cin &gt;&gt; a;<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>cout &lt;&lt; j &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;必须大于10哦&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">goto</span> AGI;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9 数组"></a>9 数组</h2><h3 id="9-1一维数组"><a href="#9-1一维数组" class="headerlink" title="9_1一维数组"></a>9_1一维数组</h3><p>特点：放在一块连续的内存空间中</p><pre><code class="hljs">数组中每个元素都是相同的数据类型</code></pre><p>用途：可以统计整个数组在内存中的长度</p><pre><code class="hljs">可以获取数组在内存中的首地址</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta"># include &lt;iostream&gt;</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br><span class="hljs-built_in">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">1</span>]) &lt;&lt; endl;  <span class="hljs-comment">//4</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; endl;     <span class="hljs-comment">//20</span><br>cout &lt;&lt; a &lt;&lt; endl;             <span class="hljs-comment">//00DAFB90 数组的首地址</span><br>cout &lt;&lt; &amp;a[<span class="hljs-number">0</span>] &lt;&lt; endl;         <span class="hljs-comment">//00DAFB90 数组第一个元素地址</span><br>cout &lt;&lt; &amp;a[<span class="hljs-number">1</span>] &lt;&lt; endl;         <span class="hljs-comment">//00DAFB94 素组第二个元素地址</span><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="案例1：五只小猪称体重"><a href="#案例1：五只小猪称体重" class="headerlink" title="案例1：五只小猪称体重"></a>案例1：五只小猪称体重</h4><p>int arr[5] &#x3D; {300,350,200,400,250} , 打印出最重小猪的体重</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">300</span>,<span class="hljs-number">350</span>,<span class="hljs-number">200</span>,<span class="hljs-number">400</span>,<span class="hljs-number">250</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (arr[i] &gt; max)<br>max = arr[i];<br>&#125;<br>cout &lt;&lt; max &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="案例2：数组元素逆置"><a href="#案例2：数组元素逆置" class="headerlink" title="案例2：数组元素逆置"></a>案例2：数组元素逆置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 我的算法是直接逆向输出到新数组，别人是首尾置换，我的时间复杂度比他高一倍</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span> &#125;;<br><span class="hljs-type">int</span> start, end;<br>start = <span class="hljs-number">0</span>;<br>end = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">while</span> (start &lt; end) &#123;<br><span class="hljs-type">int</span> temp;<br>temp = arr[start];<br>arr[start] = arr[end];<br>arr[end] = temp;<br>start++;<br>end--;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="9-2-冒泡排序"><a href="#9-2-冒泡排序" class="headerlink" title="9_2 冒泡排序"></a>9_2 冒泡排序</h3><p>比较相邻的两个元素，如果第一个比第二个大，就交换他们两个</p><p>对每一组相邻元素做同样的工作，执行完毕后，找到一个最大值</p><p>重复以上的步骤，每次比较数-1，直到不需要比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">第一次冒泡得到一个最大数，第二次冒泡得到第二大的数，直到不需要比较，即只剩一个数不需要比较，就是数组长度<span class="hljs-number">-1</span>，每次比较完会产生一个不会在比较的数，下次不用比较，即内层循环要减去轮数，时间复杂度为 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span><span class="hljs-number">+2</span><span class="hljs-number">+3</span>+...+(n<span class="hljs-number">-1</span>))<br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span> &#125;;<br><span class="hljs-type">int</span> len;<br>len = <span class="hljs-built_in">sizeof</span>(arr)/<span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">1</span>]);<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (num &lt; len<span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span> - num; i++) &#123;<br><span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> temp;<br>temp = arr[i];<br>arr[i] = arr[i + <span class="hljs-number">1</span>];<br>arr[i + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>num++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>cout &lt;&lt; arr[j] &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> n 11</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-type">int</span> a[n][n];<br><br>    <span class="hljs-comment">//左右边界</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        a[i][i] = <span class="hljs-number">1</span>;<br>        a[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//3开始的行数</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">3</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span>; j &lt; i; j++) &#123;<br>            a[i][j] = a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="9-3-二维数组"><a href="#9-3-二维数组" class="headerlink" title="9_3 二维数组"></a>9_3 二维数组</h3><p>四种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型 数组名[行数][列数]；<br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">6</span>;<br><br>数据类型 数组名[行数][列数] = &#123;&#123;数据<span class="hljs-number">1</span>，数据<span class="hljs-number">2</span>&#125;,&#123;数据<span class="hljs-number">3</span>，数据<span class="hljs-number">4</span>&#125;&#125;；<br>arr2[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <br>&#123;<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>&#125;;<br><br>数据类型 数组名[行数][列数] = &#123;数据<span class="hljs-number">1</span>，数据<span class="hljs-number">2</span>，数据<span class="hljs-number">3</span>，数据<span class="hljs-number">4</span>&#125;；<br>arr3[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><br>数据类型 数组名[   ][列数] = &#123;数据<span class="hljs-number">1</span>，数据<span class="hljs-number">2</span>，数据<span class="hljs-number">3</span>，数据<span class="hljs-number">4</span>&#125;；<br>arr4[][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><br>输出:<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>cout &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> ;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二维数组案例：总成绩"><a href="#二维数组案例：总成绩" class="headerlink" title="二维数组案例：总成绩"></a>二维数组案例：总成绩</h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-comment"># include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><br><span class="hljs-type">int</span> main() &#123;<br><span class="hljs-type">int</span> score[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">90</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span> &#125;;<br><span class="hljs-type">string</span> names[<span class="hljs-number">3</span>] = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-type">int</span> score_sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>score_sum = score_sum + score[i][j];<br>&#125;<br><br>/*switch (i) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;张三：&quot;</span> &lt;&lt; score_sum &lt;&lt; endl; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;李四：&quot;</span> &lt;&lt; score_sum &lt;&lt; endl; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;王五：&quot;</span> &lt;&lt; score_sum &lt;&lt; endl; <span class="hljs-keyword">break</span>;<br>&#125;*/<br>cout &lt;&lt; names[i] &lt;&lt; <span class="hljs-string">&quot;的总成绩是&quot;</span> &lt;&lt; score_sum &lt;&lt; endl;<br>&#125;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="10-函数"><a href="#10-函数" class="headerlink" title="10 函数"></a>10 函数</h2><h3 id="10-1值传递"><a href="#10-1值传递" class="headerlink" title="10_1值传递"></a>10_1值传递</h3><p>值传递过程中，形参发生任何改变，都不影响实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> </span>&#123;<br><span class="hljs-type">int</span> temp;<br>temp = num2;<br>num2 = num1;<br>num1 = temp;<br><span class="hljs-keyword">return</span> num1, num2;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">swap</span>(a, b);<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="10-2-函数的常见样式"><a href="#10-2-函数的常见样式" class="headerlink" title="10_2 函数的常见样式"></a>10_2 函数的常见样式</h3><ol><li><p>无参无返</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test01&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有参无返</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test02&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test02</span>(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>无参有返</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test03&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num1 = <span class="hljs-built_in">test03</span>();<br>cout &lt;&lt; num1 &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有参有返</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test04&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; a &lt;&lt; endl;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">999</span>;<br><span class="hljs-type">int</span> num1 = <span class="hljs-built_in">test04</span>(a);<br>cout &lt;&lt; num1 &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="10-3-函数的声明"><a href="#10-3-函数的声明" class="headerlink" title="10_3 函数的声明"></a>10_3 函数的声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;   <span class="hljs-comment">//要么在主函数前面定义函数，要么声明函数，定义只能有一次，声明可以多次 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">999</span>;<br><span class="hljs-type">int</span> num1 = <span class="hljs-built_in">test04</span>(a);<br>cout &lt;&lt; num1 &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test04&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; a &lt;&lt; endl;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-4-函数的分文件"><a href="#10-4-函数的分文件" class="headerlink" title="10_4 函数的分文件"></a>10_4 函数的分文件</h3><p>作用：让代码结构更加清晰</p><p>函数分文件一般有4个步骤</p><p>1.创建后缀名为.h 的头文件</p><p>2.创建后缀名为.cpp的源文件</p><p>3.在头文件中写函数的声明</p><p>4.在源文件中写函数的定义</p><p>以swap交换两个数字的函数为例</p><p>主函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swap.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">swap</span>(a, b);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>swap.h文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>swap.cpp文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swap.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp;<br>temp = a;<br>a = b;<br>b = temp;<br>cout &lt;&lt; <span class="hljs-string">&quot;a的值是：&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b的值是：&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-keyword">return</span> a, b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-指针"><a href="#11-指针" class="headerlink" title="11 指针"></a>11 指针</h2><p>指针就是内存地址</p><p>指针在32位系统占4个字节，在64位系统占8个字节（不管什么数据类型都符合这个规律）</p><ol><li>定义指针：数据类型* 指针变量名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p;<br>p = &amp;a;<br>cout&lt;&lt;<span class="hljs-string">&quot;a的地址为: &quot;</span>&lt;&lt; &amp;a &lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;指针p为 : &quot;</span>&lt;&lt; p &lt;&lt;endl;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>使用指针</p><p>可以通过解引用的方式来找到指针指向的内存</p><p>指针前面加* 代表解引用，找到指针指向的内存中的数据</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">int a=10;<br>int<span class="hljs-comment">* p;</span><br>p = <span class="hljs-variable">&amp;a</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;a的地址为: &quot;</span>&lt;&lt; <span class="hljs-variable">&amp;a</span> &lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;指针p为 : &quot;</span>&lt;&lt; p &lt;&lt;endl;<br><br><span class="hljs-comment">*p = 1000;</span>           //修改了内存数据<br>cout &lt;&lt; <span class="hljs-string">&quot;a= &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*p=&quot;</span> &lt;&lt; <span class="hljs-comment">*p &lt;&lt; endl;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h3><p>空指针：指针变量指向内存中编号为0的空间</p><p>用途：初始化指针变量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int * p <span class="hljs-operator">=</span> NULL<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>注意：空指针指向的内存是不可以访问的(0到255之间的内存编号是系统占用的，不可访问)</p><p>野指针：指针变量指向非法的内存空间</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int * p <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1100<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><h3 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h3><p>3种情况:</p><ol><li><p>const修饰指针–常量指针</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">const int * p <span class="hljs-punctuation">=</span> <span class="hljs-meta">&amp;a;</span><br>常量指针<br>特点：指针的指向可以修改，但是指针指向的值不可以改<br><br>*p <span class="hljs-punctuation">=</span> <span class="hljs-number">20</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">//错误，指针指向的值不能改</span><br>p <span class="hljs-punctuation">=</span> <span class="hljs-meta">&amp;b;   <span class="hljs-comment">//正确，指针的指向可以改</span></span><br></code></pre></td></tr></table></figure></li><li><p>const修饰常量–指针常量</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int * const p <span class="hljs-punctuation">=</span> <span class="hljs-meta">&amp;a;</span><br>指针常量<br>特点：指针的指向不能改，指针的指向的值可以改<br><br>*p <span class="hljs-punctuation">=</span> <span class="hljs-number">20</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">//正确，指向的值可以改</span><br>p <span class="hljs-punctuation">=</span> <span class="hljs-meta">&amp;b;   <span class="hljs-comment">//错误，指针指向不可以改</span></span><br></code></pre></td></tr></table></figure></li><li><p>const即修饰指针，又修饰常量 </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> p = &amp;a;<br><br>特点：指针的指向和指针指向的值都不能改<br>*p = <span class="hljs-number">20</span>; <span class="hljs-comment">//错误，指针指向的值不能改</span><br>p =&amp;b;   <span class="hljs-comment">//错误，指针的指向不能改</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>利用指针来访问数组中的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><span class="hljs-type">int</span>* p = arr;<br>cout &lt;&lt; *p &lt;&lt; endl;<br>p++; <span class="hljs-comment">//指针向后偏移4个地址</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>cout &lt;&lt; *p &lt;&lt; endl;<br>p++;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>cout &lt;&lt; <span class="hljs-string">&quot;a的值为：&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b的值为：&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap02</span><span class="hljs-params">(<span class="hljs-type">int</span>* p1, <span class="hljs-type">int</span>* p2)</span></span>&#123;<br><span class="hljs-type">int</span> temp = *p1;<br>*p1 = *p2;<br>*p2 = temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//值传递，不会修改实参</span><br><span class="hljs-comment">//swap01(a, b);</span><br><span class="hljs-comment">//地址传递，会修改实参</span><br><span class="hljs-built_in">swap02</span>(&amp;a, &amp;b);       <span class="hljs-comment">// 这里是将a和b地址所在的数据交换了</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a的值为：&quot;</span> &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">//20</span><br>cout &lt;&lt; <span class="hljs-string">&quot;b的值为：&quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="hljs-comment">//10</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例：指针，数组，函数"><a href="#案例：指针，数组，函数" class="headerlink" title="案例：指针，数组，函数"></a>案例：指针，数组，函数</h4><p>利用指针，数组和函数的知识，对一个数组冒泡排序并且封装</p><p>主函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;maopao.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">maopao</span>(arr, len);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>maopao.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maopao</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span></span>;<br><br></code></pre></td></tr></table></figure><p>maopao.cpp：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;maopao.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maopao</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len<span class="hljs-number">-1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-结构体"><a href="#12-结构体" class="headerlink" title="12 结构体"></a>12 结构体</h2><h3 id="12-1-结构体的概念"><a href="#12-1-结构体的概念" class="headerlink" title="12_1 结构体的概念"></a>12_1 结构体的概念</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="12-2-结构体的定义和使用"><a href="#12-2-结构体的定义和使用" class="headerlink" title="12_2 结构体的定义和使用"></a>12_2 结构体的定义和使用</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">语法：  <span class="hljs-keyword">struct</span> 结构体名 &#123;结构体成员列表&#125;；<br></code></pre></td></tr></table></figure><p>通过结构体创建变量的方式有三种</p><ol><li><p>struct 结构体名 变量名</p></li><li><p>struct 结构体名 变量名 &#x3D; {成员1值，成员2值…}</p></li><li><p>定义结构体时顺便定义变量</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;iostream&gt;</span><br>using namespace std;<br><br><span class="hljs-comment">//创建学生的数据类型</span><br>struct Students &#123;<br>string <span class="hljs-built_in">name</span>;<br>int age;<br>double <span class="hljs-built_in">score</span>;<br>&#125;s3;<span class="hljs-comment">//第三种方式</span><br>int main() &#123;<br><span class="hljs-comment">//创建具体的学生数据</span><br><span class="hljs-comment">//1.创建结构体变量，再给变量赋值</span><br>struct Students student1;<br>student1.<span class="hljs-built_in">name</span> = <span class="hljs-string">&quot;李瑞龙&quot;</span>;<br>student1.age = <span class="hljs-number">18</span>;<br>student1.<span class="hljs-built_in">score</span> = <span class="hljs-number">99.9</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; student1.<span class="hljs-built_in">name</span> &lt;&lt; <span class="hljs-string">&quot;  age: &quot;</span> &lt;&lt; student1.age &lt;&lt; <span class="hljs-string">&quot;  score: &quot;</span> &lt;&lt; student1.<span class="hljs-built_in">score</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br><span class="hljs-comment">//2.创建结构体变量时赋值</span><br>struct Students s2 = &#123; <span class="hljs-string">&quot;adly&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">95</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; s2.<span class="hljs-built_in">name</span> &lt;&lt; <span class="hljs-string">&quot;  age: &quot;</span> &lt;&lt; s2.age &lt;&lt; <span class="hljs-string">&quot;  score: &quot;</span> &lt;&lt; s2.<span class="hljs-built_in">score</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br><span class="hljs-comment">//3.在结构体末尾声明，直接创建</span><br>s3.<span class="hljs-built_in">name</span> = <span class="hljs-string">&quot;李龙&quot;</span>;<br>s3.age = <span class="hljs-number">18</span>;<br>s3.<span class="hljs-built_in">score</span> = <span class="hljs-number">99.9</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; s3.<span class="hljs-built_in">name</span> &lt;&lt; <span class="hljs-string">&quot;  age: &quot;</span> &lt;&lt; s3.age &lt;&lt; <span class="hljs-string">&quot;  score: &quot;</span> &lt;&lt; s3.<span class="hljs-built_in">score</span> &lt;&lt; <span class="hljs-literal">endl</span>;<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="12-3-结构体数组"><a href="#12-3-结构体数组" class="headerlink" title="12_3 结构体数组"></a>12_3 结构体数组</h3><p>作用：将自定义的结构体放入到数组中方便维护</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">语法：struct 结构体名 数组名[元素个数] = </span><span class="hljs-template-variable">&#123; &#123;&#125;</span><span class="language-xml">, </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">,...</span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">double</span> score;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//创建结构体数组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> arr[<span class="hljs-number">3</span>] = &#123;<br>&#123;<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">95</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-number">93</span>&#125;,<br>&#123;<span class="hljs-string">&quot;lrl&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">100</span>&#125;<br>&#125;;<br><span class="hljs-comment">//给结构体变量赋值或者修改</span><br>arr[<span class="hljs-number">2</span>].name = <span class="hljs-string">&quot;liruilong&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>cout &lt;&lt; arr[i].name &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-4-结构体指针"><a href="#12-4-结构体指针" class="headerlink" title="12_4 结构体指针"></a>12_4 结构体指针</h3><p>作用：通过指针访问结构体中的成员</p><p>利用操作符 -&gt;通过结构体指针访问结构体属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">double</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//创建学生结构体变量</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stu = &#123; <span class="hljs-string">&quot;lrl&quot;</span>, <span class="hljs-number">18</span> ,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-comment">//通过指针指向结构体变量</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>* p = &amp;stu;<br><span class="hljs-comment">//可以通过指针修改数据</span><br>p-&gt;name = <span class="hljs-string">&quot;liruilong&quot;</span>;<br><span class="hljs-comment">//通过结构体指针访问结构体变量中的数据</span><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot;年龄&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="hljs-string">&quot;分数&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-5-结构体嵌套结构体"><a href="#12-5-结构体嵌套结构体" class="headerlink" title="12_5 结构体嵌套结构体"></a>12_5 结构体嵌套结构体</h3><p>作用：结构体中的成员可以是另一个结构体</p><p>例如：每个老师辅导一个学员，一个老师结构体中，记录一个学生的结构体</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">struct</span> student &#123;<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-built_in">int</span> age;<br><span class="hljs-built_in">double</span> score;<br>&#125;;<br><span class="hljs-keyword">struct</span> teacher &#123;<br><span class="hljs-built_in">int</span> id;<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-built_in">int</span> age;<br><span class="hljs-keyword">struct</span> student stu;  <span class="hljs-comment">//结构体嵌套结构体</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br><span class="hljs-comment">//创建老师</span><br>teacher t;<br>t.id = <span class="hljs-number">1000</span>;<br>t.name = <span class="hljs-string">&quot;老王&quot;</span>;<br>t.age = <span class="hljs-number">40</span>;<br>t.stu.name = <span class="hljs-string">&quot;小王&quot;</span>;<br>t.stu.age = <span class="hljs-number">20</span>;<br>t.stu.score = <span class="hljs-number">99</span>;<br><br>cout &lt;&lt; t.name &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; t.stu.name &lt;&lt; endl;<br><br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-6-结构体做函数参数"><a href="#12-6-结构体做函数参数" class="headerlink" title="12_6 结构体做函数参数"></a>12_6 结构体做函数参数</h3><p>作用：将结构体作为参数向函数中传递</p><p>传递方式有两种：值传递</p><p>​   地址传递</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">double</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintStu</span><span class="hljs-params">(student* p)</span> </span>&#123;<br>cout &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>student stu1;<br>stu<span class="hljs-number">1.</span>name = <span class="hljs-string">&quot;lrl&quot;</span>;<br>stu<span class="hljs-number">1.</span>age = <span class="hljs-number">20</span>;<br>stu<span class="hljs-number">1.</span>score = <span class="hljs-number">90</span>;<br><br><span class="hljs-built_in">PrintStu</span>(&amp;stu1);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-7-结构体中const使用场景"><a href="#12-7-结构体中const使用场景" class="headerlink" title="12_7 结构体中const使用场景"></a>12_7 结构体中const使用场景</h3><p>使用const防止误操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">double</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintStu</span><span class="hljs-params">(<span class="hljs-type">const</span> student *stu1)</span> </span>&#123;<br><span class="hljs-comment">//stu1-&gt;age = 30;  不能修改</span><br>cout &lt;&lt; stu1-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu1-&gt;age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu1-&gt;score &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>student stu1;<br>stu<span class="hljs-number">1.</span>name = <span class="hljs-string">&quot;lrl&quot;</span>;<br>stu<span class="hljs-number">1.</span>age = <span class="hljs-number">20</span>;<br>stu<span class="hljs-number">1.</span>score = <span class="hljs-number">90</span>;<br><br><span class="hljs-built_in">PrintStu</span>(&amp;stu1);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p>学校正做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中老师在结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每位老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><p><strong>一个程序就能解决，我小题大作搞了5个，但是发现了分函数要重新定义结构体，不亏</strong></p><p><strong>main.cpp:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fenpeixuesheng.h&quot;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&quot;printStu.h&quot;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>string s_name;<br><span class="hljs-type">double</span> score;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> &#123;<br>string t_name;<br>Student Stu[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Teacher Teach[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(Teach) / <span class="hljs-built_in">sizeof</span>(Teach[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">fenpeixuesheng</span>(Teach, len);<br><span class="hljs-built_in">printStu</span>(Teach, len);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fenpeixuesheng.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fenpeixuesheng</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Teacher Teah[], <span class="hljs-type">int</span> len)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>printStu.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStu</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Teacher Teach[], <span class="hljs-type">int</span> len)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>fenpeixuesheng.cpp</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &quot;fenpeixuesheng.h&quot;</span><br><span class="hljs-keyword">struct</span> Student &#123;<br><span class="hljs-built_in">string</span> s_name;<br><span class="hljs-built_in">double</span> score;<br>&#125;;<br><span class="hljs-keyword">struct</span> Teacher &#123;<br><span class="hljs-built_in">string</span> t_name;<br>Student Stu[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fenpeixuesheng</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> Teacher Teach[],<span class="hljs-built_in">int</span> len</span>)</span> &#123;<br><br><span class="hljs-built_in">string</span> a_name = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>Teach[i].t_name = <span class="hljs-string">&quot;Teacher_&quot;</span>;<br>Teach[i].t_name += a_name[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>Teach[i].Stu[j].s_name = <span class="hljs-string">&quot;student_&quot;</span>;<br>Teach[i].Stu[j].s_name += a_name[j];<br>Teach[i].Stu[j].score = <span class="hljs-number">60</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>printStu.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;printStu.h&quot;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>string s_name;<br><span class="hljs-type">double</span> score;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> &#123;<br>string t_name;<br>Student Stu[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStu</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Teacher Teach[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;老师：\t&quot;</span> &lt;&lt; Teach[i].t_name &lt;&lt; <span class="hljs-string">&quot;带学生：\t&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>cout &lt;&lt; Teach[i].Stu[j].s_name &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; Teach[i].Stu[j].score &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>&#125;<br>cout &lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>&lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><p>设计一个英雄结构体，包含姓名，年龄，性别；创建结构体数组，数组中存放5名英雄。</p><p>通过冒泡排序的算法，将数组中的英雄按年龄进行升序排序，最种打印排序后的结果。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">刘备<span class="hljs-number"> 23 </span>男<br>关羽<span class="hljs-number"> 22 </span>男<br>张飞<span class="hljs-number"> 20 </span>男<br>赵云<span class="hljs-number"> 21 </span>男<br>貂蝉<span class="hljs-number"> 18 </span>女<br></code></pre></td></tr></table></figure><p><strong>main.cpp:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hero.h&quot;</span></span><br><span class="hljs-comment">//刘备 23 男</span><br><span class="hljs-comment">//关羽 22 男</span><br><span class="hljs-comment">//张飞 20 男</span><br><span class="hljs-comment">//赵云 21 男</span><br><span class="hljs-comment">//貂蝉 18 女</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>string sex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Hero s[<span class="hljs-number">5</span>] = &#123;<br>&#123;<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">23</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;貂蝉&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;女&quot;</span>&#125;<br>&#125;;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(s) / <span class="hljs-built_in">sizeof</span>(s[<span class="hljs-number">0</span>]);<br><br><span class="hljs-built_in">hero</span>(s, len);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>cout &lt;&lt; s[i].name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s[i].age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s[i].sex &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>hero.h:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hero</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Hero s[], <span class="hljs-type">int</span> len)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>hero.cpp:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">#include <span class="hljs-string">&quot;hero.h&quot;</span><br><span class="hljs-keyword">struct</span> Hero &#123;<br><span class="hljs-type">string</span> name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">string</span> sex;<br>&#125;;<br>void hero(<span class="hljs-keyword">struct</span> Hero s[], <span class="hljs-type">int</span> <span class="hljs-built_in">len</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span><span class="hljs-number">-1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span> - i; j++) &#123;<br><span class="hljs-keyword">if</span> (s[j].age &gt; s[j + <span class="hljs-number">1</span>].age) &#123;<br><span class="hljs-keyword">struct</span> Hero temp;        <span class="hljs-comment">//交换结构体可以定义个新的结构体作为临时栈</span><br>temp = s[j + <span class="hljs-number">1</span>];<br>s[j + <span class="hljs-number">1</span>] = s[j];<br>s[j] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-通讯录管理系统"><a href="#13-通讯录管理系统" class="headerlink" title="13 通讯录管理系统"></a>13 通讯录管理系统</h2><p>需要的功能：</p><p>添加联系人：信息包括（姓名，性别，年龄，联系电话，家庭住址）最多记录1000人</p><p>显示联系人：显示通讯录中所有联系人信息</p><p>删除联系人：按照姓名进行删除指定联系人</p><p>查找联系人：按照姓名查看指定联系人信息</p><p>修改联系人：按照姓名重新修改指定联系人</p><p>清空联系人：清空通讯录中所有信息</p><p>退出通讯录：退出当前使用的通讯录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//添加联系人：信息包括（姓名，性别，年龄，联系电话，家庭住址）最多记录1000人</span><br><span class="hljs-comment">//显示联系人：显示通讯录中所有联系人信息</span><br><span class="hljs-comment">//删除联系人：按照姓名进行删除指定联系人</span><br><span class="hljs-comment">//查找联系人：按照姓名查看指定联系人信息</span><br><span class="hljs-comment">//修改联系人：按照姓名重新修改指定联系人</span><br><span class="hljs-comment">//清空联系人：清空通讯录中所有信息</span><br><span class="hljs-comment">//退出通讯录：退出当前使用的通讯录</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> Max 1000</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">person</span> &#123;<br>string name;<br><span class="hljs-type">int</span> gender;<br><span class="hljs-type">int</span> age;<br>string tel;<br>string address;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">books</span> &#123;<br><span class="hljs-type">int</span> size;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">person</span> person_array[Max];<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_menu</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请选择对应的操作&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;**************&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*1.添加联系人*&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*2.显示联系人*&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*3.删除联系人*&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*4.查找联系人*&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*5.修改联系人*&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*6.清空联系人*&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*7.退出通讯录*&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_person</span><span class="hljs-params">(books* ads)</span> </span>&#123;<br><span class="hljs-comment">//判断通讯录满了吗</span><br><span class="hljs-keyword">if</span> (ads-&gt;size == Max) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;通讯录已满&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入姓名： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[ads-&gt;size].name;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入性别： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[ads-&gt;size].gender;<br><span class="hljs-keyword">if</span> ( ads-&gt;person_array[ads-&gt;size].gender == <span class="hljs-number">1</span>|| ads-&gt;person_array[ads-&gt;size].gender==<span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入有误，请重新输入：&quot;</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入年龄： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[ads-&gt;size].age;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入电话： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[ads-&gt;size].tel;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入住址： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[ads-&gt;size].address;<br>cout &lt;&lt; <span class="hljs-string">&quot;添加成功： &quot;</span>;<br>ads-&gt;size++;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_person</span><span class="hljs-params">(books* ads)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (ads-&gt;size != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ads-&gt;size; i++) &#123;<br>string a;<br><span class="hljs-keyword">if</span> (ads-&gt;person_array[i].gender == <span class="hljs-number">1</span>) &#123;<br>a = <span class="hljs-string">&quot;男&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>a = <span class="hljs-string">&quot;女&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; ads-&gt;person_array[i].name &lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>&lt;&lt;<span class="hljs-string">&quot;性别：&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>&lt;&lt;<span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt;ads-&gt;person_array[i].age&lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;电话：&quot;</span> &lt;&lt; ads-&gt;person_array[i].tel &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>&lt;&lt;<span class="hljs-string">&quot;住址：&quot;</span>&lt;&lt;ads-&gt;person_array[i].address&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有联系人&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delete_person1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> books* ads)</span> </span>&#123;<br>string del_name;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入你要删除的人：&quot;</span>;<br>cin &gt;&gt; del_name;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ads-&gt;size; i++) &#123;<br><span class="hljs-keyword">if</span> (del_name == ads-&gt;person_array[i].name) &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delete_person2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> books* ads, <span class="hljs-type">int</span> response)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (response != <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">for</span> (response; response &lt; ads-&gt;size;response++) &#123;<br>ads-&gt;person_array[response] = ads-&gt;person_array[response + <span class="hljs-number">1</span>];<br>&#125;<br>ads-&gt;size --;<br>cout &lt;&lt; <span class="hljs-string">&quot;删除成功！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;查无此人&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_person1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> books* ads)</span> </span>&#123;<br>string del_name;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入你要查找的人：&quot;</span>;<br>cin &gt;&gt; del_name;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ads-&gt;size; i++) &#123;<br><span class="hljs-keyword">if</span> (del_name == ads-&gt;person_array[i].name) &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search_person2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> books* ads, <span class="hljs-type">int</span> response)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (response != <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; ads-&gt;person_array[response].name &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span> &lt;&lt; ads-&gt;person_array[response]. gender &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; ads-&gt;person_array[response].age &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;电话：&quot;</span> &lt;&lt; ads-&gt;person_array[response].tel &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;住址：&quot;</span> &lt;&lt; ads-&gt;person_array[response].address &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;查无此人&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update_person1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> books* ads)</span> </span>&#123;<br>string del_name;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入你要修改的人：&quot;</span>;<br>cin &gt;&gt; del_name;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ads-&gt;size; i++) &#123;<br><span class="hljs-keyword">if</span> (del_name == ads-&gt;person_array[i].name) &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_person2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> books* ads, <span class="hljs-type">int</span> response)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (response != <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;你即将修改：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; ads-&gt;person_array[response].name&lt;&lt;endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入姓名： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[response].name;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入性别： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[response].gender;<br><span class="hljs-keyword">if</span> (ads-&gt;person_array[response].gender == <span class="hljs-number">1</span> || ads-&gt;person_array[response].gender == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入有误，请重新输入：&quot;</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入年龄： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[response].age;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入电话： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[response].tel;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入住址： &quot;</span>;<br>cin &gt;&gt; ads-&gt;person_array[response].address;<br>cout &lt;&lt; <span class="hljs-string">&quot;添加成功： &quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;查无此人&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cls&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> response = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> select = <span class="hljs-number">0</span>;<br>books ads;<br>ads.size = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">show_menu</span>();<br>cin &gt;&gt; select;<br><span class="hljs-keyword">switch</span> (select) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">//1.添加联系人</span><br><span class="hljs-built_in">add_person</span>(&amp;ads);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-comment">//显示联系人</span><br><span class="hljs-built_in">display_person</span>(&amp;ads);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-comment">//删除联系人</span><br>&#123;<br>response = <span class="hljs-built_in">delete_person1</span>(&amp;ads);<br><span class="hljs-built_in">delete_person2</span>(&amp;ads,response);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-comment">//查找联系人</span><br>&#123;<br>response = <span class="hljs-built_in">search_person1</span>(&amp;ads);<br><span class="hljs-built_in">search_person2</span>(&amp;ads, response);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-comment">//修改联系人</span><br>&#123;<br>response = <span class="hljs-built_in">update_person1</span>(&amp;ads);<br><span class="hljs-built_in">update_person2</span>(&amp;ads, response);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-comment">//清空联系人</span><br>&#123;ads.size = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;联系人已清空&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<span class="hljs-comment">//退出通讯录</span><br>cout &lt;&lt; <span class="hljs-string">&quot;谢谢你的使用，祝你生活愉快！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;你的输入有误，请输入1到7&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dockers学习笔记</title>
    <link href="/2022/04/30/docker%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/30/docker%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、安装Docker"><a href="#一、安装Docker" class="headerlink" title="一、安装Docker"></a>一、安装Docker</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、yum 包更新到最新</span> <br>yum update<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span> <br>yum install -y yum-utils device-mapper-persistent-data lvm2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3、 设置yum源</span><br>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4、 安装docker，出现输入的界面都按 y</span> <br>yum install -y docker-ce<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5、 查看docker版本，验证是否验证成功</span><br>docker -v<br><br></code></pre></td></tr></table></figure><p>xxxxxxxxxx #拉取镜像 docker pull 私有仓库服务器ip:5000&#x2F;centos:7shell</p><h1 id="二、Dockerfile"><a href="#二、Dockerfile" class="headerlink" title="二、Dockerfile"></a>二、Dockerfile</h1><table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是&#x2F;bin&#x2F;sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name&#x3D;value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080&#x2F;udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F; 使用的是绝对地址 如果不是&#x2F;开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table><h1 id="三、Docker-私有仓库"><a href="#三、Docker-私有仓库" class="headerlink" title="三、Docker 私有仓库"></a>三、Docker 私有仓库</h1><h2 id="1、私有仓库搭建"><a href="#1、私有仓库搭建" class="headerlink" title="1、私有仓库搭建"></a>1、私有仓库搭建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、拉取私有仓库镜像</span> <br>docker pull registry<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、启动私有仓库容器</span> <br>docker run -id --name=registry -p 5000:5000 registry<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="hljs-string">&quot;repositories&quot;</span>:[]&#125; 表示私有仓库 搭建成功</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4、修改daemon.json</span>   <br>vim /etc/docker/daemon.json    <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip</span> <br>&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">5、重启docker 服务</span> <br>systemctl restart docker<br>docker start registry<br><br></code></pre></td></tr></table></figure><h2 id="2、将镜像上传至私有仓库"><a href="#2、将镜像上传至私有仓库" class="headerlink" title="2、将镜像上传至私有仓库"></a>2、将镜像上传至私有仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、标记镜像为私有仓库的镜像</span>     <br>docker tag centos:7 私有仓库服务器IP:5000/centos:7<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2、上传标记的镜像</span>     <br>docker push 私有仓库服务器IP:5000/centos:7<br><br></code></pre></td></tr></table></figure><h2 id="3、-从私有仓库拉取镜像"><a href="#3、-从私有仓库拉取镜像" class="headerlink" title="3、 从私有仓库拉取镜像"></a>3、 从私有仓库拉取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">拉取镜像</span> <br>docker pull 私有仓库服务器ip:5000/centos:7<br></code></pre></td></tr></table></figure><h1 id="四、Docker-应用部署"><a href="#四、Docker-应用部署" class="headerlink" title="四、Docker 应用部署"></a>四、Docker 应用部署</h1><h2 id="1、部署MySQL"><a href="#1、部署MySQL" class="headerlink" title="1、部署MySQL"></a>1、部署MySQL</h2><ol><li>搜索mysql镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search mysql<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取mysql镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql:5.6<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在/root目录下创建mysql目录用于存储mysql数据信息</span><br>mkdir ~/mysql<br>cd ~/mysql<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id \<br>-p 3307:3306 \<br>--name=c_mysql \<br>-v $PWD/conf:/etc/mysql/conf.d \<br>-v $PWD/logs:/logs \<br>-v $PWD/data:/var/lib/mysql \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>mysql:5.6<br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。</li><li><strong>-v $PWD&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</strong>：将主机当前目录下的 conf&#x2F;my.cnf 挂载到容器的 &#x2F;etc&#x2F;mysql&#x2F;my.cnf。配置目录</li><li><strong>-v $PWD&#x2F;logs:&#x2F;logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 &#x2F;logs。日志目录</li><li><strong>-v $PWD&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</strong> ：将主机当前目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 。数据目录</li><li>**-e MYSQL_ROOT_PASSWORD&#x3D;123456：**初始化 root 用户的密码。</li></ul></li></ul><ol start="4"><li>进入容器，操作mysql</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec –it c_mysql /bin/bash<br></code></pre></td></tr></table></figure><ol start="5"><li>使用外部机器连接容器中的mysql</li></ol><p><img src="/../images/1573636765632.png" alt="1573636765632"></p><h2 id="2、部署Tomcat"><a href="#2、部署Tomcat" class="headerlink" title="2、部署Tomcat"></a>2、部署Tomcat</h2><ol><li>搜索tomcat镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search tomcat<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取tomcat镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull tomcat<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在/root目录下创建tomcat目录用于存储tomcat数据信息</span><br>mkdir ~/tomcat<br>cd ~/tomcat<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_tomcat \<br>-p 8080:8080 \<br>-v $PWD:/usr/local/tomcat/webapps \<br>tomcat <br></code></pre></td></tr></table></figure><ul><li><p>参数说明：</p><ul><li><p>**-p 8080:8080：**将容器的8080端口映射到主机的8080端口</p><p>**-v $PWD:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps：**将主机中当前目录挂载到容器的webapps</p></li></ul></li></ul><ol start="4"><li>使用外部机器访问tomcat</li></ol><p><img src="/../images/1573649804623.png" alt="1573649804623"></p><h2 id="3、部署Nginx"><a href="#3、部署Nginx" class="headerlink" title="3、部署Nginx"></a>3、部署Nginx</h2><ol><li>搜索nginx镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search nginx<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取nginx镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在/root目录下创建nginx目录用于存储nginx数据信息</span><br>mkdir ~/nginx<br>cd ~/nginx<br>mkdir conf<br>cd conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span><br>vim nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">user  nginx;<br>worker_processes  1;<br><br>error_log  /var/log/nginx/error.log warn;<br>pid        /var/run/nginx.pid;<br><br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br><br>http &#123;<br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;<br><br>    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>    access_log  /var/log/nginx/access.log  main;<br><br>    sendfile        on;<br>    #tcp_nopush     on;<br><br>    keepalive_timeout  65;<br><br>    #gzip  on;<br><br>    include /etc/nginx/conf.d/*.conf;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_nginx \<br>-p 80:80 \<br>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \<br>-v $PWD/logs:/var/log/nginx \<br>-v $PWD/html:/usr/share/nginx/html \<br>nginx<br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li><li><strong>-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</strong>：将主机当前目录下的 &#x2F;conf&#x2F;nginx.conf 挂载到容器的 :&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。配置目录</li><li><strong>-v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx。日志目录</li></ul></li></ul><ol start="4"><li>使用外部机器访问nginx</li></ol><p><img src="/../images/1573652396669.png" alt="1573652396669"></p><h2 id="4、部署Redis"><a href="#4、部署Redis" class="headerlink" title="4、部署Redis"></a>4、部署Redis</h2><ol><li>搜索redis镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search redis<br></code></pre></td></tr></table></figure><ol start="2"><li>拉取redis镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis:5.0<br></code></pre></td></tr></table></figure><ol start="3"><li>创建容器，设置端口映射</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_redis -p 6379:6379 redis:5.0<br></code></pre></td></tr></table></figure><ol start="4"><li>使用外部机器连接redis</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./redis-cli.exe -h 192.168.149.135 -p 6379<br></code></pre></td></tr></table></figure><h1 id="五、Docker-Compose"><a href="#五、Docker-Compose" class="headerlink" title="五、Docker Compose"></a>五、Docker Compose</h1><h2 id="1、安装Docker-Compose"><a href="#1、安装Docker-Compose" class="headerlink" title="1、安装Docker Compose"></a>1、安装Docker Compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。</span> <br>curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置文件可执行权限</span> <br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看版本信息</span> <br>docker-compose -version<br></code></pre></td></tr></table></figure><h2 id="2、卸载Docker-Compose"><a href="#2、卸载Docker-Compose" class="headerlink" title="2、卸载Docker Compose"></a>2、卸载Docker Compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span><br>rm /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h2 id="3、-使用docker-compose编排nginx-springboot项目"><a href="#3、-使用docker-compose编排nginx-springboot项目" class="headerlink" title="3、 使用docker compose编排nginx+springboot项目"></a>3、 使用docker compose编排nginx+springboot项目</h2><ol><li>创建docker-compose目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/docker-compose<br>cd ~/docker-compose<br></code></pre></td></tr></table></figure><ol start="2"><li>编写 docker-compose.yml 文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  nginx:<br>   image: nginx<br>   ports:<br>    - 80:80<br>   links:<br>    - app<br>   volumes:<br>    - ./nginx/conf.d:/etc/nginx/conf.d<br>  app:<br>    image: app<br>    expose:<br>      - &quot;8080&quot;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建.&#x2F;nginx&#x2F;conf.d目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ./nginx/conf.d<br></code></pre></td></tr></table></figure><ol start="4"><li>在.&#x2F;nginx&#x2F;conf.d目录下 编写itheima.conf文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>    listen 80;<br>    access_log off;<br><br>    location / &#123;<br>        proxy_pass http://app:8080;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br></code></pre></td></tr></table></figure><ol start="6"><li>测试访问</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://192.168.149.135/hello<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存模型和C++文件操作</title>
    <link href="/2022/04/30/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B&amp;%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/04/30/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B&amp;%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="C-核心编程（面向对象）"><a href="#C-核心编程（面向对象）" class="headerlink" title="C++核心编程（面向对象）"></a>C++核心编程（面向对象）</h1><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1. 内存分区模型"></a>1. 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为4个区域</p><ol><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li></ol><p><strong>内存四区的意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>在程序编译后，生成了exe可执行文件，<strong>未执行该程序前</strong>分为两个区域</p><p><strong>代码区：</strong></p><p>​存放cpu执行的机器指令</p><p>​代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p><strong>全局区：</strong></p><p>​全局变量和静态变量存放在此</p><p>​全局区还包含了常量区，字符串常量和其他常量也存放在此</p><p>​该区域的数据在程序结束后由操作系统释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g_b = <span class="hljs-number">11</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> g_c_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> g_c_b = <span class="hljs-number">11</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//全局区</span><br><br><span class="hljs-comment">//全局变量、静态变量、变量</span><br><br><span class="hljs-comment">//创建普通局部变量</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">11</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_b = <span class="hljs-number">11</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_b = <span class="hljs-number">11</span>;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量a：  \t&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl; <br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量b：  \t&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl; <br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_a：  \t&quot;</span> &lt;&lt; &amp;g_a &lt;&lt; endl; <br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_b：  \t&quot;</span> &lt;&lt; &amp;g_b &lt;&lt; endl; <br><br>cout &lt;&lt; <span class="hljs-string">&quot;局部静态变量s_a：&quot;</span> &lt;&lt; &amp;s_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部静态变量s_b：&quot;</span> &lt;&lt; &amp;s_b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;字符串常量：   \t&quot;</span> &lt;&lt; &amp;<span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量g_c_a：\t&quot;</span> &lt;&lt; &amp;g_c_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量g_c_b：\t&quot;</span> &lt;&lt; &amp;g_c_b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_a：\t&quot;</span> &lt;&lt; &amp;c_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_b：\t&quot;</span> &lt;&lt; &amp;c_b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>全局区：全局变量，静态变量，static关键字，常量，字符串常量，const修饰的全局变量（全局常量）</p><p>不在全局区：局部变量，const修饰的局部变量（局部常量）</p><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p> 栈区：</p><p>​由编译器自动分配释放，存放函数的参数值，局部变量等</p><p>​注意事项：<strong>不要返回局部变量的地址</strong>，栈区开辟的数据由编译器自动释放</p><p>​局部变量存放在栈区，栈区的数据在函数执行完后自动释放</p><p>​</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">int* <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br>&#123;<br>int a=<span class="hljs-number">10</span>;   <span class="hljs-comment">//局部变量 存放在栈区，栈区的数据在函数执行完后自动释放</span><br><span class="hljs-keyword">return</span> &amp;a;  <span class="hljs-comment">//返回局部变量地址</span><br>&#125;<br>int main()&#123;<br>int* p = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>cout &lt;&lt; *p&lt;&lt;endl;   <span class="hljs-comment">//第一次可以打印正确的数据他会给你保留，</span><br>cout &lt;&lt; *p&lt;&lt;endl;   <span class="hljs-comment">//第二次不会保留了，非法操作</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>堆区：</p><p>​由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p><p>​在C++中主要利用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//指针本身也是局部变量，放在栈上，指针保存的数据在堆上 </span><br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//在堆区开辟数据</span><br><span class="hljs-type">int</span>* p=<span class="hljs-built_in">func</span>();<br>cout &lt;&lt; *p &lt;&lt;endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>C++中利用new操作符在堆区开辟数据</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete</p><p>语法： new 数据类型</p><p>利用new创建的数据，会<strong>返回该数据对应的类型的指针</strong></p><p>基本语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//在堆区创建整形数据</span><br>    <span class="hljs-comment">//new返回是该数据类型的指针</span><br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    <span class="hljs-comment">//堆区的数据，由程序员管理开辟，程序员释放</span><br>    <span class="hljs-comment">//如果想要释放堆区的数据，利用关键字delete</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-comment">//cout &lt;&lt; *p&lt;&lt;endl; //内存已经释放，再次输访问就是非法操作，会报错</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//在堆区创建10整型数组</span><br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这里是中括号，10代表有10个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        arr[i] = i + <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] arr;<span class="hljs-comment">//释放数组要加[]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test1</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>作用：给变量起别名</p><p>语法：数据类型 &amp;别名 &#x3D; 原名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp; b = a;<br></code></pre></td></tr></table></figure><h3 id="2-2-引用的注意事项"><a href="#2-2-引用的注意事项" class="headerlink" title="2.2 引用的注意事项"></a>2.2 引用的注意事项</h3><p>引用必须初始化</p><p>引用在初始化后不可改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> &amp;b = a;<br><span class="hljs-comment">//1.引用必须初始化</span><br><span class="hljs-comment">//int &amp;b; //错误的，必须上来就告知是谁的别名</span><br><span class="hljs-comment">//2.引用在初始化后不可改变</span><br>b = c; <span class="hljs-comment">//赋值无问题</span><br><span class="hljs-comment">//当b是a的别名后，不能再将b改成c的别名</span><br></code></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p>作用：函数传递时，可以利用引用的技术让形参修饰实参</p><p>优点：可以简化指针修改实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//交换函数</span><br><span class="hljs-comment">//1.值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap01</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp =a;<br>    a=b;<br>    b=temp;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//2.地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap02</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span></span>&#123;<br>    <span class="hljs-type">int</span>* temp =*a;<br>    *a=*b;<br>    *b=*temp;<br>&#125; <br><span class="hljs-comment">//3.引用   引用传递，形参也会修饰实参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap03</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp =a;<br>    a=b;<br>    b=temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-引用做函数的返回值"><a href="#2-4-引用做函数的返回值" class="headerlink" title="2.4 引用做函数的返回值"></a>2.4 引用做函数的返回值</h3><p>不要返回局部变量的引用</p><p>函数的调用可以作为左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//引用做函数的返回值</span><br><span class="hljs-comment">//1.不要返回局部变量的引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;   <span class="hljs-comment">//存放在栈区，用了后会释放，打印一次显示正常以为你是误操作就做了保留，第二次就不对了</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-comment">//2.函数的调用可以作为左值</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>; <span class="hljs-comment">//静态变量，存放在全局区，全局区的数据在程序结束后系统释放</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>&amp; ref =<span class="hljs-built_in">test01</span>();<br>    cout &lt;&lt;ref&lt;&lt;endl;<span class="hljs-comment">//第一次结果正确，是因为编译器做了保留</span><br>    cout &lt;&lt;ref&lt;&lt;endl;<span class="hljs-comment">//第二次结果错误，因为a的内存已经释放</span><br>    <br>    <span class="hljs-type">int</span>&amp; ref =<span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">test02</span>() = <span class="hljs-number">1000</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：引用的本质在C++内部实现是一个指针常量</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p>作用：修饰形参，防止误操作</p><p>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_value</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; val)</span></span>&#123;<br><span class="hljs-comment">//val = 1000; //误操作改了实参</span><br>cout&lt;&lt;val&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//常量引用</span><br><span class="hljs-comment">//使用场景：用来修饰形参，防止误操作</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int a =10;</span><br><span class="hljs-comment">// int &amp; ref = 10;//不能引用常量</span><br><span class="hljs-comment">//引用必须引一块合法的内存空间</span><br><span class="hljs-comment">const int &amp;ref = 10;//加上const后 编译器将代码修改 int temp =10; int&amp; ref = temp;</span><br><span class="hljs-comment">//ref = 20;//报错，加入const后变为只读，不可以修改</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> a =<span class="hljs-number">100</span>;<br><span class="hljs-built_in">show_value</span>(a);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3.函数提高"></a>3.函数提高</h2><h3 id="3-1-函数的默认参数"><a href="#3-1-函数的默认参数" class="headerlink" title="3.1 函数的默认参数"></a>3.1 函数的默认参数</h3><p>在C++中函数的形参列表中的形参是可以有默认值的</p><p>语法： 返回值类型 函数名 （参数 &#x3D; 默认值）{}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a , b = <span class="hljs-number">1</span>, c = <span class="hljs-number">4</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>如果某个位置有了默认参数，后面的都得有默认参数</p><p>如果声明有了默认参数，函数实现就不能有默认参数（歧义）</p><p>声明和实现只能有一个默认参数</p><h3 id="3-2-函数的占位参数"><a href="#3-2-函数的占位参数" class="headerlink" title="3.2 函数的占位参数"></a>3.2 函数的占位参数</h3><p>C++函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p>语法： 返回值类型 函数名(数据类型){}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>)</span></span>&#123;<br>    <br>&#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>占位参数还可以有默认参数</p><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h3 id="3-3-1-函数重载实现"><a href="#3-3-1-函数重载实现" class="headerlink" title="3.3.1 函数重载实现"></a>3.3.1 函数重载实现</h3><p>作用：函数名相同，提高复用性</p><p>函数重载满足条件：</p><p>同一作用域下</p><p>函数名相同</p><p>函数参数类型不同 或者 个数不同 或者 顺序不同</p><p>注意：函数的返回值不可以作为函数重载的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数重载的满足条件</span><br><span class="hljs-comment">//1.同一作用域下</span><br><span class="hljs-comment">//2.函数名称相同</span><br><span class="hljs-comment">//3.函数参数类型不同，或者个数不同，或者顺序不同</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">double</span> c)</span></span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a , <span class="hljs-type">int</span> c)</span></span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-built_in">func</span>();<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>,<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//函数的返回值不可以作为函数重载的条件</span><br><span class="hljs-comment">//int func(double a , int c)&#123;</span><br><span class="hljs-comment">//    cout &lt;&lt;&quot;func调用&quot;&lt;&lt;endl;</span><br><span class="hljs-comment">//    return 0;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//产生了歧义</span><br></code></pre></td></tr></table></figure><h3 id="3-3-2-函数重载的注意事项"><a href="#3-3-2-函数重载的注意事项" class="headerlink" title="3.3.2 函数重载的注意事项"></a>3.3.2 函数重载的注意事项</h3><p>引用作为重载条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a);<span class="hljs-comment">//执行第一个，a是变量，指针常量允许指针指向的值发生改变</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//10为常量，应用const即修饰指针，又修饰常量 才合法</span><br></code></pre></td></tr></table></figure><p>函数重载碰到函数默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a , b = <span class="hljs-number">10</span>)</span></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用哪一个？只有注意 当我使用函数重载时不要定义默认参数</span><br></code></pre></td></tr></table></figure><p><strong>当我使用函数重载时不要定义默认参数</strong></p><h1 id="C-文件操作"><a href="#C-文件操作" class="headerlink" title="C++文件操作"></a>C++文件操作</h1><p>程序运行时产生的数据都属于零时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将<strong>数据持久化</strong></p><p>C++中对文件操作需要包含头文件<fstream></p><p>文件分为两种：</p><ol><li><p>文本文件 - 文件以文本的<strong>Ascll码</strong>形式存储在计算机中</p></li><li><p>二进制文件 - 文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</p></li></ol><p>操作文件的三大类：</p><ol><li>ofstream ：写操作</li><li>ifstream ：读操作</li><li>fstram ：读写操作</li></ol><h2 id="2-1-写文件"><a href="#2-1-写文件" class="headerlink" title="2.1 写文件"></a>2.1 写文件</h2><p>写文件步骤</p><ol><li><p>包含头文件</p><p>​    #include<fstream></p></li><li><p>创建流对象</p><p>​    ofstream ofs;</p></li><li><p>打开文件</p><p>​    ofs.open(“文件路径”, 打开方式);</p></li><li><p>写数据</p><p>​    ofs&lt;&lt;”写入的数据”;</p></li><li><p>关闭的文件</p><p>​    ofs.close();</p></li></ol><p>文件的打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p>写入示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ofstream ofs;<br>    ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;读写.txt&quot;</span>, ios::out);<br>    ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;<br>    ofs &lt;&lt; <span class="hljs-string">&quot;对手：罗翔&quot;</span> &lt;&lt; endl;<br>    ofs.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类C循环写入，遇到 ’#‘ 停止写入，ascll &#x3D; 35</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//#include&lt;fstream&gt;</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>FILE* fp;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-comment">//cin.get(ch);</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;lrl.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-keyword">if</span> (fp != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">while</span> ((ch = <span class="hljs-built_in">getchar</span>()) != <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br><span class="hljs-built_in">fputc</span>(ch, fp);<br>&#125;<br><span class="hljs-built_in">fclose</span>(fp);<br>&#125;<br><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>cFILE和fstream区别，待定</p><h2 id="2-2-读文件"><a href="#2-2-读文件" class="headerlink" title="2.2 读文件"></a>2.2 读文件</h2><ol><li><p>包含头文件</p><p>​    #include<fstream></p></li><li><p>创建流对象</p><p>​    ifstream ifs;</p></li><li><p>打开文件</p><p>​    ifs.open(“文件路径”, 打开方式);</p></li><li><p>写数据</p><p>​    四种方式读取</p></li><li><p>关闭的文件</p><p>​    ifs.close();</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    ifstream ifs;<br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;读写.txt&quot;</span>, ios::in);<br>    <span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;打开失败&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//读文件</span><br>    <span class="hljs-comment">//第一种</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">    while (ifs &gt;&gt; buf) &#123;//&gt;&gt;右移运算符将ifs复制到buf中</span><br><span class="hljs-comment">        cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">//第二种</span><br><br>    <span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br>    <span class="hljs-comment">//while (ifs.getline(buf, sizeof(buf))) &#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br><br><br>    <span class="hljs-comment">//第三种</span><br>    <span class="hljs-comment">//string buf;</span><br>    <span class="hljs-comment">//while (getline(ifs, buf)) &#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//第四种,一般不用</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF) &#123;<br>        cout &lt;&lt; c ;<br>    &#125;<br><br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-3-二进制文件"><a href="#2-3-二进制文件" class="headerlink" title="2.3 二进制文件"></a>2.3 二进制文件</h2><p>以二进制的方式对文件进行读写操作</p><p>打开方式为 ios::binary</p><h3 id="2-3-1-写二进制文件"><a href="#2-3-1-写二进制文件" class="headerlink" title="2.3.1 写二进制文件"></a>2.3.1 写二进制文件</h3><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型：  ostream&amp; write(const char* buffer,int len);</p><p>参数解释：字符buffer指向内存中一段存储空间，len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_age;<br>    <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;write1.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br>    <span class="hljs-comment">//ofs.open(&quot;写二进制文件.txt&quot;, ios::out | ios::binary);</span><br>    Person p = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span> &#125;;<br>    ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)&amp;p, <span class="hljs-built_in">sizeof</span>(Person));<br>    ofs.<span class="hljs-built_in">close</span>();<br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-3-2-读二进制文件"><a href="#2-3-2-读二进制文件" class="headerlink" title="2.3.2  读二进制文件"></a>2.3.2  读二进制文件</h3><p>函数原型：  istream&amp; read(char* buffer, int len);</p><p>参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    ifstream ifs;<br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;write1.txt&quot;</span>, ios::in | ios::binary);<br>    <span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;打开失败&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Person p;<br>    ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p, <span class="hljs-built_in">sizeof</span>(Person));<br>    cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; p.m_name &lt;&lt; <span class="hljs-string">&quot;   年龄：&quot;</span> &lt;&lt; p.m_age &lt;&lt; endl;<br><br>    ifs.<span class="hljs-built_in">close</span>();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++</title>
    <link href="/2022/04/30/Effective-C++/"/>
    <url>/2022/04/30/Effective-C++/</url>
    
    <content type="html"><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><ol><li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li><li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li><li>尽可能使用 const</li><li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li><li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li><li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li><li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li><li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li><li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li><li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li><li>在 <code>operator=</code> 中处理 “自我赋值”</li><li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li><li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li><li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li><li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li><li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li><li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li><li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li><li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li><li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li><li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li><li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li><li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li><li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li><li>考虑写一个不抛异常的 swap 函数</li><li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li><li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li><li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li><li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li><li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li><li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li><li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li><li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li><li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li><li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li><li>绝不重新定义继承而来的 non-virtual 函数</li><li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li><li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））</li><li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）</li><li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）</li><li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）</li><li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）</li><li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-&gt;</code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）</li><li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）</li><li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）</li><li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）</li><li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）</li><li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）</li><li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）</li><li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）</li><li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）</li><li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）</li><li>不要轻忽编译器的警告</li><li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）</li><li>让自己熟悉 Boost（准标准库）</li></ol><h1 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h1><ol><li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）</li><li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）</li><li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）</li><li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）</li><li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）</li><li>区别 increment&#x2F;decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）</li><li>千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&amp;&amp;</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）</li><li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）</li><li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）</li><li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）</li><li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）</li><li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）</li><li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）</li><li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）</li><li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）</li><li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）</li><li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）</li><li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</li></ol><h1 id="Effective-C-详解"><a href="#Effective-C-详解" class="headerlink" title="Effective C++详解"></a>Effective C++详解</h1><h1 id="一-让自己习惯C"><a href="#一-让自己习惯C" class="headerlink" title="一. 让自己习惯C++"></a>一. 让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>我们可以把C++理解为相关语言组成的联邦而非单一语言。包括</p><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++ </li><li>STL</li></ul><p>C++刚被推出时是C的加强版，加了一些面向对象的特性。最初的名称为C with Classes。随着时代的进步，C++不断发展，有了各种特性。 现在的C++是一个多重范型编程语言，它支持支持过程形式、支持面向对象形式Object-Oriented C++、函数形式、泛型形式、元编程形式（Template C++，STL)、这些能力使得c++成为一个无可匹敌的工具</p><h2 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const,enum,inline替换#define"></a>条款02：尽量以const,enum,inline替换#define</h2><p><strong>这个条款或许改为“宁可以编译器替换预处理器”比较好</strong></p><h3 id="1）以const替换-define"><a href="#1）以const替换-define" class="headerlink" title="1）以const替换#define"></a>1）以const替换#define</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br>替换为：<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> AspectRatio = <span class="hljs-number">1.653</span><br></code></pre></td></tr></table></figure><ul><li><strong>调试的需要</strong>：#define的记号会被预处理器移走，记号名称可能没进入记号表内。因此当#define的宏名称获得一个编译错误时，会引起困惑，浪费大量时间追踪错误。而AspectRatio肯定会被编译器看到</li><li><strong>更小的代码量</strong>：对浮点数而言，使用常量可能比使用#define导致较小量的代码，因为预处理器“盲目地将ASPECT_RATIO替换为1.653”可能导致目标码出现多份1.653</li></ul><p>但是，以常量替换#define时要注意：</p><ul><li><p>定义常量指针时：由于常量定义式通常被定义在头文件内，因此有必要将指针声明为const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> authorName = <span class="hljs-string">&quot;Scott Meyers&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>class专属常量：class专属常量需要声明在class内部，并且被class使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>; <span class="hljs-comment">//常量声明式</span><br>    <span class="hljs-type">int</span> scores[NumTurns];          <span class="hljs-comment">//使用该常量</span><br>&#125;;<br><span class="hljs-comment">//通常定义出现在头文件中</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns;    <span class="hljs-comment">//NumTurns的定义</span><br></code></pre></td></tr></table></figure><p>对于static修饰的class专属整形常量，如果需要对该常量取地址或编译器坚持要看到一个定义式。那么必须提供类外定义。如果类内声明时提供了初始值，类外定义就不能再设初值。但是某些编译器可能不支持类内初始值，因此需要在类外定义时提供初始值，但是这样就不能像scores成员一样，在类内使用该常量。因此，如果需要使用class专属常量，最好改用“enum hack”</p></li></ul><h3 id="2）以enum替换-define"><a href="#2）以enum替换-define" class="headerlink" title="2）以enum替换#define"></a>2）以enum替换#define</h3><p>正如上面所提到的，编译器可能不支持类内初始值，因此改用”<strong>enum hack</strong>“：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns = <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];   <span class="hljs-comment">//这就没问题了</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>enum hack</strong>的行为比较像#define而不像const。例如取一个const的地址时合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法</p><h3 id="3）以inline替换-define"><a href="#3）以inline替换-define" class="headerlink" title="3）以inline替换#define"></a>3）以inline替换#define</h3><p>以#define实现宏看起来像函数，并且不会导致函数调用带来的开销，但是可能引发错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ?  (a) : (b))</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b);       <span class="hljs-comment">//a被累加2次</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b + <span class="hljs-number">10</span>);  <span class="hljs-comment">//a被累加1次</span><br></code></pre></td></tr></table></figure><p>使用inline函数可以减轻为参数加上括号以及参数被核算多次等问题。同时，inline可以实现一个“类内的private inline函数”，但一般而言宏无法完成此事</p><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><h3 id="1）const修饰变量"><a href="#1）const修饰变量" class="headerlink" title="1）const修饰变量"></a>1）const修饰变量</h3><p>如果变量本身不应该被修改，应该使用const修饰。这样编译器可以进行保护，确保这个变量不会被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> *p = greeting;                    <span class="hljs-comment">// non-const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = greeting;              <span class="hljs-comment">// non-const pointer, const data</span><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;             <span class="hljs-comment">// const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;       <span class="hljs-comment">// const pointer, const data </span><br></code></pre></td></tr></table></figure><ul><li>如果关键字const出现在星号左边，表示被指物是常量</li><li>如果出现在星号右边，表示指针自身是常量</li></ul><h3 id="2）const修饰函数"><a href="#2）const修饰函数" class="headerlink" title="2）const修饰函数"></a>2）const修饰函数</h3><ul><li>修饰参数时，和修饰一般变量相同</li><li><strong>修饰返回值，可以降低因客户错误而造成的意外</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Rational a, b, c;<br>...<br><span class="hljs-keyword">if</span> (a * b = c)&#123; <span class="hljs-comment">//其实是想做一个比较动作，使用const修饰返回值可以避免这种错误</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果a和b都是内置类型。这样的代码直截了当就是不合法。而一个“良好的用户自定义类型”的特征是他们避免与内置类型不兼容。因此对operator*的定义应该如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure><h3 id="3）const修饰成员函数"><a href="#3）const修饰成员函数" class="headerlink" title="3）const修饰成员函数"></a>3）const修饰成员函数</h3><p>const修饰成员函数有2个好处：</p><ol><li><strong>可读性</strong>：使得接口容易被理解，可以知道哪个函数可以改动对象哪个函数不行</li><li><strong>const修饰的成员函数可以作用于const对象</strong></li></ol><p>但是，使用const修饰成员函数时需要注意，C++对常量性的定义是bitwise constness，即函数const成员函数不应该修改对象的任何成员变量。因此，如果成员变量是一个指针，那么不修改指针而修改指针所指之物，也符合bitwise constness，因此如果不是从bitwise constness的角度，这样也是修改了对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>   <span class="hljs-comment">// bitwise constness声明</span><br>  &#123; <span class="hljs-keyword">return</span> pText[position]; &#125;                    <span class="hljs-comment">// 但其实不恰当</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">char</span>* pText;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> CTextBlock <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>; <span class="hljs-comment">//声明一个常量对象</span><br><span class="hljs-type">char</span> *pc = &amp;cctb[<span class="hljs-number">0</span>];            <span class="hljs-comment">//调用const operator[]取得一个指针，</span><br>                                <span class="hljs-comment">//指向cctb的数据</span><br>*pc = <span class="hljs-string">&#x27;J&#x27;</span>;                      <span class="hljs-comment">//cctb现在有了“Jello”这样的内容</span><br></code></pre></td></tr></table></figure><p>还有一种logical constness：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 最近一次计算的文本区块长度</span><br>  <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 目前的长度是否有效</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//错误！在const成员函数内不能复制给</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//textLength和lengthIsValid</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，C++对常量性的定义是bitwise constness的，所以这样的操作非法。解决办法是使用mutable:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 这些成员变量可能总是会被更改</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 即使在const成员函数内</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//现在可以这样</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//也可以这样</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，上面提到了2种“修改”const成员函数中修改对象（修改const对象）的方法</p><p>最后，const和non-const版本的函数可能含有重复的代码，如果抽离出来单独成为一个成员函数还是有重复。如果希望去重，可以使用“运用const成员函数实现出其non-const孪生兄弟”的技术：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)<br>                [pos]   <br>        );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h2><p><strong>读取未初始化对象的后果</strong>：读取未被初始化的值会导致不明确的行为。在某些平台上，仅仅只是读取未初始化的值就可能让程序终止，更可能的情况是读入一些“半随机”bits，污染了正在进行读取动作的那个对象，最终导致不可预知的程序行为，以及许多令人不愉快的调试过程</p><p>按对象的类型划分：</p><ul><li><p><strong>对于内置类型的对象</strong>：永远在使用前初始化</p></li><li><p>类类型的对象</p><p>：初始化责任落在构造函数身上</p><ul><li><p>效率上的问题</p><p>：</p><ul><li>类类型成员的初始化动作发生在构造函数本体之前。比起先调用default构造函数然后再调用copy assignment操作符，单只调用一次copy构造函数比较高效。因此，善用初始化列表有助于提升效率</li><li>内置类型成员的初始化不一定发生在赋值动作的的时间点之前 。对于内置类型成员，一般为了保持一致也在初始化列表中给出初始值</li></ul></li><li><p><strong>初始化顺序</strong>：成员的初始化顺序与类内声明顺序相同</p></li></ul></li></ul><p>按对象的作用域与生命周期划分</p><ul><li><p>static对象</p><ul><li><p>non-local static对象</p><p>：C++对“定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确定义</p><ul><li>global对象</li><li>定义于namespace作用域内的对象</li><li>classes内、file作用域内被声明为static的对象</li></ul></li><li><p>local static对象</p><p>：函数内的local static对象会在“该函数被调用期间、首次遇上该对象的定义式”时被初始化</p><ul><li>函数内被声明为static的对象</li></ul></li></ul></li></ul><p>因此，如果一个non-local static对象的初始化依赖于另外一个non-local static的初始化，那么可能造成错误。解决方法是使用local static对象替换non-local static对象（参考单例模式）</p><h1 id="二-构造-析构-赋值运算"><a href="#二-构造-析构-赋值运算" class="headerlink" title="二.构造&#x2F;析构&#x2F;赋值运算"></a>二.构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><p>一般情况下，编译器会为类合成下列函数：</p><ul><li><strong>default构造函数</strong></li><li><strong>copy构造函数</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li><li><strong>copy assignment操作符</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li><li><strong>析构函数</strong>：编译器生成的版本是<strong>non-virtual</strong>的</li></ul><p><a href="https://github.com/arkingc/note/blob/master/C%2B%2B/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.md#%E7%AC%AC2%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E6%84%8F%E5%AD%A6">更深层次的理解</a>（对象模型第2章、第5章）</p><p>以下情况编译器不会合成<strong>copy assignment操作符</strong>：</p><ul><li><strong>含有引用成员</strong>：原因在于这种情况下，赋值的目的不明确。是修改引用还是修改引用的对象？如果是修改引用，这是被禁止的。因此编译器干脆拒绝这样的赋值行为</li><li><strong>含有const成员</strong>：const对象不应该修改</li><li><strong>父类的copy assignment操作符被声明为private</strong>：无法处理基类子对象，因此也就无法合成</li></ul><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p><strong>为什么要拒绝</strong>？比如，房产应该是独一无二的，这种情况下应该拒绝对象拷贝动作</p><p>一般情况下，不声明相应函数即可拒绝。但是编译器会为类合成一些函数，因此需要显式拒绝</p><p>还是以拒绝对象拷贝为例子，拒绝方法包括：</p><ol><li><p>将copy构造函数或copy assignment操作符声明为private，并且不定义</p><p>（这被用于C++ iostream程序库中）</p><ul><li>这种情况下member函数和friend函数还是可以调用，如果member函数或friend函数中执行了复制，会引发<strong>链接错误</strong>。可以使用一个基类，在基类中将copy构造函数或copy assignment操作符声明为private，并且继承这个基类。这样可以将<strong>链接错误</strong>移至<strong>编译期</strong>，因为尝试拷贝时，编译器会试着生成一个copy构造函数和一个copy assignment操作符，这些函数的“编译器合成版”会尝试调用其基类的对应兄弟，而那些调用会被编译器拒绝，因为private</li></ul></li><li><p><strong>使用delete</strong>（这个在书中没有提到）</p></li></ol><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><ul><li><strong>为基类声明virtual析构函数</strong>：当派生类对象经由一个基类指针被删除，而该基类带有一个non-virtual析构函数，结果未定义——实际执行时通常发生的是对象的derived成分没有销毁，即“局部销毁”，造成资源泄露（因为存在这个问题，所以不要继承一个不被用作基类的类）</li><li><strong>class不用作基类时，不要将析构函数声明为virtual</strong>：virtual会引入虚函数指针，这会增加空间开销，使得类无法被C函数使用，从而不再具有移植性</li></ul><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><strong>C++并不禁止析构函数吐出异常，但是并不鼓励这样做</strong></p><h3 id="1）原因"><a href="#1）原因" class="headerlink" title="1）原因"></a>1）原因</h3><p>如果析构函数吐出异常，程序可能过早结束（比如某个函数调用发生异常，在回溯寻找catch过程中，每离开一个函数，这个函数内的局部对象会被析构，如果此时析构函数又抛出异常，前一个异常还没得到处理又来一个，因此一般会引起程序过早结束）。异常从析构函数中传播出去，可能会导致不明确的行为</p><p><a href="https://www.zhihu.com/question/28592504">知乎相关描述</a></p><h3 id="2）如何解决"><a href="#2）如何解决" class="headerlink" title="2）如何解决"></a>2）如何解决</h3><ol><li><strong>在析构函数中catch异常</strong>，然后调用<strong>abort终止</strong>程序。通过abort抢先置“不明确行为”于死地</li><li><strong>在析构函数中catch异常</strong>，然后记录该失败，即<strong>吞掉异常</strong>（通常是个坏主意，因为这样压制了“某些动作失败”的重要信息。但是也比负担“草率结束程序”或”不明确行为带来的风险“好）</li><li>重新设计接口，让客户能够在析构前主动调用可能引起异常的函数，然后析构函数中使用一个bool变量，根据用户是否主动调用来决定析构函数中是否应该调用可能引起异常的函数，<strong>让客户拥有主动权</strong>（如果客户没有主动调用，那么当发生异常时也不应该抱怨，因为已经给出了客户自己处理异常的机会）</li></ol><h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h2><p>如果希望在继承体系中根据类型在构建对象时表现出不同行为，可以会想到在基类的构造函数中调用一个虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                           <span class="hljs-comment">//所有交易的基类</span><br><span class="hljs-keyword">public</span>:                                           <br>    <span class="hljs-built_in">Transaction</span>()&#123;           <br>        ...                           <br>        <span class="hljs-built_in">logTransaction</span>();                         <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//做出一份因类型不同而不同的日志记录</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;        <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br></code></pre></td></tr></table></figure><p>但是最终调用的virtual函数都是基类的版本。同时，因为是纯虚函数，除非定义该函数，否则将报链接错误</p><p><strong>在子类构造期间，virtual函数绝不会下降到派生类阶层。取而代之的是，对象的作为就像隶属基类类型一样。即派生类对象的基类构造期间，对象的类型是基类而不是派生类；除此之外，若使用运行期类型信息</strong>（如dynamic_cast和typeid），也会把对象视为基类类型（这样对待是合理的：因为子类部分尚未初始化，如果调用的是子类的虚函数，通常会访问子类部分的数据，会引发安全问题）</p><p><strong>同样的道理也适用于析构函数。一旦派生类析构函数开始执行，对象内的派生类成员变量便呈现未定义值，所以C++视它们仿佛不再存在。进入基类析构函数后对象就成为一个基类对象</strong></p><p>如果希望实现最初的功能，即根据类型产生不同日志记录，那么可以在派生类的成员初始化列表中，向基类传递一些类型相关的信息，基类构造函数根据这些信息生成不同的日志记录，此时日志记录的生成函数不再是virtual函数</p><h2 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator&#x3D;返回一个reference to *this"></a>条款10：令operator&#x3D;返回一个reference to *this</h2><p>这是为了实现“连锁赋值”。这个协议除了适用于operator&#x3D;，还适用于+&#x3D;、-&#x3D;、*&#x3D;</p><blockquote><p>这只是个协议，并无强制性，如果不遵循，代码一样可通过编译</p></blockquote><h2 id="条款11：在operater-中处理“自我赋值”"><a href="#条款11：在operater-中处理“自我赋值”" class="headerlink" title="条款11：在operater&#x3D;中处理“自我赋值”"></a>条款11：在operater&#x3D;中处理“自我赋值”</h2><p>考虑如下Widget类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Bitmap *pb;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面的operator&#x3D;实现是一份不安全的实现，在自赋值时会出现问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; <br>Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要处理自赋值，可以有以下几种方式：</p><ol><li><p>在开头添加“证同测试”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样做虽然能处理自赋值，但不是异常安全的，如果new时发生异常，对象的pb将指向一块被删除的内存</p></li><li><p>通过确保异常安全来获得自赋值的回报</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    Bitmap *pOrig = pb;               <span class="hljs-comment">// remember original pb</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// make pb point to a copy of *pb</span><br>    <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// delete the original pb</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，如果new失败，pb会保持原状。同时也能处理自赋值。如果担心效率可以在开头加上“证同测试”。但是if判断也会引入开销，因此需要权衡自赋值发生的频率</p></li><li><p>使用copy and swap技术</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参数为pass by reference</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget &amp;rhs)&#123;<br>    Widget <span class="hljs-built_in">temp</span>(rhs);<br>    <span class="hljs-built_in">swap</span>(temp);               <span class="hljs-comment">// swap *this&#x27;s data with</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;             <span class="hljs-comment">// the copy&#x27;s</span><br>&#125;<br><span class="hljs-comment">//参数为pass by value</span><br><span class="hljs-comment">//这种方式的缺点是代码不够清晰，但是将“copying动作“从函数本体内移至”函数参数构造阶段”</span><br><span class="hljs-comment">//却可令编译器有时生成更高效的代码</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget rhs)&#123;<br>    <span class="hljs-built_in">swap</span>(rhs);                <span class="hljs-comment">// swap *this&#x27;s data with</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;             <span class="hljs-comment">// the copy&#x27;s</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><p>如果声明自己的copying函数，意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的，会以一种奇怪的方式回敬：如果你自己写出的copying函数代码不完全，它也不会告诉你</p><ul><li>copy构造函数<ul><li><strong>非继承中</strong>：当为类添加一个新成员时，copy构造函数也需要为新成员添加拷贝代码。否则会调用新成员的默认构造函数初始化新成员</li><li><strong>继承中</strong>：在派生类的copy构造函数中，不要忘记调用基类的copy构造函数拷贝基类部分。否则会调用基类的默认构造函数初始化基类部分</li></ul></li><li>copy赋值运算符<ul><li><strong>非继承中</strong>：当为类添加一个新成员时，copy赋值运算符中也需要为新成员添加赋值代码，否则新成员会保持不变</li><li><strong>继承中</strong>：在派生类的copy赋值运算符中，不要忘记调用基类的copy赋值运算符，否则基类部分会保持不变</li></ul></li></ul><h1 id="三-资源管理"><a href="#三-资源管理" class="headerlink" title="三.资源管理"></a>三.资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><p>当申请一块动态内存时，可能会发生泄漏：</p><ul><li><strong>忘记delete</strong></li><li><strong>有delete，但是delete之前跳出控制流</strong>：在代码的维护过程中，动态分配内存和delete之间可能会加入return之类的控制流变更语句，或者是可能引发异常的代码，这样可能会使程序执行不到delete从而造成资源泄露</li></ul><p><strong>总结起来就是，手工delete一个是需要时刻记住delete，增加编码负担，另一个是即使明确delete，在delete之前控制流可能发生改变从而还是会造成资源泄露</strong></p><p>因此，<strong>一个好的办法是使用对象管理资源，包括下列两个关键想法</strong>：</p><ul><li><strong>获得资源后立刻放进管理对象</strong>：”以对象管理资源“的观念常被称为”资源取得时机便是初始化时机“(<strong>RAII</strong>)</li><li><strong>管理对象运用析构函数确保资源被释放</strong></li></ul><p>一个对象管理资源的例子是auto_ptr:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pIntv</span><span class="hljs-params">(createInvestment())</span></span>;    <br>    ...     <br>&#125;           <span class="hljs-comment">//经由auto_ptr的析构函数自动删除pInv</span><br></code></pre></td></tr></table></figure><p>对于<strong>对象管理资源，需要注意对象的复制行为</strong>：例如，复制逻辑可能是多个对象管理相同的资源，那么析构时就会重复delete。因此，如果是这种复制逻辑，那么应该引入引用计数，析构时根据引用计数决定是否delete。否则，一个资源就应该只由一个对象来管理，那么复制时就原来对象管理的资源就应该修改成null，而复制所得的新对象将取得资源的唯一拥有权（如auto_ptr）</p><blockquote><p>C++没有特别针对”动态分配数组“而设计的类似auto_ptr或tr1::shared_ptr那样的东西，甚至TR1中也没有。那是因为vector和string几乎总是可以取代动态分配而得的数组。因此当需要动态分配数组时，提倡使用vector（<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/C++Primer.md#23-unique_ptr">可以使用unique_ptr管理动态数组</a>）</p></blockquote><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p>并非所有资源都是动态内存，除此之外还有锁等资源，也应该通过”对象管理资源“来确保获取资源后能够正确的释放，<strong>根据资源的类型，和不同的需求，可能需要定义不同的copy行为</strong>：</p><ol><li><strong>禁止复制</strong>：比方说锁资源，管理锁资源的对象复制通常并不合理。因此应该禁止这类对象的复制，可以通过继承一个copying操作被声明为private的基类来禁止复制，这点在条款06中有提到</li><li><strong>对底层资源使用”引用计数法“</strong>：如果希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制RAII对象时，应该将资源的”被引用数“递增。tr1::shared_ptr便是如此（当资源引用计数减为0时，如果不希望删除资源，比方说锁资源，可以使用shared_ptr的“删除器”）</li><li><strong>复制底部资源</strong>：这种情况下，希望在复制RAII对象时，同时复制其关联的底层资源。展现出一种“深拷贝”的行为</li><li><strong>转移底部资源的拥有</strong>：如果希望任一时刻一个资源只由一个RAII对象管理，那么在复制RAII对象时，应该实现拥有权的“转移”，原RAII对象拥有的资源设为null（如auto_ptr）</li></ol><h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><p><strong>API往往要求访问原始资源（即被RAII对象管理的资源，而不是直接访问RAII对象），所以每一个RAII类应该提供一个“取得其所管理的资源”的办法</strong></p><p>取得RAII对象所管理资源的办法可以通过显式转换或隐式转换：</p><ul><li><strong>显式转换(比较安全，但不易用)</strong>：如shared_ptr的get()方法</li><li><strong>隐式转换(比较易用，但不安全)</strong>：如shared_ptr的operator*和operator-&gt;</li></ul><p>如果通过实现隐式转换（比如，实现operator()）来提供对元素资源的访问，可能不安全：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">//以下，Font是一个RAII对象，FontHandle是一个原始资源</span><br><br><span class="hljs-symbol">Font</span> <span class="hljs-built_in">f1</span>(getFont())<span class="hljs-comment">;  </span><br><span class="hljs-symbol">...</span><br><span class="hljs-symbol">FontHandle</span> <span class="hljs-built_in">f2</span> = <span class="hljs-built_in">f1</span><span class="hljs-comment">; //原意是想使用Font，复制一个RAII对象</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，如果实现了隐式转换，底层资源会被复制，如果f1销毁，f2会成为“虚吊的”（dangle）</p><p>是否该提供一个显式转换函数将RAII转换为其底层资源，或是应该提供隐式转换，答案主要取决于RAII被设计执行的特定工作，以及它被使用的情况</p><h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h2><p>当使用new和delete时，发生2件事</p><ul><li>new<ul><li>内存被分配出来（通过名为operator new的函数）</li><li>针对此内存会有一个（或更多）构造函数被调用</li></ul></li><li>delete<ul><li>针对此内存会有一个（或更多）析构函数被调用</li><li>内存被释放（通过名为operator delete的函数）</li></ul></li></ul><p>单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数，布局可能像下面这个样子：</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-3-1.png"><img src="/../images/cppeffective-3-1.png" alt="img"></a></p><p><strong>当使用delete时，唯一能够让delete知道内存中是否存在一个“数组大小记录”的办法是，由你来告诉它。即加上[]，delete便认为指针指向一个数组，否则它便认为指针指向单一对象</strong></p><p>因此，应该像这样使用new和delete</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string* stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string* stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;<br><span class="hljs-keyword">delete</span> [] stringPtr2;<br></code></pre></td></tr></table></figure><ul><li>如果对stringPtr1使用“delete []”形式，结果未定义，但不太可能让人愉快。假设内存布局上，delete会读取若干内存并将它解释为“数组大小”，然后开始多次调用析构函数，浑然不知它所处理的那块内存不但不是个数组，也或许并未持有它正忙着销毁的那种类型的对象</li><li>如果没有对stringPtr2使用“delete []”形式，结果亦未定义，但可以猜想可能导致太少的析构函数被调用。犹有进者，这对内置类型如int者亦未定义，即使这类类型并没有析构函数</li></ul><p>因此，<strong>如果调用new时使用了[]，必须在对应调用delete时也使用[]；如果调用new时没使用[]，那么也不该在对应调用delete时使用[]</strong></p><p>这点在typedef中尤其需要注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> std::string AddressLines[<span class="hljs-number">4</span>];        <span class="hljs-comment">//每个人的地址有4行，每行是一个string</span><br><br>std::string *pa1 = <span class="hljs-keyword">new</span> AddressLines;        <span class="hljs-comment">//就像new string[4]一样</span><br><br><span class="hljs-keyword">delete</span> pa1;             <span class="hljs-comment">//错误！行为未定义</span><br><span class="hljs-keyword">delete</span> [] pa1;          <span class="hljs-comment">//很好</span><br></code></pre></td></tr></table></figure><p>为避免这类错误，最好尽量不要对数组形式做typedef动作</p><h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><p>考虑如下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">func1</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类),<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure><p>在调用func1之前，编译器必须创建代码，做以下3件事</p><ul><li>执行func2</li><li>执行”new 原始资源类”创建一个原始资源</li><li>调用tr1::shared_ptr构造函数</li></ul><p>但是执行顺序弹性很大。如果执行顺序如下；</p><ol><li>执行”new 原始资源类”创建一个原始资源</li><li>执行func2</li><li>调用tr1::shared_ptr构造函数</li></ol><p>现在，如果2发生异常，那么因为1创建的资源未被置入tr1::shared_ptr内，因此会发生内存泄露。也就是说，在“资源被创建”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰。因此，应该使用独立语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类) p;<br><br><span class="hljs-built_in">func1</span>(p,<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure><h1 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四.设计与声明"></a>四.设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><ol><li><p>通过引入新类型来防止误用</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span></span>&#123;<br>public:<br>    Date(<span class="hljs-keyword">int</span> month,<span class="hljs-keyword">int</span> day,<span class="hljs-keyword">int</span> year);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上面日期类的构造函数中，年月日都是int，那么很容易传入顺序错误的参数。因此，可以因为3个表示年月日的新类：Year、Month、Day。从而防止这种问题。更进一步，为了使得传入的数据有效，比如月份，可以设计生成12个月份对象的static成员函数，并将构造函数声明为explicit强制要求通过调用static成员函数得到月份对象。使用enums没有那么安全，enums可被拿来当作一个ints使用</p></li><li><p><strong>除非有好的理由，否则应该尽量让你的type的行为与内置类型一致</strong>：如<code>if(a * b = c)</code>对内置类型来说不合法，那么你的type在实现operator*时就应该返回一个const对象</p></li><li><p><strong>提供一致的接口</strong>：如C++ STL容器都提供size()返回容器大小，但是Java和.Net对于不同容器大小接口可能不同，这会增加使用负担</p></li><li><p><strong>返回“资源管理对象”而不是原始资源</strong>：如用shared_ptr管理资源时，客户可能会忘记使用智能指针，从而开启了忘记释放和重复释放的大门。通过修改接口的返回类型为智能指针，从而确保元素资源处于“资源管理对象”的掌控之中</p></li></ol><h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><p>在设计class时，下列问题将导致class你的设计规范：</p><ul><li>新type的对象应该如何被创建和销毁？</li><li>对象的初始化和对象的赋值该有什么样的差别？</li><li>新type的对象如果被passed by value，意味着什么？</li><li>什么是新type的“合法值”？</li><li>你的新type需要配合某个继承体系吗？</li><li>你的新type需要什么样的转换？</li><li>什么样的操作符和函数对此新type而言是合理的？</li><li>什么样的标准函数应该驳回？</li><li>谁该取用新type的成员？</li><li>什么是新type的“未声明接口”？</li><li>你的新type有多么一般化？</li><li>你真的需要一个新type吗？</li></ul><h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><p>pass-by-reference-to-const有下列好处：</p><ul><li><strong>更高的效率</strong>：如果一个类处于继承体系的底部，并且包含大量成员，pass-by-value会导致大量的构造函数被调用，在函数调用完成后，又有大量的析构函数被调用</li><li><strong>防止继承中的对象切割</strong>：如果是pass-by-value，并且传入一个子类对象时，传入的子类对象会被切割，只保有基类对象的部分，从而无法表现多态</li></ul><p>references往往以指针实现出来，因此pass by reference通常意味真正传递的是指针。因此，对于<strong>内置类型</strong>，pass by value往往比pass by reference的效率更高。pass by value同样适用于<strong>STL的迭代器</strong>和<strong>函数对象</strong></p><p>并不是所有小型对象都是pass-by-value的合格候选者：</p><ul><li>对象小并不意味着copy构造函数不昂贵。许多对象——包括大多数STL容器——内含的东西比一个指针多一些，但是复制这种对象却需承担“复制那些指针所指的每一样东西”。那将非常昂贵</li><li>即使copy构造函数不昂贵，还是可能有效率上的争议。某些编译器对待“内置类型”和“用户自定义类型”的态度截然不同，纵使两者拥有相同的底层表述，“用户自定义类型”也不会被编译器放入缓存器，因此pass by reference更适合</li></ul><blockquote><p>可以合理假设“pass-by-value并不昂贵”的唯一对象就是内置类型和STL的迭代器和函数对象。其它任何时候，宁以pass-by-reference-to-const替换pass-by-value</p></blockquote><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p>必须返回对象的最常见例子是运算符函数：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs);<br></code></pre></td></tr></table></figure><p>在必须返回对象时，不要企图返回reference，可以通过反面来说，也就是如果返回reference会是什么情况？</p><ul><li><p>使用stack构造一个局部对象，返回局部对象的reference</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span>&amp; operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs)<br>&#123;<br>    <span class="hljs-built_in">Rational</span> result(lhs.n * rhs.n,lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意！使用reference的本意是避免构造新对象，但是一个新的对象result还是经由构造函数构造。更严重的是，这个局部对象在函数调用完成后就被销毁了，reference将指向一个被销毁的对象</p></li><li><p>使用heap构造一个局部对象，返回这个对象的reference</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span>&amp; operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs)<br>&#123;<br>    <span class="hljs-built_in">Rational</span> *result = new <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> *result;<br>&#125;<br><span class="hljs-built_in">Rational</span> w,x,y,z;<br>w = x * y *z;<br></code></pre></td></tr></table></figure><p>这样虽然reference不再引用一个被销毁的对象，但是因为了动态内存分配的开销，而且谁该为delete负责也成为问题。同时，在上面的连乘例子中，会多次动态分配内存，但是只返回最后一次的指针，因此会造成资源泄露</p></li><li><p>构造一个static局部对象，每次计算结果保存在这个对象中，返回其reference</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-type">Rational</span>&amp; operator*(<span class="hljs-keyword">const</span> <span class="hljs-type">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-type">Rational</span> &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Rational</span> <span class="hljs-built_in">result</span><br>    <span class="hljs-built_in">result</span> = ...;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br><span class="hljs-type">Rational</span> w,x,y,z;<br><span class="hljs-keyword">if</span>((w * x) == (y * z))<span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>首先，显而易见的问题是这个函数在多线程情况下是不安全的，多个线程会修改相同的static对象；除此之外，在上面的if判断中，不管传入的w,x,y,z是什么，由于operator*传回的reference都指向同一个static对象，因此上面的判断永远都会为true</p></li></ul><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><h3 id="1）为什么不能是public"><a href="#1）为什么不能是public" class="headerlink" title="1）为什么不能是public"></a>1）为什么不能是public</h3><p>3个原因：</p><ol><li><p><strong>语法一致性</strong>：如果成员变量和成员函数一样，都是public，那么调用时会困惑于该不该使用括号。如果想获取大小时使用size，但是这到底是一个成员变量还是一个成员函数？</p></li><li><p>更精准的控制</p><p>：通过将成员变量声明为private，通过成员函数提供访问，可以实现更精准的访问控制</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessLevels</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getReadOnly</span>() <span class="hljs-keyword">const</span></span>   &#123;<span class="hljs-keyword">return</span> readOnly;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setReadWrite</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span>    &#123;readWrite = <span class="hljs-keyword">value</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getReadWrite</span>() <span class="hljs-keyword">const</span></span>    &#123;<span class="hljs-keyword">return</span> readWrite;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setWriteOnly</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span>    &#123;writeOnly = <span class="hljs-keyword">value</span>;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">int</span> noAccess;   <span class="hljs-comment">//对此int无访问动作</span><br>    <span class="hljs-built_in">int</span> readOnly;   <span class="hljs-comment">//对此int做只读访问</span><br>    <span class="hljs-built_in">int</span> readWrite;  <span class="hljs-comment">//对此int做读写访问</span><br>    <span class="hljs-built_in">int</span> writeOnly;  <span class="hljs-comment">//对此int做只写访问</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>封装(主要)</strong>：private将成员变量封装，如果通过public暴露，在需要改成员变量的大量实现代码中，会直接使用当这个成员变量被修改或删除时，所有直接访问该成员变量的代码将会变得不可用</p></li></ol><h3 id="2）那么protected行不行"><a href="#2）那么protected行不行" class="headerlink" title="2）那么protected行不行"></a>2）那么protected行不行</h3><p>protected成员变量和public成员变量的论点十分相同。“语法一致性”和“细微划分的访问控制”等理由也适用于protected数据。同时，protected也并不具备良好的封装性</p><p>假设有一个public成员变量，而我们最终取消了它。所以使用它的客户代码都会被破坏。因此，public成员变量完全没有封装性。假设有一个protected变量，而我们最终取消了它，所有使用它的派生类都会被破坏。因此，protected成员变量也缺乏封装性</p><p>因此，从封装的角度看，只有private能提供封装性</p><h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p>假设有个浏览器类，包含一些功能用来清除下载元素高速缓冲区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearCache</span>()</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearCookies</span>()</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearHistory</span>()</span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>此时，如果想整个执行所有这些动作，那么有两种选择，一种实现成member函数，一种实现成non-member函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">class WebBrowser&#123;<br>public:<br>  //实现成成员函数，能访问private成员<br>  void <span class="hljs-built_in">clearEverything</span>()&#123;<br>    <span class="hljs-built_in">clearCache</span>();<br>    <span class="hljs-built_in">clearCookies</span>();<br>    <span class="hljs-built_in">clearHistory</span>();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//或者实现成非成员函数，不能访问private成员</span><br>void <span class="hljs-built_in">clearEverything</span>(WebBrowser&amp; wb)&#123;<br>  wb<span class="hljs-selector-class">.clearCache</span>();<br>  wb<span class="hljs-selector-class">.clearCookies</span>();<br>  wb<span class="hljs-selector-class">.clearHistory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>问题是应该如何选择？这个问题主要在于<strong>封装性</strong></p><p>如果某些东西被封装，它就不再可见。越多东西被封装，越少人可以看到它。越少人看到它，就有越大的弹性去变化它，因为我们的改变仅仅直接影响看到改变的那些人事物</p><p>因此，对于对象内的代码。越少代码可以看到数据（也就是访问它），越多的数据可被封装，我们也就越能自由地改变对象数据。作为一种粗糙的测量，越多函数可访问它，数据的封装性就越低</p><p>条款22所说，成员变量应该是private。能够访问private成员变量的函数只有class的member函数加上friend函数而已。<strong>如果要在一个member函数和一个non-member，non-friend函数之间做选择，而且两者提供相同机能，那么，导致较大封装性的是non-member，non-friend函数</strong>，也就是本条款这样选择的原因</p><p>一个扩展性的问题是——这些non-member，non-friend函数应该实现于何处?</p><p>一个像WebBrowser这样的class可能拥有大量便利函数，某些与书签有关，某些与打印有关，还有一些与cookie的管理有关…通常客户只对其中某些感兴趣。没道理一个只对书签相关便利函数感兴趣的客户却与一个cookie相关便利函数发生编译相依关系。分离它们的最直接做法就是将书签相关便利函数声明于一个头文件，将cookie相关便利函数声明于另一个头文件，再将打印相关…以此类推：</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-1.png"><img src="/../images/cppeffective-4-1.png" alt="img"></a></p><p>这正是C++标准库的组织方式。标准库并不是拥有单一、整体、庞大的&lt;C++StandardLibrary&gt;头文件并在其中内含std命名空间内的每一样东西，而是有数十个头文件（<vector>,<algorithm>,…），每个头文件声明std的某些机能。客户可以根据需要使用的机能选择性的包含头文件</p><h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>为class支持隐式类型转换不是个好主意，但是在数值类型之间颇为合理。考虑有理数和内置整形之间的相乘运算。具有如下有理数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>); <span class="hljs-comment">//构造函数刻意不为explicit，提供了Int-to-Rational的隐式转换</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">//分子的访问函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//分母的访问函数</span><br><span class="hljs-keyword">private</span>:<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，有理数提供了Int-to-Rational的隐式转换方式，那么operator*应该实现成member，还是non-member？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-comment">//实现为member</span><br>    <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span>;<br>&#125;<br><br><span class="hljs-comment">//实现为non-member</span><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure><p>问题发生在混合运算上。如果实现成member，那么下面的混合运算只有一半行得通：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">result = oneHalf * <span class="hljs-number">2</span>;                  <span class="hljs-comment">// OK</span><br>result = <span class="hljs-number">2</span> * oneHalf;                  <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>因为内置类型int并没有相应的class，也就没有operator*成员函数。所以后者会出错。但是当实现为non-member时，具有2个参数，都能通过int转换为Rational，所以上面2行代码都能运行。因此，若所有参数皆需类型转换，请为此采用non-member函数</p><h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p>”以指针指向一个对象，内含真正数据“。这种设计的常见表现形式是所谓的”pimpl手法“。如下，WidgetImpl包含了Widget的真正数据，而Widget只包含一个WidgetImpl类型的指针，指向一个WidgetImpl对象。这种设计特点，决定了Widget的copying行为应该表现出一种”深拷贝“的行为：</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-2.png"><img src="/../images/cppeffective-4-2.png" alt="img"></a></p><p>因此，如果使用标准库的swap交换2个Widget对象，会引起WidgetImpl对象的拷贝，由于其内含有Widget的大量数据，因此效率可能十分低。实际上这种情况下，交换2个指针就可以了。为此，我们可能实现出下图右边中间的swap特化版来提升效率，但是由于其内直接访问Widget的private成员，因此无法通过编译。所以我们采用下图右下角的方案，在Widget类内实现一个public的swap函数，然后特化版的swap调用这个public的swap函数：</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-3.png"><img src="/../images/cppeffective-4-3.png" alt="img"></a></p><p>当问题更进一步发展时，即Widget和WidgetImpl为class template时，可能会将相同的思想迁移过来，实现出下图右边左上角的偏特化版本。但是问题是：<strong>C++只允许偏特化class template，而不允许偏特化function template</strong>。所以行不通，因此可以使用下图右下角的重载方式，但是<strong>客户可以全特化std内的模板，但是不能添加新的模板到std内</strong>，因此正确的做法是下图左下角</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-4.png"><img src="/../images/cppeffective-4-4.png" alt="img"></a></p><p>总结起来就是：</p><ul><li>首先，如果swap的缺省实现对你的class或class template提供可接受的效率，那不需要做额外的事</li><li>否则，如果swap的缺省实现效率不足（那几乎总是意味着你的class或template使用了某种pimpl手法），试着做以下事情：<ul><li>提供一个public swap成员函数，让它高效地置换你的类型的两个对象的值（<strong>这个public swap成员函数绝不应该抛出异常。这个约束不可施行于非成员版，因为swap缺省版是以copy构造函数和copy assignment操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定义版本的swap，往往提供的不只是高效置换对象值的方法，而且不抛出异常。一般而言这两个swap特性是连在一起的，因为高效的swap几乎总是基于对内置类型的操作，而内置类型上的操作绝对不会抛出异常</strong>）</li><li>在你的class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数</li><li>如果你正编写一个class（而非class template），为你的class特化std::swap。并令它先调用你的swap成员函数</li></ul></li><li>最后，如果你调用swap，请确定包含一个using声明，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符地调用swap</li></ul><h1 id="五-实现"><a href="#五-实现" class="headerlink" title="五.实现"></a>五.实现</h1><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>只要定义了一个变量而其类型带有一个构造函数或析构函数，那么</p><ul><li>当程序的控制流到达这个变量定义式时，你便得承受构造成本</li><li>当这个变量离开作用域时，你便得承受析构成本</li></ul><p>即使这个变量最终并未被使用，仍需耗费这些成本，所以你应尽可能避免这种情形，即延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止</p><p>当考虑循环时，有下列2种情况：</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-5-1.png"><img src="/../images/cppeffective-5-1.png" alt="img"></a></p><p>2种写法的成本如下；</p><ul><li>做法A：1个构造函数 + 1个析构函数 + n个赋值操作</li><li>做法B：n个构造函数 + n个析构函数</li></ul><p><strong>从效率上看</strong>：如果class的一个赋值成本低于一组构成+析构成本，做法A大体而言比较高效，尤其当n比较大时。否则做法B或许更好</p><p><strong>从可理解性和维护性上看</strong>：A造成名称w的作用域比做法B更大，可理解性和维护性相对较差</p><p>因此，除非</p><ol><li>你知道赋值成本比”构造 + 析构“成本低</li><li>你正在处理代码中效率高度敏感的部分</li></ol><p>否则，应该使用做法B</p><h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>转型分类：</p><ul><li><p>C风格的转型</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-punctuation">(</span><span class="hljs-built_in">T</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">expression</span>   <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将<span class="hljs-built_in">expression</span>转型为<span class="hljs-built_in">T</span><br><span class="hljs-built_in">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span>   <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将<span class="hljs-built_in">expression</span>转型为<span class="hljs-built_in">T</span><br></code></pre></td></tr></table></figure></li><li><p>C++提供的新式转型</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs r">const_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br>dynamic_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br>reinterpret_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br>static_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><ul><li><strong>static_cast</strong>：只要不包含底层const，都可以使用。适合将较大算术类型转换成较小算术类型</li><li><strong>const_cast</strong>：只能改变底层const，例如指向const的指针(指向的对象不一定是常量，但是无法通过指针修改)，如果指向的对象是常量，则这种转换在修改对象时，结果未定义</li><li><strong>reinterpret_cast</strong>：通常为算术对象的位模式提供较低层次上的重新解释。如将int<em>转换成char</em>。很危险！</li><li><strong>dynamic_cast</strong>：一种动态类型识别。转换的目标类型，即type，是指针或者左右值引用，主要用于基类指针转换成派生类类型的指针(或引用)，通常需要知道转换源和转换目标的类型。如果转换失败，返回0（转换目标类型为指针类型时）或抛出bad_cast异常（转换目标类型为引用类型时）</li></ul></li></ul><p>应该尽可能使用新式转型：</p><ol><li>它们很容易在代码中被辨别出来（无论是人工还是使用工具如grep），因而得以简化”找出类型系统在哪个地点被破坏“的过程</li><li>各转型动作的目标越窄化，编译器越可能诊断出错误的运用</li></ol><p><strong>尽量少做转型</strong>：</p><ol><li><p>转型不只是告诉编译器把某种类型视为另一种类型这么简单。任何一个转型动作往往令编译器编译出运行期间执行的代码</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim">//示例一<br><span class="hljs-type">int</span> x,y;<br>...<br>double d = static_cast&lt;double&gt;(x)/y;<br>//示例二<br>class <span class="hljs-type">Base</span> <span class="hljs-meta">&#123;...&#125;</span>;<br>class <span class="hljs-type">Derived</span> : public <span class="hljs-type">Base</span> <span class="hljs-meta">&#123;...&#125;</span>;<br><span class="hljs-type">Derived</span> d;<br><span class="hljs-type">Base</span> *pd = &amp;d;  //隐式地将<span class="hljs-type">Derived</span>*转换为<span class="hljs-type">Base</span>*<br></code></pre></td></tr></table></figure><ul><li>在示例一中：int转型为double几乎肯定会产生一些代码，因为在大部分体系结构中，int的底层表述不同于double的底层表述</li><li>在示例二中：会有个偏移量在运行期被实施于Derived<em>指针身上，用以取得正确的Base</em>地址</li></ul></li><li><p>很容易写出似是而非的代码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    virtual <span class="hljs-built_in">void</span> onResize() &#123;...&#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//错误的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">SpecialWindow: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    virtual <span class="hljs-built_in">void</span> onResize()&#123;<br>        static_cast&lt;Window&gt;(*<span class="hljs-keyword">this</span>).onResize();  <br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//正确的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">SpecialWindow: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    virtual <span class="hljs-built_in">void</span> onResize()&#123;<br>        Window::onResize();  <span class="hljs-comment">//调用Window::onResize作用于*this身上</span><br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中，派生类的虚函数可能希望调用基类虚函数的版本执行一些固定操作，然后再执行一些专属行为。在前面的做法中，转型并非在当前对象身上调用Window::onResize之后又在该对象身上执行SpecialWindow专属动作。而是在”当前对象的base class成分“的副本上调用Window::onResize，然后在当前对象身上执行SpecialWindow专属动作。如果Window::onResize修改了对象内容，当前对象其实没被改的，改的是副本。如果专属动作也修改对象，那么当前对象会进入一种”伤残“状态：其base class成分的更改没有落实，derived class成分的更改倒是落实了</p></li><li><p>继承中的类型转换效率低</p><ul><li>C++通过dynamic_cast实现继承中的类型转换，dynamic_cast的大多数实现效率都是相当慢的。因此，应该避免继承中的类型转换。一般需要dynamic_cast，通常是因为想在一个认定为derived class对象身上执行derived class操作，但是拥有的是一个”指向base“的指针或引用。这种情况下有2种办法可以避免转型：<ul><li><strong>使用容器并在其中存储直接指向derived class对象的指针</strong>：这种做法无法在同一个容器内存储指针”指向所有可能的各种派生类“。如果真要处理多种类型，可能需要多个容器，它们都必须具备类型安全性</li><li><strong>将derived class中的操作上升到base class内，成为virtual函数，base class提供一份缺省实现</strong>：缺省实现代码可能是个馊主意，条款34中有分析，但是也比使用dynamic_cast来转型要好</li></ul></li></ul></li></ol><h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h2><blockquote><p>References、指针和迭代器统统都是所谓的handles</p></blockquote><h3 id="1）增加封装性"><a href="#1）增加封装性" class="headerlink" title="1）增加封装性"></a>1）增加封装性</h3><p>如果成员函数返回handles，那么相当于成员变量的封装性从private上升到public。这与<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE22%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate">条款22</a>相悖</p><h3 id="2）使得“通过const修改对象的数据”成为可能"><a href="#2）使得“通过const修改对象的数据”成为可能" class="headerlink" title="2）使得“通过const修改对象的数据”成为可能"></a>2）使得“通过const修改对象的数据”成为可能</h3><p>在<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>提到过”pimpl手法“，即：“以指针指向一个对象，内含真正数据”，也就是对象只包含指针成员，实际数据通过这个指针指向。而在<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE03%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const">条款3</a>中也提到，C++对const成员函数的要求是，符合bitwise constness。因此，const成员函数返回一个这个指针所指对象的引用，并不会造成指针被修改，也就符合bitwise constness，但是通过这个引用却可以改变对象实际的数据</p><h3 id="3）防止“虚吊”-dangle-发生"><a href="#3）防止“虚吊”-dangle-发生" class="headerlink" title="3）防止“虚吊”(dangle)发生"></a>3）防止“虚吊”(dangle)发生</h3><p>如果返回的handles指向一个临时对象，那么返回后临时对象销毁，handles会成为“虚吊的”。只要handle被传出去，就会面临“handle比其所指对象更长寿”的风险</p><h2 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h2><p>考虑下面例子，有一个菜单类，changeBg函数可以改变它的背景，切换背景计数，同时提供线程安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    Mutex mutex;            <span class="hljs-comment">//提供多线程互斥访问</span><br>    Image *bg;          <span class="hljs-comment">//背景图片</span><br>    <span class="hljs-type">int</span> changeCount;    <span class="hljs-comment">//切换背景计数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBg</span><span class="hljs-params">(istream&amp; sr)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-built_in">lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">delete</span> bg;<br>    ++changeCount;<br>    bg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src);<br>    <span class="hljs-built_in">unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1）异常安全的2个条件"><a href="#1）异常安全的2个条件" class="headerlink" title="1）异常安全的2个条件"></a>1）异常安全的2个条件</h3><p><strong>异常安全有2个条件</strong>：</p><ol><li><strong>不泄露任何资源</strong>：即发生异常时，异常发生之前获得的资源都应该释放，不会因为异常而泄露。在上面的例子中，如果new Image发生异常，那么unlock就不会调用，因此锁资源会泄露</li><li><strong>不允许数据败坏</strong>：上面的例子也不符合，如果new Image异常，背景图片会被删除，计数也会改变。但是新背景并未设置成功</li></ol><p><strong>对于资源泄露</strong>，<a href="https://github.com/arkingc/note/blob/master/C%2B%2B">条款13</a>讨论过以对象管理资源。锁资源也可以为shared_ptr指定“删除器”，当引用为0时，即异常发生，管理所资源的对象被销毁后，删除器会调用unlock</p><p><strong>对于数据败坏</strong>：见下文</p><h3 id="2）异常安全函数的3个保证"><a href="#2）异常安全函数的3个保证" class="headerlink" title="2）异常安全函数的3个保证"></a>2）异常安全函数的3个保证</h3><ol><li><strong>基本承诺</strong>：抛出异常后，对象仍然处于合法（valid）的状态。但不确定处于哪个状态（对于前面的例子，如果发生异常，PrettyMenu可以继续拥有原背景图像，或是令它拥有某个“缺省”的背景图像，但客户无法确定）</li><li><strong>强烈保证</strong>：如果抛出了异常，状态并不会发生发生任何改变。就像没调用这个函数一样</li><li><strong>不抛掷保证</strong>：这是最强的保证，函数总是能完成它所承诺的事情（作用于内置类型身上的所有操作都提供nothrow保证。这是异常安全代码中一个必不可少的关键基础）</li></ol><p>对于前面的PrettyMenu对象，可以通过使用智能指针，以及重排changeBg的语句顺序来满足“强烈保证”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    shared_ptr&lt;Image&gt; bg;<br>    ...<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;    <span class="hljs-comment">//Lock以对象管理资源</span><br>    bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src));<br>    ++changeCount;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，上述实现只能为PrettyMenu对象提供“强烈保证”，不能提供完美（即全局状态）的“强烈保证”。比如Image构造函数中移动了istream&amp; src的读指针然后再抛出异常，那么系统还是处于一个被改变的状态。 这是一种对整个系统的副作用，类似的副作用还包括数据库操作，因为没有通用的办法可以撤销数据库操作。 不过这一点可以忽略，我们暂且认为它提供了完美的强烈保证</p><p><strong>copy and swap策略</strong></p><p>“copy and swap”设计策略通常能够<strong>为对象</strong>提供异常安全的“强烈保证”。当我们要改变一个对象时，先把它复制一份，然后去修改它的副本，改好了再与原对象交换。关于swap的详细讨论可以参见<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>。这种策略用在前面的例子中会像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Mutex mutex;<br>    std::shared_ptr&lt;MenuImpl&gt; pImpl;<br>&#125;;<br>Menu::<span class="hljs-built_in">changeBg</span>(std::istream&amp; src)&#123;<br>    <span class="hljs-keyword">using</span> std::swap;            <span class="hljs-comment">// 见 Item 25</span><br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;            <span class="hljs-comment">// 获得mutex的副本数据</span><br><br>    <span class="hljs-function">std::shared_ptr&lt;MenuImpl&gt; <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MenuImpl(*pImpl))</span></span>;<br>    copy-&gt;bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src)); <span class="hljs-comment">//修改副本数据</span><br>    ++copy-&gt;changeCount;<br><br>    <span class="hljs-built_in">swap</span>(pImpl, copy);              <span class="hljs-comment">//置换数据，释放mutex</span><br>&#125;<br></code></pre></td></tr></table></figure><p>copy and swap策略能够<strong>为对象</strong>提供异常安全的“强烈保证”。但是一般而言，它并不保证整个函数有“强烈保证”。也就是说，如果某个函数使用copy and swap策略为某个对象提供了异常安全的“强烈保证”。但是这个函数可能调用其它函数，而这些函数可能改变一些全局状态（如数据库状态），那么”整个函数“就不是”强烈保证“</p><blockquote><p>函数提供的”异常安全保证“通常最高只等于其所调用的各个函数的”异常安全保证“中的最弱者</p></blockquote><p>除此之外，copy and swap必须为每一个即将被改动的对象作出一个副本，从而可能造成时间和空间上的问题</p><h3 id="3）最终目标是什么"><a href="#3）最终目标是什么" class="headerlink" title="3）最终目标是什么"></a>3）最终目标是什么</h3><p>当”强烈保证“不切实际时（比如前面提到的全局状态改变难以保证，或者效率问题），就必须提供”基本保证“。现实中你或许会发现，可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。只要你曾经付出适当的心力试图提供强烈保证，万一实际不可行，使你退而求其次地只提供基本保证，任何人都不该因此责难你。对许多函数而言，”异常安全性的基本保证“是一个绝对同情达理的选择</p><p>总的来说就是，应该为自己的函数努力实现尽可能高级别的异常安全，但是由于种种原因并不是说一定需要实现最高级别的异常安全，而是应该以此为目标而努力</p><h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><strong>inline的优劣</strong>：</p><ul><li><p>优</p><p>：</p><ul><li><strong>较少函数调用的开销</strong></li><li><strong>编译器对inline的优化</strong></li></ul></li><li><p>劣</p><p>：</p><ul><li><strong>目标代码的增加，程序体积增大，导致额外的换页行为，降低指令高速缓存装置的命中率</strong></li></ul></li></ul><p>inline提出方式包括2种：1）显式提出；2）隐式提出（类内实现成员函数）</p><p>inline在大多数C++程序中是<strong>编译期行为</strong>。inline只是对编译器的一个申请，不是强制命令。大多数编译器提供了一个诊断级别：如果它们无法将你要求的函数inline化，会给出一个警告</p><p><strong>对virtual函数的调用也都会使inlining落空。因为virtual意味着”等待，直到运行期才确定调用哪个函数“，而inline意味着”执行前，先将调用动作替换为被调用函数的本体</strong>“</p><p>如果程序要取某个inline函数的地址，编译器通常必须为此函数生成一个outlined函数本体。毕竟编译器没有能力提出一个指针指向并不存在的函数</p><p><strong>构造函数和析构函数往往是inlining的糟糕候选人</strong>。C++对于”对象被创建和被销毁时发生什么事“做了各式各样的保证。在对象构造期间如果抛出异常，该对象已经构造好的部分会被自动销毁…，因此，对于下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string bm1,bm2;    <span class="hljs-comment">//base成员1和2</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()  &#123;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string dm1,dm2,dm3; <span class="hljs-comment">//derived成员1-3</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>虽然看上去Derived的构造函数为空，符合一个函数成为inline的的特性。但是为了确保C++对于”对象被创建和被销毁时发生什么事“做出的各式各样的保证，编译器会在其中安插代码，因此实际的Derived构造函数可能是这个样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">Derived::<span class="hljs-built_in">Derived</span>()<br>&#123;<br>    Base::<span class="hljs-built_in">Base</span>();<br>    <span class="hljs-keyword">try</span>&#123;dm<span class="hljs-number">1.</span>std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm<span class="hljs-number">2.</span>std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm<span class="hljs-number">1.</span>std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm<span class="hljs-number">3.</span>std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm<span class="hljs-number">2.</span>std::string::~<span class="hljs-built_in">string</span>();<br>        dm<span class="hljs-number">1.</span>std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大部分的调试器面对inline函数都束手无策。因为无法在一个不存在的函数内设立断点。因此，一个合乎逻辑的策略是，一开始先不要将任何函数声明为inline，或至少将inlining施行范围局限在那些“一定称为inline”或“十分平淡无奇”的函数身上</p><h2 id="条款31：将文件间的编译依存关系将至最低"><a href="#条款31：将文件间的编译依存关系将至最低" class="headerlink" title="条款31：将文件间的编译依存关系将至最低"></a>条款31：将文件间的编译依存关系将至最低</h2><p>C++并没有把“将接口从实现中分离”这件事做得很好。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string theName;    <span class="hljs-comment">//实现细目</span><br>    Date    theBirthDate;   <span class="hljs-comment">//实现细目</span><br>    Address theAddress;     <span class="hljs-comment">//实现细目</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果没有前面3行引入头文件，那么编译无法通过。但是如此却<strong>会在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些文件所依赖的其它头文件有任何改变。那么每个含入Person class的文件就得重新编译，任何使用Person class的文件也必须重新编译</strong>。这样的连串编译依存关系会对许多项目造成难以形容的灾难</p><p>你可能会想着将实现细目分开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>;   <span class="hljs-comment">//前置声明，但不正确</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;         <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;      <span class="hljs-comment">//前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果可以这么做，Person的客户就只需要在Person接口被修改过时才重新编译。但是这种想法存在2个问题：</p><ul><li><p>string并不是个class，它是个typedef，上述前置声明不正确，正确的前置声明比较复杂</p></li><li><p>重点是，</p><p>编译器必须在编译期间知道对象的大小</p><p>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;           <span class="hljs-comment">//定义一个int</span><br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(...)</span></span>;   <span class="hljs-comment">//定义一个Person</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这和Java，Smalltalk中不同，因为它们在定义对象时，编译器只分配足够空间给一个指针使用。也就是说，它们将上述代码视为这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;          <span class="hljs-comment">//定义一个int</span><br>    Person* p;      <span class="hljs-comment">//定义一个指针指向Person对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>1）一个办法是，可以把Person分割为两个类：1）一个只提供接口(Person)；2）一个负责实现接口(PersonImpl)；就是使用<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>中的”pimpl手法“：接口class中只包含一个负责实现接口的class的指针，因此任何改变都只是在负责实现接口的class中进行。那么Person的客户就完全与Date,Address,以及Person的实现细目分离了。那些classes的任何实现修改都不需要Person客户端重新编译。此外，由于客户无法看到Person的实现细目，也就不可能写出什么“取决于那些细目的代码”。这正是接口与实现分类。这种情况下，像Person这样使用pimpl的classes往往被称为handle classes</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string&amp; name);<br>    <span class="hljs-function">string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;;<br>Person::<span class="hljs-built_in">Person</span>(string&amp; name): <span class="hljs-built_in">pImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PersonImpl</span>(name))&#123;&#125;<br><span class="hljs-function">string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）另一种制作Handle class的办法是，令Person成为一种特殊的abstract base class，称为interface class</strong>。其目的是详细描述derived classes的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">birthday</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>客户不能实例化它，只能使用它的引用和指针。然而客户一定需要某种方法来获得一个实例，比如工厂方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> shared_ptr&lt;Person&gt; <span class="hljs-title">create</span><span class="hljs-params">(string&amp; name)</span></span>;<br>&#125;;<br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">Person::create</span><span class="hljs-params">(string&amp; name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;Person&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealPerson</span>(name));<br>&#125;<br>...<br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">p</span><span class="hljs-params">(Person::create(<span class="hljs-string">&quot;alice&quot;</span>))</span></span>;<br></code></pre></td></tr></table></figure><p><strong>应该让头文件自我满足</strong>，万一做不到，则让它与其他头文件内的声明式相依。其他每一件事都源自于这个简单的设计策略：</p><ul><li><p><strong>如果使用object references或object pointers可以完成任务，就不要使用objects</strong></p></li><li><p>如果能够，尽量以class声明式替换class定义式</p><p>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>为声明式和定义式提供不同的头文件</p><p>。为了促使这个准则，需要两个头文件：一个用于声明式，一个用于定义式。因此，上面的例子应该是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;datefwd.h&quot;</span>    <span class="hljs-comment">//包含了class Date的声明</span></span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="六-继承与面向对象设计"><a href="#六-继承与面向对象设计" class="headerlink" title="六.继承与面向对象设计"></a>六.继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h2><p><strong>public隐含的寓意</strong>：每个派生类对象同时也是一个基类对象(反之不成立)，只不过基类比派生类表现出更一般化的概念，派生类比基类表现出更特殊化的概念。</p><p>可以举一个例子验证一下上面的说法。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;...&#125;;<br></code></pre></td></tr></table></figure><p>显然，每个学生都是人，但并非每个人都是学生。对人可以成立的每一件事对学生也都成立（例如每个人都有生日），但对学生都成立的每件事并不一定对每个人也成立(例如注册于某个学校)</p><p>因此，C++中，任何函数如果期望获得一个类型为基类的实参，都也愿意接收一个派生类对象。但是反之不成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student &amp;s)</span></span>;<br>Person p;<br>Student s;<br><span class="hljs-built_in">eat</span>(p);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">eat</span>(s);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(s);   <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(p);   <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p>谨记这种is-a关系以及背后隐藏的规则可以防止因为“经验主义”而使用不合理的继承：</p><ul><li>从“经验主义”上看，企鹅也是鸟，如果为鸟定义了虚拟(virtual)的飞的方法，然后企鹅类以public继承鸟类，那么是不合理的方式。这种情况下，可以设计一个会飞的鸟的类，虚拟(virtual)的飞的方法声明在这个类中，而鸟类里面没有声明飞的方法。或者根本不声明飞的方法</li><li>从“经验主义”上看，正方形也是长方形，如果长方形有成员方法会修改长或宽，那么正方形以public继承长方形就显得不合理</li></ul><p>软件世界不同于现实世界。对于上面的鸟的设计，某些软件系统可能不需要区分会飞的鸟和不会飞的鸟。那么即使鸟类声明了飞的方法，然后企鹅类以public继承，也不会有多大问题。也就是说，不存在一个适用于所有软件的设计。最佳的设计取决于系统希望做什么事。如果程序对飞行一无所知，而且也不打算未来对飞行有所知，那么不去区分会飞的鸟和不会飞的鸟不失为一个完美而有效的设计。实际上可能比对两者做出隔离的设计更受欢迎，因为这样的区隔在你企图塑模的世界中并不存在。因此，<strong>应该根据实际软件需求，合理使用public</strong></p><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><h3 id="1）继承中的作用域嵌套"><a href="#1）继承中的作用域嵌套" class="headerlink" title="1）继承中的作用域嵌套"></a>1）继承中的作用域嵌套</h3><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-1.png"><img src="/../images/cppeffective-6-1.png" alt="img"></a></p><p>名字查找会从内层作用域向外层作用域延伸</p><h3 id="2）名称遮掩会遮掩基类所有重载版本"><a href="#2）名称遮掩会遮掩基类所有重载版本" class="headerlink" title="2）名称遮掩会遮掩基类所有重载版本"></a>2）名称遮掩会遮掩基类所有重载版本</h3><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-2.png"><img src="/../images/cppeffective-6-2.png" alt="img"></a></p><p>派生类中同名的名称会遮掩基类中相同的名称，如果基类包含重载函数，所有重载函数都会被遮掩</p><p>解决办法是使用using引入被遮掩的名字：</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-3.png"><img src="/../images/cppeffective-6-3.png" alt="img"></a></p><p>如果只想引入基类被遮掩函数中某个版本（注意，这种需求一般只在private继承中出现，因为如果只继承基类的部分操作，违背了<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE32%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB">条款32</a>），可以直接定义一个同名同参的函数，然后在这个函数内调用基类的版本，做一个转调用。这实际上称为一种实现技术(而不是引入)更为恰当：</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-4.png"><img src="/../images/cppeffective-6-4.png" alt="img"></a></p><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><blockquote><p>纯虚函数一般作为接口，基类一般不提供定义，但是基类可以为纯虚函数提供定义。派生类必须声明纯虚函数，如果想要使用纯虚函数，派生类必须提供一份定义，即使基类已经为该纯虚函数提供了定义。如果派生类不提供定义，仍然是一个抽象基类</p></blockquote><ol><li><strong>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口</strong></li><li><strong>声明(非纯)impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现</strong></li><li><strong>声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现</strong></li></ol><h3 id="1）pure-virtual函数"><a href="#1）pure-virtual函数" class="headerlink" title="1）pure virtual函数"></a>1）pure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且没有相同的缺省实现，那么应该使用pure virtual函数，此时派生类只继承接口</p><h3 id="2）impure-virtual函数"><a href="#2）impure-virtual函数" class="headerlink" title="2）impure virtual函数"></a>2）impure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且具有相同的缺省实现，那么应该使用impure virtual函数，此时派生类继承接口和缺省实现</p><p><strong>但是，允许impure virtual函数同时指定函数声明和缺省行为，却可能造成危险：假设引入了一个新的派生类，但是缺省行为并不适用于新的派生类，而新的派生类忘记重新定义新的行为，那么调用该操作将表现出缺省行为，这是不合理的</strong></p><p>例如，某个航空公司有A,B两种类型的飞机，他们有相同的fly行为，这个fly行为在基类Airplane中声明为impure virtual函数，并且具有缺省的飞行实现。现在引入了一种新机型C，但是这个缺省的fly行为并不适合C，如果C忘记重新定义fly，那么它将按照A,B缺省的行为飞行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 缺省的fly代码</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br>Airplane* p = <span class="hljs-keyword">new</span> ModelC;<br>p-&gt;<span class="hljs-built_in">fly</span>();   <span class="hljs-comment">//调用Airplane::fly</span><br></code></pre></td></tr></table></figure><p>a）要避免这种错误，可以将fly改为pure virtual函数，并且将缺省的飞行行为实现为一个protected函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//这是合理的，因为它是Airplane及其derived classes的实现细目。乘客应该只在意飞机能不能飞，不在意它怎么飞</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">//non-virtual函数，因为没有任何一个派生类应该重新定义缺省行为</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFly</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，fly变成了pure virtual函数，首先，飞机C必须声明fly函数，如果需要使用，必须为其定义。那么就可以防止因为忘记重新定义而引起的错误</p><p>b）有些人反对以不同函数分别提供接口和缺省实现，像上面的fly和defaultFly。因为他们关心因过渡雷同函数名称而引起的class命名空间污染问题。那么可以将缺省的行为定义在fly中，即为fly实现一份缺省的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 缺省的fly代码</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        Airplane::<span class="hljs-built_in">fly</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于任何派生类想要使用pure virtual函数都必须提供一份定义，那么如果想要使用缺省行为，可以直接在定义中转调用基类的实现。否则，可以定制特殊的行为。因为是纯虚函数，只要不定义就无法使用，因此也可以避免前面的问题</p><h3 id="3）non-virtual函数"><a href="#3）non-virtual函数" class="headerlink" title="3）non-virtual函数"></a>3）non-virtual函数</h3><p>如果某个操作在整个体系中，应该表现出一致的行为，那么应该使用non-virtual函数。此时派生类继承接口和一份强制性实现</p><h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><blockquote><p>在面向对象中，如果希望某个操作存在缺省算法，并且各派生类可以定制适合自己的操作。可以使用public virtual函数，这是最简单直白且容易想到的方法，但是除此之外，也存在其它可替代的方案。它们有各自的优缺点，应该将所有方案全部列入考入</p></blockquote><p>以一个例子来介绍其它几种可替代方案。在一个游戏人物的类中，存在一个健康值计算的函数，不同的角色可以提供不同的健康值计算方法，并且存在一个缺省实现。以传统的public virtual函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//健康值计算函数，派生类可以重新定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1）藉由Non-Virtual-Interface手法实现Template-Method模式"><a href="#1）藉由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="1）藉由Non-Virtual Interface手法实现Template Method模式"></a>1）藉由Non-Virtual Interface手法实现Template Method模式</h3><p>这种方案的主要思想是：保留healthValue为public成员，但是让其成为non-virtual，并调用一个private(也可以是protected) virtual函数进行实际工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...                             <span class="hljs-comment">//做一些事前工作</span><br>        <span class="hljs-type">int</span> retVal = <span class="hljs-built_in">doHealthValue</span>();   <span class="hljs-comment">//负责真正的健康值计算</span><br>        ...                             <span class="hljs-comment">//做一些事后工作</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">doHealthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-comment">//派生类可以重新定义</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...     <span class="hljs-comment">//缺省的健康值计算方法</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>NVI手法的一个优点是可以在真正操作进行的前后保证一些“事前”和“事后”工作一定会进行。如“事前”进行一些锁的分配，日志记录。“事后”进行解锁等操作</p><h3 id="2）藉由Function-Pointers实现Strategy模式"><a href="#2）藉由Function-Pointers实现Strategy模式" class="headerlink" title="2）藉由Function Pointers实现Strategy模式"></a>2）藉由Function Pointers实现Strategy模式</h3><p>上面的方案本质还是使用virtual函数，人物的健康值计算(操作)还是与人物(类)相关。后面这几种方案，都是将任务的健康值计算(操作)与具体的每个人(对象)相关，并且可以每个人(对象)的健康值计算(操作)可以修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*HealthCalcFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个人物(类)包含一个计算健康值的函数指针，每创建一个人(对象)时，可以为其指定不同的健康值计算函数。因此将操作和类分离。同时，如果提供修改函数指针成员的方法，每个对象还能使用不同的计算方法</p><h3 id="3）藉由tr1-function完成Strategy模式"><a href="#3）藉由tr1-function完成Strategy模式" class="headerlink" title="3）藉由tr1::function完成Strategy模式"></a>3）藉由tr1::function完成Strategy模式</h3><p>这种方案是前一种的加强，将函数指针改成任何可调用对象。因此允许任何与可调用声明相兼容(即可以通过类型转换与声明相符)的可调用物</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//现在，类型HealthCalcFunc从函数指针变成了可调用物</span><br>    <span class="hljs-keyword">typedef</span> std::tr1::function&lt;<span class="hljs-type">int</span> (<span class="hljs-type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4）传统的Stategy模式"><a href="#4）传统的Stategy模式" class="headerlink" title="4）传统的Stategy模式"></a>4）传统的Stategy模式</h3><p>传统的Stategy模式做法会将健康计算函数做成一个分离的继承体系中的virtual成员函数，设计结果看起来像这样:</p><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-5.png"><img src="/../images/cppeffective-6-5.png" alt="img"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthCalcFunc</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">cacl</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span> <span class="hljs-type">const</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br><span class="hljs-comment">//创建一个HealthCalcFunc对象，可以通过它调用缺省的健康值计算方法</span><br>HealthCalcFunc defaultHealthCalc;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span> : pHealthCalc(phcf) &#123;</span>&#125;<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pHealthCalc-&gt;<span class="hljs-built_in">cacl</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc *pHealthCalc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个方案的吸引力在于，熟悉标准Strategy模式的人很容易辨认它，而且它还提供“将一个既有的健康算法纳入使用”的可能性——只要为HealthCalcFunc继承体系添加一个derived class即可</p><h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p>从规范上说，<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE34%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">条款34</a>提到，如果某个操作在整个继承体系应该是不变的，那么使用non-virtual函数，此时派生类从基类继承接口以及一份强制实现。如果派生类希望表现出不同行为，那么应该使用virtual函数</p><p>另一方面，假设真的重新定义了继承而来的non-virtual函数，会表现出下列令人困惑的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//重新定义了继承而来的non-virtual函数</span><br>&#125;;<br><br>D x;<br>B *pB = &amp;x;<br>D *pD = &amp;x;<br><br>pB-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用B::mf</span><br>pD-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用D::mf</span><br></code></pre></td></tr></table></figure><p>你可能会觉得因为pB和pD指向的是相同的对象，因此调用的non-virtual函数也应该相同，但是事实并非如此。因为<strong>non-virtual函数是静态绑定</strong>，因此实际上调用的函数由指针或引用决定</p><h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p><a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE36%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0">条款36</a>论述了non-virtual函数不应该被重新定义，那么non-virtual函数中的参数也就不存在被重新定义的机会。因此这里主要针对的是virtual函数</p><p><strong>原因就在于，virtual函数是动态绑定，而缺省参数值却是静态绑定</strong>。所以你可能调用了一个派生类的virtual函数，但是使用到的缺省参数，却是基类的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br>Rectangle r;<br>Circle c;<br><br>r.<span class="hljs-built_in">draw</span>();           <span class="hljs-comment">//调用Rectangle::draw，静态类型为Rectangle，所以缺省参数为Shape::Green</span><br><span class="hljs-comment">//c.draw();         //调用Circle::draw，静态类型为Circle，没有缺省参数，因此错误，必须显式指定！</span><br><br>Shape *pr = &amp;r;<br>Shape *pc = &amp;c;<br><br><span class="hljs-comment">//以下为容易引起困惑的地方，函数与参数不一致</span><br>pr-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Rectangle::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br>pc-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Shape::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br></code></pre></td></tr></table></figure><p>但是，即使派生类严格遵循基类的缺省参数，也存在问题：当基类的缺省参数发生变化时，派生类的所有缺省参数也需要跟着修改。因此，<strong>本质在于，不应该在virtual函数中使用缺省参数</strong>，如果有这样的需求，那么这种场景就适合使用<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#">条款35</a>中，public virtual函数的几种替代方案，比如NVI手法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-comment">//此时，带缺省参数的已经不是virtual函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">doDraw</span>(color);  <span class="hljs-comment">//调用一个virtual</span><br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//完成真正的工作</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h2><blockquote><p>复合是类型间的一种关系，当某种类型的对象含有另一种类型的对象，便是这种关系</p></blockquote><p>复合意味着has-a(有一个)或is-implemented-in-terms-of(根据某物实现出)</p><ul><li><p>has-a：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>    Address address;<br>    PhoneNumber voiceNumber;<br>    PhoneNumber faxNumber;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>根据某物实现出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> stack &#123;<br>...<br><span class="hljs-keyword">protected</span>:<br>  Sequence c;   <span class="hljs-comment">//底层容器</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>上面两者情况都应该使用复合，而不是public继承。在has-a中，每个人肯定不是一个地址，或者电话。显然不能是is-a的关系。而对于后者，由于每个栈只能从栈顶压入弹出元素，而队列不同，is-a的性质是所有对基类为true的操作，对派生类也应该为true。所以stack也不应该通过public继承deque来实现，因此使用复合</p><h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><p><strong>private继承和public继承的不同之处</strong>：</p><ul><li><p>编译器不会把子类对象转换为父类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">private</span> Person &#123; ... &#125;;     <span class="hljs-comment">// private继承</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span></span>;                 <span class="hljs-comment">// 任何人都会吃</span><br>Person p;                                  <span class="hljs-comment">// p是人</span><br>Student s;                                 <span class="hljs-comment">// s是学生</span><br><span class="hljs-built_in">eat</span>(p);                                    <span class="hljs-comment">// 没问题，p是人，会吃</span><br><span class="hljs-built_in">eat</span>(s);                                    <span class="hljs-comment">// 错误！难道学生不是人？！</span><br></code></pre></td></tr></table></figure><p>如果使用public继承，编译器在必要的时候可以将Student隐式转换成Person，但是private继承时不会，所以eat(s)调用失败。从这个例子中表达了，private继承并不表现出is-a的关系。实际上</p><p>private表现出的是”is-implemented-in-terms-of”的关系</p></li><li><p><strong>父类成员（即使是public、protected）都变成了private</strong></p></li></ul><p><a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE38%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA">条款38</a>提到，复合也是可以表现出”is-implemented-in-terms-of”的关系，那么两者有什么区别？</p><h3 id="1）private继承"><a href="#1）private继承" class="headerlink" title="1）private继承"></a>1）private继承</h3><p>假设Widget类需要执行周期性任务，于是希望继承Timer的实现。 因为Widget不是一个Timer，所以选择了private继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> tickFrequency)</span></span>;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <span class="hljs-comment">// 每滴答一次，该函数就被自动调用一次</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">private</span> Timer &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 查看Widget的数据...等等</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在Widget中重写虚函数onTick，使得Widget可以周期性地执行某个任务</p><p>通过private继承来表现”is-implemented-in-terms-of”关系实现非常简单，而且下列情况也只能使用这种方式：</p><ul><li>当Widget需要访问Timer的protected成员时。因为对象组合后只能访问public成员，而private继承后可以访问protected成员。</li><li>当Widget需要重写Timer的虚函数时。比如上面的例子中，需要重写onTick。单纯的复合是做不到的</li></ul><h3 id="2）复合"><a href="#2）复合" class="headerlink" title="2）复合"></a>2）复合</h3><p>如果使用复合，上面的例子可以这样实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetTimer</span>: <span class="hljs-keyword">public</span> Timer &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    &#125;;<br>    WidgetTimer timer;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过复合来表现”is-implemented-in-terms-of”关系，实现较为复杂，但是具有下列优点：</p><ul><li>如果希望禁止Widget的子类重定义onTick。因为派生类无法访问私有的WidgetTimer类</li><li>可以减小Widget和Timer的编译依赖。如果是private继承，在定义Widget的文件中势必需要引入#include”timer.h”。 但如果采用复合的方式，可以把WidgetTimer放到另一个文件中，在Widget中使用WidgetTimer*并声明WidgetTimer即可</li></ul><p>总的来说，在需要表现”is-implemented-in-terms-of”关系时。如果一个类需要访问基类的protected成员，或需要重新定义其一个或多个virtual函数，那么使用private继承。否则，在考虑过所有其它方案后，仍然认为private继承是最佳办法，才使用它</p><h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><p>使用多继承时，一个问题是不同基类可能具有相同名称，产生歧义（即使一个名字可访问，另一个不可访问）</p><p>一般有两种方式使用多继承：</p><ul><li><p>一般的多重继承</p><ul><li>如果某个基类到派生类之间存在多条路径，那么派生类会包含重复的基类成员</li></ul><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-6.png"><img src="/../images/cppeffective-6-6.png" alt="img"></a></p></li><li><p>虚继承（此时基类是虚基类）</p><ul><li>如果某个基类到派生类之间存在多条路径，派生类只包含一份基类成员，但是这会带来额外开销<ul><li>为避免重复，编译器必须提供一些机制，后果就是virtual继承的那些classes所产生的对象往往比non-virtual继承的体积大，访问virtual base classes的成员变量时，速度也更慢</li><li>virtual base的初始化由继承体系中的最底层class负责，这会带来开销<ul><li>classes若派生自virtual bases而需要初始化，必须认知其virtual bases——无论那些bases距离多远</li><li>当一个新derived class加入继承体系中，它必须承担其virtual bases的初始化责任</li></ul></li></ul></li></ul><p><a href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-7.png"><img src="/../images/cppeffective-6-7.png" alt="img"></a></p></li></ul><p>如果你有一个单一继承的设计方案，而它大约等价于一个多重继承方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候是完成任务的最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。只要确定，你的确是在明智而审慎的情况下使用它</p><h1 id="七-模板与泛型编程"><a href="#七-模板与泛型编程" class="headerlink" title="七.模板与泛型编程"></a>七.模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译器多态"><a href="#条款41：了解隐式接口和编译器多态" class="headerlink" title="条款41：了解隐式接口和编译器多态"></a>条款41：了解隐式接口和编译器多态</h2><p>面向对象设计中的类（class）考虑的是显式接口（explicit interface）和运行时多态， 而模板编程中的<strong>模板（template）考虑的是隐式接口（implicit interface）和编译期多态</strong>。</p><ul><li>对类而言，显式接口是由函数签名表征的，运行时多态由虚函数实现</li><li>对模板而言，隐式接口是由表达式的合法性表征的，编译期多态由模板初始化和函数重载的解析实现</li></ul><h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p>以下代码中，typename和class等价：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br></code></pre></td></tr></table></figure><p>但是如果在template中，遇到嵌套从属名称，需要明确声明是一种类型时，必须使用typename。考虑如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们认为C::const_iterator表示容器C的迭代器类型，因此上述代码定义一个该迭代器类型的指针。但是这是一种先入为主的思想。如果C::const_iterator不是一个类型呢？比如恰巧有个static成员变量被命名为const_iterator，或如果x碰巧是个global变量名称？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作</p><p>因此，C++有个规则解决这种歧义：如果解析器在template中遭遇一个嵌套从属名称，它便假设这个名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。那么怎么告诉它是一个类型，当然就是typename了，所以上述代码应该像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typename</span> C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，<strong>规则是：除了下面2个例外，任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename：</strong></p><ol><li><strong>typename不可出现在base classes list内的嵌套从属名称之前</strong></li><li><strong>typename也不可出现在成员初始值列表中作为base class修饰符</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested&#123; <span class="hljs-comment">//typename不可出现在此</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">explict <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : Base&lt;T&gt;::Nested(x) //typename也不可出现在此</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;  <span class="hljs-comment">//这里必须使用typename</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>typename相关规则在不同的编译器上有不同的实践。某些编译器接收的代码原本该有typename却遗漏了；原本不该有typename却出现了；还有少数编译器（通常是较旧版本）根本就拒绝typename。这意味typename和“嵌套从属名称”之间的互动，也会在移植性方面给你带来一些麻烦</p><h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p>假设以下MsgSender类可以通过两种方式发送信息到各个公司：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//1.发送原始文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...<br>        Company c;<br>        c.<span class="hljs-built_in">sendCleartext</span>(...);   <br>    &#125;<br>    <span class="hljs-comment">//2.发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>假设我们有时候想要在每次送出信息时志记(log)某些信息。因此有了以下派生类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);             <span class="hljs-comment">//调用base class函数，无法通过编译</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在问题是，如果有一个公司CompanyZ只支持加密传送，那么泛化的MsgSender就不适合，因此需要为其产生一个特化版的MsgSender：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&lt;CompanyZ&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//只支持发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此，当base class被指定为MsgSender时，其内不包含sendClear方法，那么derived class LoggingMsgSender的sendClearMsg方法就会调用不存在sendClear</p><p><strong>因此，正是因为知道base class templates有可能被特化，而那么特化版本可能不提供和一般性template相同的接口。因此C++往往拒绝在templatized base classes（模板化基类，本例的MsgSender<Company>）内寻找继承而来的名称（本例的SendClear）</strong></p><p><strong>解决办法有3个，它们会通知编译器:进入base class作用域查找继承而来的名称</strong>：</p><ol><li><p>使用this-&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>使用using</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//告诉编译器，请它假设sendClear位于base class内</span><br>    <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通过作用域符明确指出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(...);  <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方法往往最不让人满意，因为如果被调用的是virtual函数，这样会关闭”virtual绑定行为“</p></li></ol><p>要注意的是，它们只是通知编译器进去查找。如果找到了自然是没问题。但是如同上面的CompanyZ，如果基类还是不存在相应名称，编译器还是会报错</p><h2 id="条款44：将与参数无关的代码抽离templates"><a href="#条款44：将与参数无关的代码抽离templates" class="headerlink" title="条款44：将与参数无关的代码抽离templates"></a>条款44：将与参数无关的代码抽离templates</h2><p>模板提供的是编译期的多态， 即使你的代码看起来非常简洁短小，生成的二进制文件也可能包含大量的冗余代码。 因为模板每次实例化都会生成一个完整的副本，所以其中与模板参数无关的部分会造成代码膨胀</p><p>把模板中参数无关的代码重构到模板外便可以有效地控制模板产生的代码膨胀：</p><ul><li><p>对于非类型模板参数产生的代码膨胀，用函数参数或成员变量来替换模板参数即可消除冗余</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//非类型模板参数造成代码膨胀</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//求逆矩阵</span><br>&#125;;<br><span class="hljs-comment">//以下会实例化两个类：Square&lt;double, 5&gt;和Square&lt;double, 10&gt;</span><br><span class="hljs-comment">//会具现化两份invert。除了常量5和10，两个函数的其它部分完全相同</span><br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">5</span>&gt; s1;<br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10</span>&gt; s2;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">invert</span>();<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">invert</span>();<br><span class="hljs-comment">//以下，使用函数参数消除重复</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareBase</span>&#123;<br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-comment">//以下函数只是作为避免代码重复的方法，并不应该被外界调用，</span><br>    <span class="hljs-comment">//同时，该函数希望被子类调用，因此使用protected</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>:<span class="hljs-keyword">private</span> SquareBase&lt;T&gt;&#123;<span class="hljs-comment">//只要T相同，都会使用同一份父类实例，</span><br><span class="hljs-keyword">private</span>:                           <span class="hljs-comment">//因此，只有一份invert(int size)</span><br>    <span class="hljs-keyword">using</span> SquareBase&lt;T&gt;::invert;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//调用父类invert的代价为零，因为Square::invert是隐式的inline函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是父类如何访问矩阵数据。原本这些数据在派生类中，但是因为invert核心代码转移到了父类，那么父类必须有办法访问这些数据。可以在调用SquareBase::invert时把内存地址也一起告知父类，但如果矩阵类中有很多函数都需要这些信息就需要为每个函数添加一个这样的参数。因此，可以把数据地址直接放在父类中</p></li><li><p>对于类型模板参数产生的代码膨胀，可以让不同实例化的模板类共用同样的二进制表示</p><ul><li>int和long在多数平台都是一样的底层实现，然而模板却会实例化为两份，因为它们类型不同</li><li>List&lt;int <em>&gt;, List&lt;const int *&gt;, List&lt;double *&gt;的底层实现也是一样的。但因为指针类型不同，也会实例化为多份模板类 如果某些成员函数操作强型指针(T</em>)，应该令它们调用另一个操作无类型指针(void*)的函数，后者完成实际工作</li></ul></li></ul><h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>需要使用成员函数模板的一个例子是构造函数和copying赋值运算符。例如，假设SmartPtr是一种智能指针，并且它是一个template class。现在有一个继承体系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Top</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span> : <span class="hljs-keyword">public</span> Top &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span> : <span class="hljs-keyword">public</span> Middle &#123;...&#125;;<br></code></pre></td></tr></table></figure><p>现在希望通过一个SmartPtr<Bottom>或SmartPtr<Middle>来初始化一个SmartPtr<Top>。如果是指针，即Middle<em>和Bottom</em>可以隐式转换成Top*，问题是：<strong>同一个template的不同具现体之间不存在什么与生俱来的固有关系，即使具现体之间具有继承关系</strong>。因此，SmartPtr<Bottom>或SmartPtr<Middle>并不能隐式转化成SmartPtr<Top>。因此，我们需要一个构造函数模板，来实现这种转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数模板</span><br>    <span class="hljs-comment">//意思是：对任何类型T和任何类型U，可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt; &amp;other)</span></span><br><span class="hljs-function">     : heldPtr(other.get()) &#123;</span>...&#125;<br>    <span class="hljs-comment">//原始指针为private成员，需要一个接口来获取</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> heldPtr;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    T* heldPtr;   <span class="hljs-comment">//智能指针所持有的原始指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们当然不希望一个SmartPtr<Top>可以转化成SmartPtr<Bottom>或SmartPtr<Middle>， <code>heldPtr(other.get())</code>为次提供了保证。这个行为只有当“存在某个隐式转换可将一个U<em>指针转为一个T</em>指针”时才能通过编译</p><p>最后需要指明的是：<strong>member templates并不改变语言规则</strong>，而语言规则说，如果程序需要一个copy构造函数，你却没声明它，编译器会为你暗自生成一个。因此，使用member templates实现一个泛化版的copy构造函数时，编译器也会合成一个“正常的”copy构造函数</p><h2 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h2><p><strong>template实参推导过程中从不将隐式类型转换函数纳入考虑</strong>，下列将<a href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE24%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0">条款24</a>中的Rational和operator*改成了template，混合运算会编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">const</span> T &amp;numerator = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> T &amp;denominator = <span class="hljs-number">1</span>);<br>    <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt; &amp;lhs,<span class="hljs-type">const</span> Rational&lt;T&gt; &amp;rhs)<br>&#123; ... &#125;<br><br><span class="hljs-function">Rational&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">oneHalt</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>Rational&lt;<span class="hljs-type">int</span>&gt; result = oneHalf * <span class="hljs-number">2</span>   <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>将oneHalf传递给operator*时，它将T推断为int，因此期待第二个参数也为Rational，但是第二个参数为int，前面我们说了，template实参推导过程中从不将隐式类型转换函数纳入考虑。因此编译错误</p><p>那么解决办法是什么？在class template将其声明为friend，从而具现化一个operator*，具现化后就可以不受template的限制了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//也可以是Rational&lt;T&gt;，但是省去&lt;T&gt;更简洁</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.numerator,<br>                         lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果上面只有函数声明，而函数定义在类外，那么会报链接错误。当传入第一个参数oneHalt时，会具现化Rational<int>，编译器也就知道了我们要调用传入两个Rational<int>的版本，但是那个函数只在类中进行了声明，并没有定义，不能依赖类外的operator* template提供定义，我们必须自己定义，所以会出现链接错误。解决方法就是像上面一样定义与类内</p><p>这样看起来有点像是member函数，但是因为friend关键字，所以实际是non-member函数，如果去掉friend关键字，就成了member函数，但是此时参数也只能有1个，就不能实现所有参数的隐式转换</p><p>上面的代码可能还有一个问题，虽然有friend，上述函数仍是隐式的inline。如果函数实体代码量较大，可以令operator*不做任何事，只调用一个定义与class外部的辅助函数（当然这里没必要，因为本身只有1行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>;<br><br><span class="hljs-comment">//helper template</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">doMultiply</span>(lhs, rhs);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h2><ul><li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现</li><li>整合重载技术后，traits classes有可能在编译期对类型执行if…else测试</li></ul><p>详细可参考<a href="https://github.com/arkingc/note/blob/master/C++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md#2traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95">STL源码分析中对traits的介绍</a></p><h2 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款48：认识template元编程</h2><ul><li>Template metaprogramming(TMP)是编写template-based C++程序并执行于编译期的过程</li><li>Template metaprogram(模板元程序)是以C++写成、执行于C++编译器内的程序</li></ul><p><strong>TMP的两个重要特点：1）基于template；2）编译期执行</strong></p><p>TMP有2个伟大的效力：</p><ol><li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的</li><li>执行于编译期，因此可将工作从运行期转移到编译期。会导致以下几个结果<ul><li>某些原本在运行期才能侦测到的错误现在可在编译期找出来</li><li>使用TMP的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求</li><li>编译时间变长了</li></ul></li></ol><p>traits解法就是TMP，traits引发“编译器发生于类型身上的if…else计算”</p><p>另一个TMP的例子是循环，TMP并没有真正的循环构件，所以循环效果藉由递归完成。TMP的递归甚至不是正常种类，因为TMP循环并不涉及递归函数调用，而是涉及“递归模板具现化”。以计算阶乘为例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&#123;    <span class="hljs-comment">//一般情况，Factorial&lt;n&gt;的值是n乘以Factorial&lt;n-1&gt;</span><br>    <span class="hljs-keyword">enum</span> &#123;value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value&#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt;&#123;    <span class="hljs-comment">//特殊情况：Factorial&lt;0&gt;的值是1</span><br>    <span class="hljs-keyword">enum</span> &#123;value = <span class="hljs-number">1</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value;    <span class="hljs-comment">//打印120</span><br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">10</span>&gt;::value;   <span class="hljs-comment">//打印3628800</span><br>&#125;<br></code></pre></td></tr></table></figure><p>TMP能够达到以下目标（这部分可以等有实际需求了再去详细了解）：</p><ul><li>确保量度单位正确</li><li>优化矩阵运算</li><li>可以生成客户定制的设计模式实现品</li></ul><h1 id="八-定制new和delete"><a href="#八-定制new和delete" class="headerlink" title="八.定制new和delete"></a>八.定制new和delete</h1><ul><li>operator new 和 operator delete用来分配单一对象</li><li>Arrays所用的内存由operator new[]分配出来，并由operator delete[]归还</li><li>STL容器使用的heap内存由容器所拥有的分配器对象管理</li></ul><h2 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h2><p>operator new抛出异常以反映一个未获满足的内存需求之前，会先调用一个客户指定的错误处理函数，new-handler，可以通过调用<code>std::set_new_handler()</code>来设置，<code>std::set_new_handler()</code>定义在<new>中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">namespace std&#123;<br>    typedef void (*new_handler)();<br>    new_handler <span class="hljs-built_in">set_new_handler</span>(new_handler p) <span class="hljs-built_in">throw</span>(); <br>    <span class="hljs-comment">//以上，throw()是一个异常声明，括号内无任何内容，表示不抛任何异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当operator new无法满足内存申请时，它会不断调用new-handler函数，直到找到足够内存。一个设计良好的new-handler函数必须做以下事情；</p><ul><li><strong>让更多内存可被使用</strong>：一个做法是程序一开始执行就分配一大块内存，而后当new-handler第一次被调用，将它们还给程序使用。这便造成operator new内的下一次内存分配动作可能成功</li><li><strong>安装另一个new-handler</strong>：如果当前new-handler无法取得更多可用内存，可用安装另一个，下次operator new时会调用新的new-handler</li><li><strong>卸除new-handler</strong>：将null指针传给set_new_handler</li><li><strong>抛出bad_alloc(或派生自bad_alloc)的异常</strong>：这样的异常不会被operator new捕获，因此会被传播到内存索求处</li><li><strong>不返回</strong>：通常调用abort或exit（abort会设置程序非正常退出，exit会设置程序正常退出，当存在未处理异常时C++会调用terminate， 它会回调由std::set_terminate设置的处理函数，默认会调用abort）</li></ul><h3 id="实现class专属的new-handlers"><a href="#实现class专属的new-handlers" class="headerlink" title="实现class专属的new-handlers"></a>实现class专属的new-handlers</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerHolder</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NewHandlerHolder</span><span class="hljs-params">(std::new_handler nh)</span>: handler(nh)&#123;</span>&#125;<br>    ~<span class="hljs-built_in">NewHandlerHolder</span>()&#123; std::<span class="hljs-built_in">set_new_handler</span>(handler); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::new_handler handler;<br>    <span class="hljs-built_in">NewHandlerHolder</span>(<span class="hljs-type">const</span> HandlerHolder&amp;);     <span class="hljs-comment">// 禁用拷贝构造函数</span><br>    <span class="hljs-type">const</span> NewHandlerHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NewHandlerHolder&amp;); <span class="hljs-comment">// 禁用赋值运算符</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerSupport</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> std::new_handler current;   <span class="hljs-comment">//class专属的new-handlers</span><br>&#125;;<br><br><span class="hljs-comment">//class专属的new-handlers初始化为null</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::current = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::<span class="hljs-built_in">set_new_handler</span>(std::new_handler p) <span class="hljs-keyword">throw</span>()&#123;<br>    std::new_handler old = current;<br>    current = p;    <span class="hljs-comment">//将class专属的new-handlers设置为新的new_handler</span><br>    <span class="hljs-keyword">return</span> old;     <span class="hljs-comment">//返回旧的class专属的new-handlers</span><br>&#125;<br><br><span class="hljs-comment">//new时会调用该operator new</span><br><span class="hljs-comment">//它会设置全局的new-handlers为该class专属的new-handlers，然后调用全局operator new申请内存</span><br><span class="hljs-comment">//h对象销毁后，其析构函数会将全局new-handlers恢复为调用前的状态</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> * NewHandlerSupport&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>&#123;<br>    <span class="hljs-function">NewHandlerHolder <span class="hljs-title">h</span><span class="hljs-params">(std::set_new_handler(current))</span></span>;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>&#125;<br></code></pre></td></tr></table></figure><p>有了<code>NewHandlerSupport</code>这个模板基类后，给Widget添加”new-handler”支持只需要public继承即可:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Widget: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">NewHandlerSupport</span>&lt;<span class="hljs-symbol">Widget</span>&gt;&#123; ... &#125;;<br></code></pre></td></tr></table></figure><p><code>NewHandlerSupport</code>的实现和模板参数T完全无关，添加模板参数是因为handler是静态成员，这样编译器才能为每个类型生成一个handler实例</p><h3 id="nothrow-new"><a href="#nothrow-new" class="headerlink" title="nothrow new"></a>nothrow new</h3><p>1993年之前C++的operator new在失败时会返回null而不是抛出异常。如今的C++仍然支持这种nothrow的operator new</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget *p1 = <span class="hljs-keyword">new</span> Widget;    <span class="hljs-comment">// 失败时抛出 bad_alloc 异常</span><br><span class="hljs-keyword">if</span>(p1 == <span class="hljs-number">0</span>) ...             <span class="hljs-comment">// 这个测试一定失败</span><br><br>Widget *p2 = <span class="hljs-built_in">new</span> (std::nothrow) Widget;<br><span class="hljs-keyword">if</span>(p2 == <span class="hljs-number">0</span>) ...             <span class="hljs-comment">// 这个测试可能成功</span><br></code></pre></td></tr></table></figure><p>nothrow new只能保证所调用的nothrow版的operator new不抛出异常，但是构造也属于new的一个步骤，而它没法强制构造函数不抛出异常，所以并不能保证<code>new (std::nothrow) Widget</code>这样的表达式绝不导致异常</p><h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><p>一般出于下列原因可能想要替换编译器提供的operator new或operator delete：</p><ul><li>为了检测运用错误</li><li>为了收集动态分配内存的使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><p>下面是一个”为了检测运用错误“而实现的简单的operator new的例子，通过在首部和尾部插入一个签名，返回中间内存块给程序使用，如果程序在使用内存时发生过在区块前或区块后写入的行为，那么签名就会被修改，因此可以检测这种行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> signature = <span class="hljs-number">0xDEADBEEF</span>;    <span class="hljs-comment">// 边界符</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Byte; <br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span> </span>&#123;<br>    <span class="hljs-comment">// 多申请一些内存来存放占位符 </span><br>    <span class="hljs-type">size_t</span> realSize = size + <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>); <br><br>    <span class="hljs-comment">// 申请内存</span><br>    <span class="hljs-type">void</span> *pMem = <span class="hljs-built_in">malloc</span>(realSize);<br>    <span class="hljs-keyword">if</span> (!pMem) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>(); <br><br>    <span class="hljs-comment">// 写入边界符</span><br>    *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>))) <br>        = *(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pMem)) = signature;<br><br>    <span class="hljs-comment">// 返回真正的内存区域</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子主要是展示，它存在很多错误：</p><ol><li>所有的operator new都应该内含一个循环，反复调用某个new-handling函数，这里却没有</li><li>C++要求所有operator new返回的指针都有适当的对齐。这里malloc返回的指针是满足要求的，但是因为上述实现并不是直接返回malloc的结果，而是返回一个int偏移后的地址，因此无法保证它的安全</li></ol><h2 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h2><p>前一条款是解释什么时候会想实现自己的 operator new 和 operator delete，这个条款是解释当实现自己的 operator new 和 operator delete 时，必须遵守的规则</p><h3 id="1）operator-new"><a href="#1）operator-new" class="headerlink" title="1）operator new"></a>1）operator new</h3><p>实现一致性的operator new必得返回正确的值，内存不足时必得调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new</p><p>下面是non-member operator new的伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;          <span class="hljs-comment">//处理0-byte申请</span><br>        size = <span class="hljs-number">1</span>;           <span class="hljs-comment">//将它视为1-byte</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        尝试分配<span class="hljs-function">size bytes</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(分配成功)</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-params">(一个指针，指向分配得来的内存)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-comment">//分配失败：找出目前的new-handling函数</span></span><br><span class="hljs-function">        new_handler globalHandler </span>= <span class="hljs-built_in">set_new_handler</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">set_new_handler</span>(globalHandler);<br>        <br>        <span class="hljs-keyword">if</span>(globalHandler) (*globalHandler)();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在继承中定制member operator new时，一般是针对某特定class的对象分配行为提供最优化，此时，并不是为了该class的任何derived classes。也就是说，针对class X而设计的operator new，其行为很典型地只为大小刚好为sizeof(X)的对象而设计。然而一旦被继承下去，有可能base class的operator new被调用用以分配derived class对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base  <span class="hljs-comment">//假设Derived未声明operator new</span><br>&#123;...&#125;;<br><br>Derived *p = <span class="hljs-keyword">new</span> Derived;    <span class="hljs-comment">//这里调用的是Base::operator new</span><br></code></pre></td></tr></table></figure><p>如果Base class专属的operator new并没有设计上述问题的处理方法，那么最佳做法是将“内存申请量错误”的调用行为改采标准operator new，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))            <span class="hljs-comment">//如果大小错误</span><br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    <span class="hljs-comment">//交给标准的operator new处理</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）operator-delete"><a href="#2）operator-delete" class="headerlink" title="2）operator delete"></a>2）operator delete</h3><p>operator delete比起operator new更简单，需要记住的唯一事情就是C++保证“删除null指针永远安全”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//如果将被删除的是个null指针，那就什么都不做</span><br>    现在，归还rawMemory所指的内存；<br>&#125;<br></code></pre></td></tr></table></figure><p>member版本也很简单，只需要多一个动作检查删除数量。万一class专属的operator new将大小有误的分配行为转交::operator new执行，你也必须将大小有误的删除行为转交::operator delete执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory,std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;         <span class="hljs-comment">//检查null指针</span><br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))&#123;           <span class="hljs-comment">//如果大小错误，令标准版</span><br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMemory)</span></span>;   <span class="hljs-comment">//operator delete处理此一申请</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    现在，归还rawMemory所指的内存<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果即将被删除的对象派生自某个base class，而后者欠缺virtual析构函数，那么C++传给operator delete的size_t数值可能不正确。这是“让你的base classes拥有virtual析构函数”的一个够好的理由</p><h2 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了placement new也要写placement delete</h2><p>placement new是带有额外参数的operator new，但是通常都指“接受一个指针指向对象该被构造之处”的operator new。这个版本被纳入了C++标准程序库，只要#include<new>\就可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>new会先调用operator new，然后构造对象。如果对象构造过程中发生异常，那么需要调用相应的operator delete，否则会发生内存泄露。而operator delete必须和相应的operator new匹配</p><ul><li>对于正常版本的operator new，匹配的operator delete就是不带额外参数的版本</li><li>对于非正常版本的operator new(placement new)，匹配的operator delete是带相应参数的版本(placement delete)</li></ul><p><strong>placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针施行delete绝不会导致调用placement delete</strong></p><p>这意味着如果要对所有与placement new相关的内存泄露宣战，我们必须同时提供一个正常的operator delete（用于构造期间无任何异常被抛出）和一个placement版本（用于构造期间有异常被抛出）。后者的额外参数必须和operator new一样。只要这样做，就再也不会因为难以察觉的内存泄露而失眠</p><p>还需要注意名称掩盖的问题：</p><ul><li>成员函数的名称会掩盖外围作用域中的相同名称</li><li>子类的名称会掩盖所有父类相同的名称</li></ul><p>一个比较好的方法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardNewDeleteForms</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//正常的 new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);&#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;&#125;<br><br>    <span class="hljs-comment">//placement new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, ptr); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(pMemory, ptr); &#125;<br><br>    <span class="hljs-comment">// nothrow new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, nt); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> StandardNewDeleteForms &#123;      <span class="hljs-comment">//继承标准形式</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;     <span class="hljs-comment">//让这些形式可见</span><br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;<br><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; log)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;    <span class="hljs-comment">// 自定义 placement new</span><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, std::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 对应的 placement delete</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2022/04/30/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E4%BA%86%E6%97%A0%E6%95%B0%E5%9D%91/"/>
    <url>/2022/04/30/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E4%BA%86%E6%97%A0%E6%95%B0%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="0、当前系统环境"><a href="#0、当前系统环境" class="headerlink" title="0、当前系统环境"></a>0、当前系统环境</h2><p>windows 10</p><h2 id="1、下载Node-js和Git"><a href="#1、下载Node-js和Git" class="headerlink" title="1、下载Node.js和Git"></a>1、下载Node.js和Git</h2><h3 id="1-1、-下载Node-js"><a href="#1-1、-下载Node-js" class="headerlink" title="1.1、 下载Node.js"></a>1.1、 下载Node.js</h3><p>下载链接，选择长期维护版本：<br><code>https://nodejs.org/zh-cn/</code></p><p><img src="/../images/image-20220430224733035.png" alt="image-20220430224733035"></p><p>如果下载不了，试试这个链接：</p><p><code>http://nodejs.cn/download/</code></p><p><img src="/../images/image-20220430225101014.png" alt="image-20220430225101014"></p><p>安装一路next</p><p>安装完后 管理员身份打开cmd，输入   <code>node -v</code>   如果有版本号代表安装成功了</p><p><img src="/../images/image-20220430225743400.png" alt="image-20220430225743400"></p><p>顺便看看有没有 npm  ，输入 <code>npm -v</code>  ，看有没有版本号</p><p><img src="/../images/image-20220430230032665.png" alt="image-20220430230032665"></p><h3 id="1-2、-下载Git"><a href="#1-2、-下载Git" class="headerlink" title="1.2、 下载Git"></a>1.2、 下载Git</h3><p>官网地址：</p><p><code>https://git-scm.com/download/win</code></p><p><img src="/../images/image-20220430225312396.png" alt="image-20220430225312396"></p><p>如果很卡用国内地址：</p><p><code>https://npm.taobao.org/mirrors/git-for-windows/</code></p><p>按照需要的下</p><p>我的是：</p><p><img src="/../images/image-20220430225405741.png" alt="image-20220430225405741"></p><p>然后</p><p><img src="/../images/image-20220430225432283.png" alt="image-20220430225432283"></p><p>解压</p><p>安装</p><p>安装时除了改安装地址那一步，其他的我全部是 next</p><p>安装完后输入   <code>git --version</code> ，有版本号就成功了</p><p><img src="/../images/image-20220430225923417.png" alt="image-20220430225923417"></p><h2 id="2、换源"><a href="#2、换源" class="headerlink" title="2、换源"></a>2、换源</h2><p>也可以不改，就是影响下速度而已</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><h2 id="3、创建文件夹Blog"><a href="#3、创建文件夹Blog" class="headerlink" title="3、创建文件夹Blog"></a>3、创建文件夹Blog</h2><p>创建一个文件夹Blog，其他操作都在这里面</p><p><img src="/../images/image-20220430230221129.png" alt="image-20220430230221129"></p><p>空文件夹</p><h2 id="3、安装hexo"><a href="#3、安装hexo" class="headerlink" title="3、安装hexo"></a>3、安装hexo</h2><p>管理员身份打开命令行</p><p><img src="/../images/image-20220430230140263.png" alt="image-20220430230140263"></p><p>并且换路径到 Blog下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">d:</span><br><span class="hljs-function"><span class="hljs-title">cd</span> <span class="hljs-title">Blog</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/image-20220430230313642.png" alt="image-20220430230313642"></p><p>输入<code>cnpm install -g hexo-cli</code></p><p>看看安装好没有，如果有错误，基本上都能百度出来</p><h2 id="4、初始化hexo"><a href="#4、初始化hexo" class="headerlink" title="4、初始化hexo"></a>4、初始化hexo</h2><p>hexo init </p><h2 id="5、生成界面文件"><a href="#5、生成界面文件" class="headerlink" title="5、生成界面文件"></a>5、生成界面文件</h2><p>hexo g</p><h2 id="6、搭建本地博客"><a href="#6、搭建本地博客" class="headerlink" title="6、搭建本地博客"></a>6、搭建本地博客</h2><p>hexo s</p><p>默认地址  127.0.0.1:4000</p><p>启动成功后， 大概这个样子</p><p><img src="/../images/image-20220430230610362.png" alt="image-20220430230610362"></p><h2 id="7、搭建远程博客"><a href="#7、搭建远程博客" class="headerlink" title="7、搭建远程博客"></a>7、搭建远程博客</h2><h3 id="7-1-创建github仓库"><a href="#7-1-创建github仓库" class="headerlink" title="7.1 创建github仓库"></a>7.1 创建github仓库</h3><p>打开github，没有账号注册一个，记住自己的邮箱和用户名</p><p><img src="/../images/image-20220430231213731.png" alt="image-20220430231213731"></p><p>创建仓库， 记住按照图上的方式填： <code>用户名.github.io</code> ，取名随便</p><p><img src="/../images/image-20220430231400803.png" alt="image-20220430231400803"></p><h3 id="7-2-安装插件"><a href="#7-2-安装插件" class="headerlink" title="7.2 安装插件"></a>7.2 安装插件</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="7-3-配置插件"><a href="#7-3-配置插件" class="headerlink" title="7.3 配置插件"></a>7.3 配置插件</h3><p>打开 Blog 目录下的 _config.yml 文件，编辑（记事本、Sublime、VS code都行），在文件末尾补上以下内容：</p><p>添加 repo和branch</p><p><img src="/../images/image-20220430231100098.png" alt="image-20220430231100098"></p><p>type 去掉引号，写入git</p><p>repo是下图的地址</p><p>branch是下图显示的，如果显示master就填master</p><p>注意<code>:</code>是英文并且后面有个空格</p><p><img src="/../images/image-20220430231810617.png" alt="image-20220430231810617"></p><h3 id="7-4-配置全局用户"><a href="#7-4-配置全局用户" class="headerlink" title="7.4 配置全局用户"></a>7.4 配置全局用户</h3><p>在 Blog目录下输入命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;1355165054@qq.com&quot;</span><br><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;liruilong9999&quot;</span><br></code></pre></td></tr></table></figure><p><em><strong>这里的邮箱和用户名换成github注册邮箱和用户名，别把我的抄上了。。。</strong></em></p><p>查看配置好了吗</p><p><code>git congif --list</code></p><p><img src="/../images/image-20220430232300558.png" alt="image-20220430232300558"></p><h3 id="7-5-生成密钥"><a href="#7-5-生成密钥" class="headerlink" title="7.5 生成密钥"></a>7.5 生成密钥</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;github邮箱&quot;</span> <br># 示例 <br><br>ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;1355165054@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>第一次生成的话按下回车4次</p><p>不是第一次遇生成到选择选 y 就行其余操作回车</p><p>密钥生成到下面文件夹下了，就是选中这个</p><p><img src="/../images/image-20220430232637964.png" alt="image-20220430232637964"></p><h3 id="7-6-将密钥添加到github"><a href="#7-6-将密钥添加到github" class="headerlink" title="7.6 将密钥添加到github"></a>7.6 将密钥添加到github</h3><p>打开这个id_rsa.pub文件 复制所有文本</p><p>然后打开GitHub 点击setting</p><p><img src="/../images/image-20220430232848401.png" alt="image-20220430232848401"></p><p><img src="/../images/image-20220430232950777.png" alt="image-20220430232950777"></p><p>新加一个</p><p><img src="/../images/image-20220430233032060.png" alt="image-20220430233032060"></p><p>在命令行窗口测试能否连接github</p><p><code>ssh -T git@github.com</code></p><p><img src="/../images/image-20220430233153083.png" alt="image-20220430233153083"></p><h3 id="7-7-最后一步，上传"><a href="#7-7-最后一步，上传" class="headerlink" title="7.7 最后一步，上传"></a>7.7 最后一步，上传</h3><p>命令 </p><p><code>hexo d</code></p><p><strong>可能</strong>会出现这个界面，输入用户名密码，但是我没遇到过</p><p><img src="/../images/image-20220430233338610.png" alt="image-20220430233338610"></p><p>过一段时间</p><p>在浏览器上输入</p><p><code>用户名.gitbun.io</code></p><p><img src="/../images/image-20220430233520355.png" alt="image-20220430233520355"></p><p>最后一步遇到很多问题，但是基本上是没按照教程走或者和教程操作得不同导致的。</p><p>当然还有个很大的问题是我去学习其他教程，<strong>但是不合当前版本，无法搭建成功</strong></p><p>故此列出时间望大家参考此攻略是否还适用</p><p>2022&#x2F;04&#x2F;30  23:37</p><p>还有20分钟劳动节，卷死他们！！</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++题目练习（部分）</title>
    <link href="/2022/04/30/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    <url>/2022/04/30/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h1><h2 id="1-大数乘法"><a href="#1-大数乘法" class="headerlink" title="1.大数乘法"></a>1.大数乘法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//大数相乘</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//构造传入参数</span><br><span class="hljs-built_in">Solution</span>(string num1, string num2) &#123;<br><span class="hljs-keyword">this</span>-&gt;num1 = num1;<br><span class="hljs-keyword">this</span>-&gt;num2 = num2;<br>&#125;<br><br><span class="hljs-comment">//实现相乘、进位</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">C</span>(A.<span class="hljs-built_in">size</span>() + B.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j++) &#123;<br>C[i + j] += A[i] * B[j];<br>&#125;<br>&#125;<br><span class="hljs-comment">//进位 </span><br><span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i++) &#123;<br>t += C[i];<br>C[i] = t % <span class="hljs-number">10</span>;<br>t /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-comment">//去掉尾部的0</span><br><span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-keyword">return</span> C;<br><br>&#125;<br><br><span class="hljs-comment">//尾插2个数据，先插个位</span><br><span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;A, B;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>A.<span class="hljs-built_in">push_back</span>(num1[i] - <span class="hljs-number">48</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>B.<span class="hljs-built_in">push_back</span>(num2[i] - <span class="hljs-number">48</span>);<br>&#125;<br><span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, B);<br><span class="hljs-comment">//将结果放入res</span><br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>res += C[i] + <span class="hljs-number">48</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//析构输出结果</span><br>~<span class="hljs-built_in">Solution</span>() &#123;<br>string res = <span class="hljs-built_in">multiply</span>(<span class="hljs-keyword">this</span>-&gt;num1, <span class="hljs-keyword">this</span>-&gt;num2);<br>cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>string num1;<br>string num2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>string num1 = <span class="hljs-string">&quot;5555554666666666666666666666666666666664444444444444444445648745&quot;</span>;<br>string num2 = <span class="hljs-string">&quot;5555554666666666666666666666666666666664444444444444444445648745&quot;</span>;<br><span class="hljs-function">Solution <span class="hljs-title">A</span><span class="hljs-params">(num1, num2)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL学习笔记（部分）</title>
    <link href="/2022/04/30/%E6%B3%9B%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/30/%E6%B3%9B%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-模板"><a href="#1-模板" class="headerlink" title="1.模板"></a>1.模板</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><ol><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用不是万能的</li></ol><h2 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h2><ol><li>C++另一种思想为泛型思想，主要利用技术就是模板</li><li>C++提供两个模板机制：函数模板和类模板</li></ol><h3 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1"></a>1.2.1</h3><p>函数模板的作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟类型来代表</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>函数声明或定义<br></code></pre></td></tr></table></figure><p>template  声明创建模板</p><p>typename   表明其后面的符号是一种数据类型，可以用class代替</p><p>T    通用的数据类型，名称可以替换，通常为大写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">(T&amp; a,T&amp; b)</span> </span>&#123;<br><span class="hljs-type">double</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">11</span>;<br><span class="hljs-comment">//利用函数模板交换</span><br><span class="hljs-comment">//自动类型推导</span><br><span class="hljs-comment">//myswap(a, b);</span><br><span class="hljs-comment">//显示指定类型</span><br><span class="hljs-built_in">myswap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-2-类模板成员函数的调用时机"><a href="#1-2-2-类模板成员函数的调用时机" class="headerlink" title="1.2.2 类模板成员函数的调用时机"></a>1.2.2 类模板成员函数的调用时机</h3><p> 创建对象时调用类模板的成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person1</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson1</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person1&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson2</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person2&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>T obj;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>obj.<span class="hljs-built_in">showPerson1</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>obj.<span class="hljs-built_in">showPerson2</span>();<br>&#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>MyClass&lt;Person1&gt;p1;<br>p<span class="hljs-number">1.f</span>unc1();<br><span class="hljs-comment">//p1.func2(); //只创建了Person1，没有Person2</span><br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2-STL"><a href="#2-STL" class="headerlink" title="2.STL"></a>2.STL</h1><h2 id="2-1-STL基本概念"><a href="#2-1-STL基本概念" class="headerlink" title="2.1 STL基本概念"></a>2.1 STL基本概念</h2><h2 id="2-2-vector存放内置数据类型"><a href="#2-2-vector存放内置数据类型" class="headerlink" title="2.2 vector存放内置数据类型"></a>2.2 vector存放内置数据类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>cout &lt;&lt; val &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//创建容器，数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-comment">//插入数据</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><span class="hljs-comment">//通过迭代器查看数据的首地址和最后以为数据后面一位的地址</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itBegin = v.<span class="hljs-built_in">begin</span>();<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = v.<span class="hljs-built_in">end</span>();<br><span class="hljs-comment">//第一种遍历</span><br><span class="hljs-keyword">while</span> (itBegin!= itEnd) &#123;<br>cout &lt;&lt; *itBegin &lt;&lt; endl;<br>itBegin++;<br>&#125;<br><br><span class="hljs-comment">//第二种遍历</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//第三种遍历</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-vector-存放自定义数据类型"><a href="#2-3-vector-存放自定义数据类型" class="headerlink" title="2.3 vector 存放自定义数据类型"></a>2.3 vector 存放自定义数据类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_name = name;<br><span class="hljs-keyword">this</span>-&gt;m_age = age;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>string m_name;<br><span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(Person p)</span> </span>&#123;<br>cout &lt;&lt; p.m_name &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; p.m_age &lt;&lt; endl;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//创建容器，数组</span><br>vector&lt;Person&gt;v;<br><span class="hljs-comment">//插入数据</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">4</span>)</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br><span class="hljs-comment">//通过迭代器查看数据的首地址和最后以为数据后面一位的地址</span><br>vector&lt;Person&gt;::iterator itBegin = v.<span class="hljs-built_in">begin</span>();<br>vector&lt;Person&gt;::iterator itEnd = v.<span class="hljs-built_in">end</span>();<br><span class="hljs-comment">//第一种遍历</span><br><span class="hljs-comment">//while (itBegin!= itEnd) &#123;</span><br><span class="hljs-comment">//cout &lt;&lt; itBegin-&gt;m_name&lt;&lt;&quot;  &quot;&lt;&lt;itBegin-&gt;m_age&lt;&lt; endl;</span><br><span class="hljs-comment">//itBegin++;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第二种遍历</span><br><span class="hljs-comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="hljs-comment">//cout &lt;&lt; (*it).m_name&lt;&lt;&quot;   &quot;&lt;&lt;(*it).m_age &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第三种遍历</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-容器嵌套容器"><a href="#2-4-容器嵌套容器" class="headerlink" title="2.4 容器嵌套容器"></a>2.4 容器嵌套容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//创建大容器，存数组的数组</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;v;<br><span class="hljs-comment">//创建小容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>vector&lt;<span class="hljs-type">int</span>&gt;v3;<br>vector&lt;<span class="hljs-type">int</span>&gt;v4;<br>    <span class="hljs-comment">//小容器插入数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>v<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">2</span>);<br>v<span class="hljs-number">3.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">3</span>);<br>v<span class="hljs-number">4.</span><span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//小容器放入大容器里</span><br>v.<span class="hljs-built_in">push_back</span>(v1);<br>v.<span class="hljs-built_in">push_back</span>(v2);<br>v.<span class="hljs-built_in">push_back</span>(v3);<br>v.<span class="hljs-built_in">push_back</span>(v4);<br><span class="hljs-comment">//输出数据</span><br><span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it2 = (*it).<span class="hljs-built_in">begin</span>(); it2 != (*it).<span class="hljs-built_in">end</span>(); it2++) &#123;<br>cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-string容器"><a href="#3-string容器" class="headerlink" title="3.string容器"></a>3.string容器</h1><h2 id="3-1-string容器基本概念"><a href="#3-1-string容器基本概念" class="headerlink" title="3.1 string容器基本概念"></a>3.1 string容器基本概念</h2><p>本质：</p><p>  string是C++风格的字符串，而string本质上时一个类</p><p>string  和char* 的区别：</p><ol><li>char*是一个指针</li><li>string是一个类，类部封装了char*，管理这个字符串，是char*型的容器</li></ol><p>特点：</p><p>string内部封装了很多方法</p><p>例如查找find，拷贝copy，删除delete，替换replace，插入insert</p><p>string管理char*分配的内存，不用担心赋值越界和取值越界等，由内部进行负责</p><h2 id="3-2-string的构造原型"><a href="#3-2-string的构造原型" class="headerlink" title="3.2 string的构造原型"></a>3.2 string的构造原型</h2><p>构造函数原型：</p><p>string();</p><p>string(const char* s);</p><p>string(const string&amp; str);</p><p>string(int n, char c);</p><h2 id="3-3-string的赋值操作"><a href="#3-3-string的赋值操作" class="headerlink" title="3.3 string的赋值操作"></a>3.3 string的赋值操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>string str1;<br>str1 = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>string str2;<br>str2 = str1;<br><br>string str3;<br>str3 = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>string str4;<br>str<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello c++&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str4&quot;</span>&lt;&lt; str4 &lt;&lt; endl;<br><br>string str5;<br>str<span class="hljs-number">5.</span><span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello c++&quot;</span>, <span class="hljs-number">5</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str5&quot;</span> &lt;&lt; str5 &lt;&lt; endl;<br><br>string str6;<br>str<span class="hljs-number">6.</span><span class="hljs-built_in">assign</span>(str5);<br>cout &lt;&lt; <span class="hljs-string">&quot;str6&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>string str7;<br>str<span class="hljs-number">7.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;x&#x27;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str7&quot;</span> &lt;&lt; str7 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般用operator&#x3D;赋值</p><h2 id="3-4-string字符串拼接"><a href="#3-4-string字符串拼接" class="headerlink" title="3.4 string字符串拼接"></a>3.4 string字符串拼接</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>string str1 = <span class="hljs-string">&quot;我&quot;</span>;<br>str1 += <span class="hljs-string">&quot;爱玩游戏&quot;</span>;<br><br>str1 += <span class="hljs-string">&#x27;:&#x27;</span>;<br><br>string str2 = <span class="hljs-string">&quot;LOL DNF&quot;</span>;<br>string str3 = <span class="hljs-string">&quot;I&quot;</span>;<br>str<span class="hljs-number">3.</span><span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;love&quot;</span>);<br>str<span class="hljs-number">3.</span><span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; game aaasdf&quot;</span>, <span class="hljs-number">5</span>);<br>str<span class="hljs-number">3.</span><span class="hljs-built_in">append</span>(str2, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>cout &lt;&lt; str3 &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-字符串查找和替换"><a href="#3-5-字符串查找和替换" class="headerlink" title="3.5 字符串查找和替换"></a>3.5 字符串查找和替换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//查找</span><br>string str1 = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;<br><span class="hljs-type">int</span> pos = str<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&quot;kl&quot;</span>);<br><span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; pos &lt;&lt; endl;<br>&#125;<br>pos = str<span class="hljs-number">1.</span><span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;kl&quot;</span>);<br>cout &lt;&lt; pos &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//替换</span><br>string str1 = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str<span class="hljs-number">1.</span><span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1111&quot;</span>);<span class="hljs-comment">//下标开始，替换几个，替换为什么</span><br>cout &lt;&lt; str1 &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-字符串比较"><a href="#3-6-字符串比较" class="headerlink" title="3.6 字符串比较"></a>3.6 字符串比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>string str1 = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>string str2 = <span class="hljs-string">&quot;aacdefg&quot;</span>;<br><span class="hljs-type">int</span> ret = str<span class="hljs-number">1.</span><span class="hljs-built_in">compare</span>(str2);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1 = str2&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1 &gt; str2&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1 &lt; str2&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般只用于比较字符串是否相同</p><h2 id="3-7-string字符存取"><a href="#3-7-string字符存取" class="headerlink" title="3.7 string字符存取"></a>3.7 string字符存取</h2><p>两种方式：</p><ol><li>通过[]存取</li><li>通过at存取</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>string str1 = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++) &#123;<br>cout &lt;&lt; str1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++) &#123;<br>cout &lt;&lt; str<span class="hljs-number">1.</span><span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//字符修改</span><br>str1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>str<span class="hljs-number">1.</span><span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;x&#x27;</span>;<br>cout &lt;&lt; str1 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-8-string插入和删除"><a href="#3-8-string插入和删除" class="headerlink" title="3.8 string插入和删除"></a>3.8 string插入和删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>str<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;222&quot;</span>);<span class="hljs-comment">//2号位置开始插入</span><br>cout &lt;&lt; str1 &lt;&lt; endl;<br><br>str<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//从1号位置开始3个字符</span><br>cout &lt;&lt; str1 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-9-string-子串"><a href="#3-9-string-子串" class="headerlink" title="3.9 string 子串"></a>3.9 string 子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>string str1 = <span class="hljs-string">&quot;asfdgaasdgasdg&quot;</span>;<br>string subStr = str<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//下标1开始，3个字符</span><br>cout &lt;&lt; <span class="hljs-string">&quot;substr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;<br><br>string str2 = <span class="hljs-string">&quot;zhangsan@163.com&quot;</span>;<br><span class="hljs-type">int</span> pos = str<span class="hljs-number">2.f</span>ind(<span class="hljs-string">&#x27;@&#x27;</span>);<br>string response = str<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,pos);<br>cout &lt;&lt; response &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-verctor容器"><a href="#4-verctor容器" class="headerlink" title="4.verctor容器"></a>4.verctor容器</h1><h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><p><strong>功能</strong>：</p><p>​    vector数据结构和数组非常相似，也成为单端数组</p><p><strong>vector与普通数组区别</strong></p><p>​    不同之处在于数组是静态空间，vector是动态空间</p><p><strong>动态扩展</strong></p><p>​并不是在原空间之后续接新空间，而是找更大的内存空间，然后将元数据拷贝新空间，释放原空间</p><h2 id="4-2-构造函数"><a href="#4-2-构造函数" class="headerlink" title="4.2 构造函数"></a>4.2 构造函数</h2><p>vector<T>v</p><p>vector(v.bengin(), v.end())</p><p>vector(b, elem)</p><p>vector(const vector &amp; vec)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it &lt; v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">myPrint</span>(v1);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v2</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">myPrint</span>(v2);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v3</span>(<span class="hljs-number">9</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">myPrint</span>(v3);<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v4</span>(v3);<br><span class="hljs-built_in">myPrint</span>(v4);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-vector赋值"><a href="#4-3-vector赋值" class="headerlink" title="4.3  vector赋值"></a>4.3  vector赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it &lt; v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">myPrint</span>(v1);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>v2 = v1;<br><span class="hljs-built_in">myPrint</span>(v2);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v3;<br>v<span class="hljs-number">3.</span><span class="hljs-built_in">assign</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">myPrint</span>(v3);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v4;<br>v<span class="hljs-number">4.</span><span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">55</span>);<br><span class="hljs-built_in">myPrint</span>(v4);<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-vector容量和大小"><a href="#4-4-vector容量和大小" class="headerlink" title="4.4 vector容量和大小"></a>4.4 vector容量和大小</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it &lt; v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">myPrint</span>(v1);<br><br><span class="hljs-keyword">if</span> (v<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的容量为：&quot;</span>&lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt;endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的大小为：&quot;</span>&lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt;endl;<br>&#125;<br><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//指定大小为15，不足用10填充</span><br><span class="hljs-built_in">myPrint</span>(v1);<br><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">30</span>);<span class="hljs-comment">//指定大小为30，不足 30 默认  用 0 填充</span><br><span class="hljs-built_in">myPrint</span>(v1);<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-vector插入和删除"><a href="#4-5-vector插入和删除" class="headerlink" title="4.5 vector插入和删除"></a>4.5 vector插入和删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it &lt; v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-comment">//尾插10个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">myPrint</span>(v1);<br><br><span class="hljs-comment">//尾删</span><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">myPrint</span>(v1);<br><span class="hljs-comment">//插入</span><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">myPrint</span>(v1);<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">myPrint</span>(v1);<br><br><span class="hljs-comment">//删除</span><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">myPrint</span>(v1);<br><br><span class="hljs-comment">//清空</span><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">clear</span>();<br><br><span class="hljs-built_in">myPrint</span>(v1);<br>cout &lt;&lt; <span class="hljs-string">&quot;删除成功&quot;</span> &lt;&lt; endl;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6-vector-数据存取"><a href="#4-6-vector-数据存取" class="headerlink" title="4.6 vector 数据存取"></a>4.6 vector 数据存取</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it &lt; v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-comment">//尾插10个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">myPrint</span>(v1);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++) &#123;<br>cout &lt;&lt; v1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(); i++) &#123;<br>cout &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的第一个元素为：&quot;</span> &lt;&lt; v<span class="hljs-number">1.f</span>ront() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的最后一个元素为：&quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-7-vector-互换容器"><a href="#4-7-vector-互换容器" class="headerlink" title="4.7 vector 互换容器"></a>4.7 vector 互换容器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it &lt; v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-comment">//尾插10个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">myPrint</span>(v1);<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-comment">//尾插10个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>v<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">myPrint</span>(v2);<br><span class="hljs-comment">//互换容器</span><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(v2);<br><span class="hljs-built_in">myPrint</span>(v1);<br><span class="hljs-built_in">myPrint</span>(v2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的容量为&quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的大小为&quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的容量为&quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的大小为&quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//通过匿名对象收缩内存</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v1).<span class="hljs-built_in">swap</span>(v1);<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的容量为&quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的大小为&quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-8-vector-预留空间"><a href="#4-8-vector-预留空间" class="headerlink" title="4.8 vector 预留空间"></a>4.8 vector 预留空间</h2><p><strong>功能：</strong></p><p><strong>减少vector在动态扩展容量时的拓展次数</strong></p><p>函数原型</p><p>reserve(int len);&#x2F;&#x2F; 预留len个长度空间，预留位置不初始化，元素不可访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it &lt; v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    <span class="hljs-comment">//预留空间</span><br>v<span class="hljs-number">1.</span><span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br><br><span class="hljs-keyword">if</span> (p != &amp;v1[<span class="hljs-number">0</span>]) &#123;   <span class="hljs-comment">//开辟一次内存，首地址就会变化，用这个来验证是否开辟新的内存</span><br>p = &amp;v1[<span class="hljs-number">0</span>];<br>num++;<br>&#125;<br>&#125;<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-deque容器"><a href="#5-deque容器" class="headerlink" title="5.deque容器"></a>5.deque容器</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>双端数组  可以对头部插入或者删除</p><p>与vector容器区别</p><ol><li>vector对于头部的插入和删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度比vector快</li><li>vector访问元素的速度会比deque快，这和两者内部实现有关</li></ol><p>deque内部工作原理：</p><p>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护时每个缓冲区的地址，使得deque时像一片连续的内存空间</p><p>deque容器的迭代器也支持随机访问</p><h2 id="5-2-构造函数"><a href="#5-2-构造函数" class="headerlink" title="5.2 构造函数"></a>5.2 构造函数</h2><p>deque<T>v</p><p>deque(v.bengin(), v.end())</p><p>deque(b, elem)</p><p>deque(const vector &amp; vec)</p><h2 id="5-3-deque容器的赋值操作"><a href="#5-3-deque容器的赋值操作" class="headerlink" title="5.3 deque容器的赋值操作"></a>5.3 deque容器的赋值操作</h2><p>deque&amp; operator&#x3D;(const deque&amp; deq);</p><p>assign(d.begin(), d.end());</p><p>assign(n, elem);</p><h2 id="5-4-deque容器大小操作"><a href="#5-4-deque容器大小操作" class="headerlink" title="5.4 deque容器大小操作"></a>5.4 deque容器大小操作</h2><p>deque.empty(){};&#x2F;&#x2F;判断容器是否为空</p><p>deque.size();&#x2F;&#x2F;返回容器的个数</p><p>deque.resize();&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则默认值填充新位置</p><p>​  &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</p><p>deque.resize(num,elem);  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置</p><p>​  &#x2F;&#x2F;若容器变短，则末尾超出容器长度的元素被删除</p><h2 id="5-5-deque插入和删除"><a href="#5-5-deque插入和删除" class="headerlink" title="5.5 deque插入和删除"></a>5.5 deque插入和删除</h2><p>两端插入操作：</p><p>push_back(elem);&#x2F;&#x2F;尾插elem</p><p>push_front(elem);&#x2F;&#x2F;头插elem</p><p>pop_back();&#x2F;&#x2F;尾删</p><p>pop_front();&#x2F;&#x2F;头删</p><p>指定位置操作：</p><p>insert(pos, elem);&#x2F;&#x2F;pos位置插入elem的拷贝，返回新元素的位置             pos：迭代器位置</p><p>insert(pos, n, elem);&#x2F;&#x2F;pos位置插入n和elem，无返回值</p><p>insert(pos, beg, end);&#x2F;&#x2F;pos位置插一个[begin,end)区间，无返回值</p><p>clear();&#x2F;&#x2F;清空容器中的所有数据</p><p>erase(beg, end);&#x2F;&#x2F;删除[begin,end)区间的数据，返回下一个数据的位置</p><p>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置</p><h2 id="5-6-deque数据存取"><a href="#5-6-deque数据存取" class="headerlink" title="5.6 deque数据存取"></a>5.6 deque数据存取</h2><p>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</p><p>operator[];&#x2F;&#x2F;返回索引idx所指的数据</p><p>front();       &#x2F;&#x2F;返回容器中第一个数据元素</p><p>back();       &#x2F;&#x2F;返回容器中最后一个数据元素</p><h2 id="5-7-deque排序"><a href="#5-7-deque排序" class="headerlink" title="5.7 deque排序"></a>5.7 deque排序</h2><p>sort(iterator beg, iterator end) &#x2F;&#x2F;对beg和end区间内元素进行排序         升序</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象学习</title>
    <link href="/2022/04/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/04/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>C++面向对象三大特性：封装，继承，多态</p><p>C++认为万事万物都皆为对象，对象上有其属性和行为</p><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1 封装"></a>1 封装</h2><h3 id="1-1封装的意义"><a href="#1-1封装的意义" class="headerlink" title="1.1封装的意义"></a>1.1封装的意义</h3><p>将属性和行为作为一个整体，表现生活中的事物</p><p>将属性和行为加以权限控制</p><p>设计一个圆类，求圆的周长</p><p>语法： class 类名{};</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br>    <span class="hljs-comment">//访问权限</span><br>    <span class="hljs-comment">//公共权限</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//类中的属性和行为 我们统一称为成员</span><br>    <span class="hljs-comment">//属性 成员属性 成员变量</span><br>    <span class="hljs-comment">//行为 成员函数 成员方法</span><br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-comment">//周长</span><br>    <span class="hljs-type">int</span> m_r;<br>    <span class="hljs-comment">//行为</span><br>    <span class="hljs-comment">//获取圆的周长</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * PI *m_r;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//通过圆类 创建具体化的圆（对象）</span><br>    <span class="hljs-comment">//实例化 （通过一个类 创建一个对象的过程）</span><br>    Circle c1;<br>    <span class="hljs-comment">//给圆对象的属性赋值</span><br>    c<span class="hljs-number">1.</span>m_r = <span class="hljs-number">10</span>;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;圆的周长为： &quot;</span>&lt;&lt; c<span class="hljs-number">1.</span><span class="hljs-built_in">calculateZC</span>()&lt;&lt;endl;<br>        <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设计一个学生类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//类中的属性和行为 我们统一称为成员</span><br>    <span class="hljs-comment">//属性 成员属性 成员变量</span><br>    <span class="hljs-comment">//行为 成员函数 成员方法</span><br>    string m_name;<br>    <span class="hljs-type">int</span> m_id;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showStudent</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;m_id&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span></span>&#123;<br>        m_name = name;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Student s1;<br>    s<span class="hljs-number">1.</span>m_name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;lisi&quot;</span>);<br>    s<span class="hljs-number">1.</span>m_id = <span class="hljs-number">1</span>;<br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">showStudent</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-访问权限"><a href="#1-2-访问权限" class="headerlink" title="1.2 访问权限"></a>1.2 访问权限</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//访问权限</span><br><span class="hljs-comment">//三种</span><br><span class="hljs-comment">//公共权限 public     成员 类内可以访问 类外可以访问</span><br><span class="hljs-comment">//保护权限 protected  成员 类内可以访问 类外不可以访问    儿子可以访问保护内容</span><br><span class="hljs-comment">//私有权限 private    成员 类内可以访问 类外不可以访问    儿子不可以访问私有</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//公共权限</span><br>    string m_name; <br>    <br><span class="hljs-keyword">protected</span>: <br>    <span class="hljs-comment">//保护权限</span><br>    string m_car;<br>    <br>    <span class="hljs-comment">//私有权限</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_password;<br>    <br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        m_name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>        m_car = <span class="hljs-string">&quot;tuolaji&quot;</span>;<br>        m_password = <span class="hljs-number">123456</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person p1;<br>    <br>    p<span class="hljs-number">1.</span>m_name = <span class="hljs-string">&quot;lisi&quot;</span>;<br>    <span class="hljs-comment">//p1.m_car = &quot;benchi&quot;;//访问不到</span><br>    <span class="hljs-comment">//p1.m_password = 123;//访问不到</span><br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-struct-和-class-的区别"><a href="#1-3-struct-和-class-的区别" class="headerlink" title="1.3 struct 和 class 的区别"></a>1.3 struct 和 class 的区别</h3><p>唯一区别就是访问权限不同</p><p>struct默认为公共</p><p>class 默认为私有</p><h3 id="1-4-成员属性设置为私有"><a href="#1-4-成员属性设置为私有" class="headerlink" title="1.4 成员属性设置为私有"></a>1.4 成员属性设置为私有</h3><p>1、可以自己控制读写</p><p>2、对于写可以检测数据的有效性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//设计人类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置姓名  写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>        m_name = name;<br>    &#125;<br>    <span class="hljs-comment">//显示姓名  读</span><br>    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_name;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    string m_name;<br><br>    <span class="hljs-type">int</span> m_age;<br><br>    string m_lover;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person s1;<br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>    cout &lt;&lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">getName</span>() &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例：点和圆的关系"><a href="#案例：点和圆的关系" class="headerlink" title="案例：点和圆的关系"></a>案例：点和圆的关系</h4><p>设计一个点类（Point），设计一个圆类(Circle)，计算点和圆的关系</p><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt; iostream &gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;point.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">relation</span><span class="hljs-params">(Circle&amp; c, Point&amp; p)</span> </span>&#123;<br>    <span class="hljs-type">double</span> pc_dist = <span class="hljs-number">0</span>;<br>    pc_dist = (c.<span class="hljs-built_in">getCenter</span>().<span class="hljs-built_in">getX</span>() - p.<span class="hljs-built_in">getX</span>()) * (c.<span class="hljs-built_in">getCenter</span>().<span class="hljs-built_in">getX</span>() - p.<span class="hljs-built_in">getX</span>()) <br>            + (c.<span class="hljs-built_in">getCenter</span>().<span class="hljs-built_in">getY</span>() - p.<span class="hljs-built_in">getY</span>()) * (c.<span class="hljs-built_in">getCenter</span>().<span class="hljs-built_in">getY</span>() - p.<span class="hljs-built_in">getY</span>());<br><br>    <span class="hljs-keyword">if</span> (pc_dist &lt; (c.<span class="hljs-built_in">getR</span>() * c.<span class="hljs-built_in">getR</span>())) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;在圆内&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pc_dist == (c.<span class="hljs-built_in">getR</span>() * c.<span class="hljs-built_in">getR</span>())) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;在圆上&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;在圆外&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Circle c;<br>    Point p, pc;<br>    <span class="hljs-type">double</span> c_x, c_y, c_r, p_x, p_y;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入圆的横坐标：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; c_x;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入圆的纵坐标：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; c_y;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入圆的半径：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; c_r;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入点的横坐标：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; p_x;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入点的横坐标：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; p_y;<br>    <span class="hljs-comment">//给点赋值</span><br>    p.<span class="hljs-built_in">setX</span>(p_x);<br>    p.<span class="hljs-built_in">setY</span>(p_y);<br>    <span class="hljs-comment">//给圆心赋值</span><br>    pc.<span class="hljs-built_in">setX</span>(c_x);<br>    pc.<span class="hljs-built_in">setY</span>(c_y);<br>    <span class="hljs-comment">//将圆心属性赋给圆</span><br>    c.<span class="hljs-built_in">setCenter</span>(pc);<br>    c.<span class="hljs-built_in">setCenter</span>(pc);<br>    <span class="hljs-comment">//赋值半径</span><br>    c.<span class="hljs-built_in">setR</span>(c_r);<br><br>    <span class="hljs-built_in">relation</span>(c, p);<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>point.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置坐标</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span></span>;<br>    <span class="hljs-comment">//获取坐标</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> p_x;<br>    <span class="hljs-type">double</span> p_y;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>point.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;point.h&quot;</span></span><br><br><span class="hljs-comment">//设置坐标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Point::setX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    p_x = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Point::setY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> </span>&#123;<br>    p_x = y;<br>&#125;<br><span class="hljs-comment">//获取坐标</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Point::getX</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p_x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Point::getY</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p_y;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>circle.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;point.h&quot;</span></span><br><span class="hljs-comment">//设计圆类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置圆心</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCenter</span><span class="hljs-params">(Point center)</span></span>;<br>    <span class="hljs-comment">//获取圆心</span><br>    <span class="hljs-function">Point <span class="hljs-title">getCenter</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//设置半径</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setR</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span></span>;<br>    <span class="hljs-comment">//获取半径</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getR</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> c_r;<br>    Point m_center;<br>&#125;;<br></code></pre></td></tr></table></figure><p>circle.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br><span class="hljs-comment">//设置圆心</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Circle::setCenter</span><span class="hljs-params">(Point center)</span> </span>&#123;<br>    m_center = center;<br>&#125;<br><span class="hljs-comment">//获取圆心</span><br><span class="hljs-function">Point <span class="hljs-title">Circle::getCenter</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_center;<br>&#125;<br><span class="hljs-comment">//设置半径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Circle::setR</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123;<br>    c_r = r;<br>&#125;<br><span class="hljs-comment">//获取半径</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Circle::getR</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c_r;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-对象初始化和清理"><a href="#2-对象初始化和清理" class="headerlink" title="2 对象初始化和清理"></a>2 对象初始化和清理</h2><h3 id="2-1-构造函数和析构函数"><a href="#2-1-构造函数和析构函数" class="headerlink" title="2.1 构造函数和析构函数"></a>2.1 构造函数和析构函数</h3><p>对象的初始化和清理是两个非常重要的安全问题</p><ol><li>一个对象或者变量没有初始状态，对其使用后果是未知</li><li>同样的使用完一个对象或者变量，没有及时清理，也会造成一定的安全问题</li></ol><p>C++利用构造函数和析构函数解决以上问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要求我们做的事情，如果我们不强制提供构造和析构，编译器会提供编译器的构造函数和析构函数是空实现。</p><p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。</p><p>析构函数：主要作用于在对象销毁前系统自动调用，执行一些清理工作。</p><p>构造函数语法：  类名（）{}</p><ol><li>构造函数没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次</li></ol><p>析构函数语法： ~类名（）{}</p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称和类名相同，在名称前加上~</li><li>析构函数不可以有参数，因此不会发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;构造函数&quot;</span>&lt;&lt;endl;;<br>    &#125;    <br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;     <span class="hljs-comment">//代码在堆区，test01执行完后释放这个对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    Person p;<span class="hljs-comment">//main执行完了后执行析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-构造函数的分类和调用"><a href="#2-2-构造函数的分类和调用" class="headerlink" title="2.2 构造函数的分类和调用"></a>2.2 构造函数的分类和调用</h3><p>两种分类方式：</p><p>  按参数分为：有参构造和无参构造（默认构造）</p><p>  按类型分为：普通构造和拷贝构造</p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;无参构造函数&quot;</span>&lt;&lt;endl;<br>    &#125; <br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a)&#123;<br>        age = a;<br>        cout&lt;&lt;<span class="hljs-string">&quot;有参构造函数&quot;</span>&lt;&lt;endl;<br>    &#125; <br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)&#123;<br>        age = p.age;<br>        cout&lt;&lt; <span class="hljs-string">&quot;拷贝调用&quot;</span> &lt;&lt; endl;<br>            <br>    &#125; <br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1.括号法</span><br>    Person p1;<span class="hljs-comment">//调用无参</span><br>    <span class="hljs-function">Person <span class="hljs-title">P2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//调用有参</span><br>    <span class="hljs-function">Person <span class="hljs-title">P3</span><span class="hljs-params">(P2)</span></span>;<span class="hljs-comment">//拷贝调用</span><br>    <br>    <span class="hljs-comment">//注意事项</span><br>    <span class="hljs-comment">//调用默认构造参数时，不要加（）</span><br>    <span class="hljs-comment">//Person P1();//编译器以为是函数的声明</span><br>    <br>    <span class="hljs-comment">//2.显示法</span><br>    person P1;<span class="hljs-comment">//默认（无参）构造</span><br>    Person P2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//有参构造</span><br>    Person P3 = <span class="hljs-built_in">Person</span>(P2);<span class="hljs-comment">//拷贝构造</span><br>    <br>    <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">//匿名对象   特点：当前执行结束后马上析构</span><br>    <br>    <span class="hljs-comment">//注意事项2</span><br>    <span class="hljs-comment">//不要利用拷贝构造函数 初始化匿名对象</span><br>    <span class="hljs-comment">//Person(P3);  //编译器会将Person(P3) = Person P3, 将其实例化</span><br>    <br>    <span class="hljs-comment">//3.隐式转换法</span><br>    Person P4 = <span class="hljs-number">10</span>; <span class="hljs-comment">//相当于 写了 Person P4 = Person(10);</span><br>    Person P5 = P4; <span class="hljs-comment">//拷贝构造</span><br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-type">int</span> a;<br>    Person p;<span class="hljs-comment">//main执行完了后执行析构函数</span><br>    <br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-拷贝构造函数调用时机"><a href="#2-3-拷贝构造函数调用时机" class="headerlink" title="2.3 拷贝构造函数调用时机"></a>2.3 拷贝构造函数调用时机</h3><p>C++中拷贝构造函数调用时机通常由三种情况</p><ol><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person无参构造函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person有参构造函数调用&quot;</span>&lt;&lt;endl;<br>        m_age = age;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person拷贝构造函数调用&quot;</span> &lt;&lt; endl;<br>        m_age = p.m_age;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-comment">//使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">P1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">P2</span><span class="hljs-params">(P1)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//值传递的方式给函数参数传值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person P)</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    Person P;<br>    <span class="hljs-built_in">doWork</span>(P);<br>&#125;<br><br><span class="hljs-comment">//以值方式返回局部对象</span><br><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span> </span>&#123;<br>    Person P1;<br>    <span class="hljs-keyword">return</span> P1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    Person P = <span class="hljs-built_in">doWork2</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test03</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="2-4-构造函数的调用规则"><a href="#2-4-构造函数的调用规则" class="headerlink" title="2.4 构造函数的调用规则"></a>2.4 构造函数的调用规则</h3><p>默认情况下，C++编译器至善给一个类添加3个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝函数，对属性进行值拷贝</li></ol><p>构造函数调用规则如下：</p><ol><li><p>如果用户定义了有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，C++不会提供其他构造函数</p></li></ol><h3 id="2-5-深拷贝和浅拷贝"><a href="#2-5-深拷贝和浅拷贝" class="headerlink" title="2.5 深拷贝和浅拷贝"></a>2.5 深拷贝和浅拷贝</h3><p>浅拷贝：简单的赋值拷贝操作</p><p>​            问题：空间重复释放</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p>​利用深拷贝解决问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;person的默认构造函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> Height) &#123;<br>        m_age = age;<br>        m_Height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(Height);<br>        cout &lt;&lt; <span class="hljs-string">&quot;person的有参构造函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;person的拷贝构造函数调用&quot;</span> &lt;&lt; endl;<br>        m_age = p.m_age;<br>        <span class="hljs-comment">//m_Height = p.m_Height; 编译器默认实现的代码</span><br>        m_Height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_Height);<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        <span class="hljs-keyword">if</span> (m_Height != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_Height;<br>            m_Height = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;person的析构函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_age;<br>    <span class="hljs-type">int</span>* m_Height;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>,<span class="hljs-number">160</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄为： &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>m_age&lt;&lt; <span class="hljs-string">&quot;  身高为：&quot;</span> &lt;&lt; *p<span class="hljs-number">1.</span>m_Height &lt;&lt; endl;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>m_age &lt;&lt; <span class="hljs-string">&quot;  身高为：&quot;</span> &lt;&lt; *p<span class="hljs-number">2.</span>m_Height &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>如果属性由在堆区开辟的操作，一定要自己进行深拷贝防止浅拷贝带来的问题</p><h3 id="2-6-初始化列表"><a href="#2-6-初始化列表" class="headerlink" title="2.6 初始化列表"></a>2.6 初始化列表</h3><p>C++提供了初始化列表语法，用来初始化属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">语法： <br>    构造函数（）：属性<span class="hljs-number">1</span>（值<span class="hljs-number">1</span>），属性<span class="hljs-number">2</span>（值<span class="hljs-number">2</span>）...&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//传统初始化操作</span><br>    <span class="hljs-comment">//Person(int a , int b , int c)&#123;</span><br>    <span class="hljs-comment">//    m_a = a;</span><br>    <span class="hljs-comment">//    m_b = b;</span><br>    <span class="hljs-comment">//    m_c = c;</span><br>        <br>    &#125;<br>    <span class="hljs-comment">//初始化列表初始化属性</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c):<span class="hljs-built_in">m_A</span>(a),<span class="hljs-built_in">m_b</span>(b),<span class="hljs-built_in">m_c</span>(c)&#123;<br>        <br>    &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_a;<br>    <span class="hljs-type">int</span> m_b;<br>    <span class="hljs-type">int</span> m_c;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;m_a&quot;</span>&lt;&lt;p.m_a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;m_b&quot;</span>&lt;&lt;p.m_b&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;m_c&quot;</span>&lt;&lt;p.m_c&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-类对象作为类成员"><a href="#2-7-类对象作为类成员" class="headerlink" title="2.7 类对象作为类成员"></a>2.7 类对象作为类成员</h3><p>C++类中成员可以是另一个类的对象，我们称该成员为对象成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    A C;<br>&#125;;<br><span class="hljs-comment">//先有鸡还是先有蛋</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Phone</span>(string pName) &#123;<br>        m_pName = pName;<br>        cout &lt;&lt; <span class="hljs-string">&quot;手机构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    string m_pName;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, string pName) :<span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Phone</span>(pName) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;人构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    string m_Name;<br>    Phone m_Phone;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;Red mi&quot;</span>)</span></span>;<br>    cout &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot;拿着&quot;</span> &lt;&lt; p.m_Phone.m_pName &lt;&lt; <span class="hljs-string">&quot;手机&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>当其他类对象作为本类成员，构造的时候先构造其他类，再构造本类</p><p>析构顺序相反</p><h3 id="2-8-静态成员"><a href="#2-8-静态成员" class="headerlink" title="2.8 静态成员"></a>2.8 静态成员</h3><p>静态成员就是再成员变量或者成员函数前面加上static关键字</p><p>静态成员变量</p><ol><li>所有对象共享同一份数据</li><li>在编译阶段分配内存（全局区）</li><li>类内声明，类外初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_a;<span class="hljs-comment">//类内声明</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_b;<br>&#125;;<br><br><span class="hljs-type">int</span> Person::m_a = <span class="hljs-number">100</span>; <span class="hljs-comment">//类外初始化</span><br><span class="hljs-type">int</span> Person::m_b = <span class="hljs-number">200</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    cout &lt;&lt; p.m_a &lt;&lt; endl;<br>    Person p2;<br>    p<span class="hljs-number">2.</span>m_a = <span class="hljs-number">200</span>;<br>    cout &lt;&lt; p<span class="hljs-number">2.</span>m_a &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//静态成员不属于某一个对象，所有对象都共享同一份数据</span><br><br>    <span class="hljs-comment">//所以由两种访问方式</span><br>    <span class="hljs-comment">//1.通过类名访问</span><br>    cout &lt;&lt; Person::m_a &lt;&lt; endl;<br>    <span class="hljs-comment">//2.通过对象访问</span><br>    Person p;<br>    cout &lt;&lt; p.m_a &lt;&lt; endl;<br>    <span class="hljs-comment">//静态成员变量也是有访问权限的</span><br>    <span class="hljs-comment">//cout &lt;&lt; Person::m_b &lt;&lt; endl; //无法访问privete中数据</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//test01();</span><br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>静态成员函数</p><ol><li>所有对象共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        m_a = <span class="hljs-number">100</span>;<span class="hljs-comment">//静态成员函数可以访问静态成员</span><br>        <span class="hljs-comment">//m_b = 200;//静态成员函数 不可以访问 非静态成员变量,无法区分是哪个对象的m_b属性</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;static void func 的调用!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-type">int</span> m_b;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//类外访问不到这个私有静态成员函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;static void func2 的调用!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> Person::m_a = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p;<br>    p.<span class="hljs-built_in">func</span>();<br><br>    Person::<span class="hljs-built_in">func</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="3-C-对象模型和this指针"><a href="#3-C-对象模型和this指针" class="headerlink" title="3 C++对象模型和this指针"></a>3 C++对象模型和this指针</h2><h3 id="3-1-成员变量和成员函数分开存储"><a href="#3-1-成员变量和成员函数分开存储" class="headerlink" title="3.1 成员变量和成员函数分开存储"></a>3.1 成员变量和成员函数分开存储</h3><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-type">int</span> m_a; <span class="hljs-comment">//非静态成员变量 属于类的对象上</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_b; <span class="hljs-comment">// 静态成员变量 不属于类的对象上</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;   <span class="hljs-comment">// 非静态成员函数  不属于类的对象上</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">// 静态成员函数    不属于类的对象上</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    <span class="hljs-comment">//空对象占用内存空间为：1</span><br>    <span class="hljs-comment">//C++编译器会给每个空对象也分配一个独立的内存空间，是为了区分空对象占内存空间的位置</span><br>    <span class="hljs-comment">//每个空对象也应该有一个独一无二的内存地址</span><br>    cout &lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-this指针"><a href="#3-2-this指针" class="headerlink" title="3.2 this指针"></a>3.2 this指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-comment">//this 指针指向 被调用的成员函数 所属的对象</span><br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>    &#125;<br>    <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddAge</span><span class="hljs-params">(Person&amp; p)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age += p.age;<br>        <span class="hljs-comment">//返回对象本身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-comment">//1.解决名称冲突</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    cout &lt;&lt; p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//2.返回对象本身用*this</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    p<span class="hljs-number">2.</span><span class="hljs-built_in">PersonAddAge</span>(p1).<span class="hljs-built_in">PersonAddAge</span>(p1).<span class="hljs-built_in">PersonAddAge</span>(p1);<br>    cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄是：&quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="3-3-空指针访问成员函数"><a href="#3-3-空指针访问成员函数" class="headerlink" title="3.3 空指针访问成员函数"></a>3.3 空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">welcome</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;欢迎使用&quot;</span> &lt;&lt; endl;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ageage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cout &lt;&lt; age &lt;&lt; endl;<span class="hljs-comment">//报错的原因是指针为NULL</span><br>    &#125;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person* p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">welcome</span>();<br>    p-&gt;<span class="hljs-built_in">ageage</span>();<br>    <br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="3-4-const-修饰成员函数"><a href="#3-4-const-修饰成员函数" class="headerlink" title="3.4 const 修饰成员函数"></a>3.4 const 修饰成员函数</h3><p>常函数：</p><ol><li>成员函数后加const后我们称为这个函数为常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ol><p>常对象：</p><ol><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//this 指针的本质 是指针常量 指针的指向是不可以修改的</span><br>    <span class="hljs-comment">//即Person * const this</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-comment">//const Person* const this;</span><br>        <span class="hljs-comment">//this-&gt;m_a = 100; //加const后不能修改指针指向的值</span><br>        <span class="hljs-comment">//this = NULL; //this指针不可以修改指针的指向的</span><br>    <span class="hljs-keyword">this</span>-&gt;m_b = <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-function">viod <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_b;<span class="hljs-comment">//特殊变量，即使在常函数中也可以修改</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><span class="hljs-comment">//常对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> Person p;<span class="hljs-comment">//常对象</span><br>    <span class="hljs-comment">//p.m_a = 100; //不能改</span><br>    p.m_b = <span class="hljs-number">100</span>; <span class="hljs-comment">//可以修改</span><br>    <span class="hljs-comment">//常对象只能调用常函数</span><br>    p.<span class="hljs-built_in">showPerson</span>();<br>    <span class="hljs-comment">//p.func();//常对象不能调用其他函数，常对象只能调用常函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-友元"><a href="#4-友元" class="headerlink" title="4 友元"></a>4 友元</h2><p>友元的三种实现</p><h3 id="4-1-全局函数做友元"><a href="#4-1-全局函数做友元" class="headerlink" title="4.1 全局函数做友元"></a>4.1 全局函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building* building)</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>() &#123;<br>        m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>        m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br><br>    &#125;<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;  <span class="hljs-comment">//卧室</span><br>&#125;;<br><br><span class="hljs-comment">//全局函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building* building)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友的全局函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友的全局函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Building building;<br>    <span class="hljs-built_in">goodGay</span>(&amp;building);<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="4-2类做友元"><a href="#4-2类做友元" class="headerlink" title="4.2类做友元"></a>4.2类做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;  <span class="hljs-comment">//卧室</span><br>&#125;;<br>Building::<span class="hljs-built_in">Building</span>() &#123;<br>    m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GoodGay</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//参观函数，访问Building中的属性</span><br>    Building* building;<br>&#125;;<br><br>GoodGay::<span class="hljs-built_in">GoodGay</span>() &#123;<br>    <span class="hljs-comment">//创建建筑物对象</span><br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    GoodGay gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-类内函数做友元"><a href="#4-3-类内函数做友元" class="headerlink" title="4.3 类内函数做友元"></a>4.3 类内函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GoodGay</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//参观函数，访问Building中的属性</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    Building* building;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>    string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;  <span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>() &#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br>    <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>GoodGay::<span class="hljs-built_in">GoodGay</span>() &#123;<br>    <span class="hljs-comment">//创建建筑物对象</span><br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit2</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;好基友正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    GoodGay gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br>    gg.<span class="hljs-built_in">visit2</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-运算符重载"><a href="#5-运算符重载" class="headerlink" title="5.运算符重载"></a>5.运算符重载</h2><p>概念：对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型</p><h3 id="5-1-加号运算符重载"><a href="#5-1-加号运算符重载" class="headerlink" title="5.1 加号运算符重载"></a>5.1 加号运算符重载</h3><p>作用：实现两个自定义类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//1.通过成员函数重载</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Person <span class="hljs-keyword">operator</span>+(Person&amp; p) &#123;<br>        Person temp;<br>        temp.m_a = <span class="hljs-keyword">this</span>-&gt;m_a + p.m_a;<br>        temp.m_b = <span class="hljs-keyword">this</span>-&gt;m_b + p.m_b;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-type">int</span> m_b;<br>&#125;;<br><span class="hljs-comment">//2.通过全局函数重载</span><br><span class="hljs-comment">//Person operator+(Person&amp; p1, Person&amp; p2) &#123;</span><br><span class="hljs-comment">//    Person temp;</span><br><span class="hljs-comment">//    temp.m_a = p1.m_a + p2.m_a;</span><br><span class="hljs-comment">//    temp.m_b = p1.m_b + p2.m_b;</span><br><span class="hljs-comment">//    return temp;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person p1;<br>    p<span class="hljs-number">1.</span>m_a = <span class="hljs-number">10</span>;<br>    p<span class="hljs-number">1.</span>m_b = <span class="hljs-number">10</span>;<br>    Person p2;<br>    p<span class="hljs-number">2.</span>m_a = <span class="hljs-number">10</span>;<br>    p<span class="hljs-number">2.</span>m_b = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//成员函数的本质调用</span><br>    Person p3 = p<span class="hljs-number">1.</span><span class="hljs-keyword">operator</span>+(p2);<br>    <span class="hljs-comment">//全局函数的本质调用</span><br>    <span class="hljs-comment">//Person p3 = operator+(p1, p2);</span><br>    <span class="hljs-comment">//Person p3 = p1+p2;</span><br>    cout &lt;&lt; p<span class="hljs-number">3.</span>m_a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-左移运算符重载"><a href="#5-2-左移运算符重载" class="headerlink" title="5.2 左移运算符重载"></a>5.2 左移运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person p);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>        m_a = a;<br>        m_b = b;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//利用成员函数重载 左移运算符</span><br>    <span class="hljs-comment">//不用成员函数，会变成p&lt;&lt;cout</span><br>    <span class="hljs-comment">//void operator&lt;&lt;(cout)&#123;&#125;</span><br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-type">int</span> m_b;<br>&#125;;<br><br><span class="hljs-comment">//只能利用全局函数重载左移运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person p) &#123;<span class="hljs-comment">//本质 operator&lt;&lt;(cout,p) 简化 cout&lt;&lt;p;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;m_a = &quot;</span> &lt;&lt; p.m_a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;m_b = &quot;</span> &lt;&lt; p.m_b;<br>    <span class="hljs-keyword">return</span> cout; <span class="hljs-comment">//输出了成员属性后使用链式编程追加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-递增运算符重载"><a href="#5-3-递增运算符重载" class="headerlink" title="5.3 递增运算符重载"></a>5.3 递增运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInteger</span> &#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyInteger</span>() &#123;<br>        m_Num = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//重载前置++运算符</span><br>    MyInteger&amp; <span class="hljs-keyword">operator</span>++() &#123;<span class="hljs-comment">//返回引用是为了对一个数据进行操作</span><br>        <span class="hljs-comment">//先自身++的操作</span><br>        m_Num++;<br>        <span class="hljs-comment">//再将自身的引用返回</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">//重载后置++运算符</span><br>    MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)&#123; <span class="hljs-comment">//int 代表的是占位参数，可以区分前置递增和后置递增</span><br>        <span class="hljs-comment">//先 记录当时的结果</span><br>        MyInteger temp = *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-comment">//后 递增</span><br>        m_Num++;<br>        <span class="hljs-comment">//最后将记录的结果做返回的操作</span><br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_Num;<br>&#125;;<br><span class="hljs-comment">//重载左移运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint) &#123;<br>    cout &lt;&lt; myint.m_Num;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    MyInteger myint;<br>    cout &lt;&lt; ++(++myint) &lt;&lt; endl;<br>    cout &lt;&lt; myint &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>递减运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInteger</span> &#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger Myint);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyInteger</span>() &#123;<br>        m_Num = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//前置递减</span><br>    MyInteger&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        m_Num--;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">//后置递减</span><br>    MyInteger <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        MyInteger temp = *<span class="hljs-keyword">this</span>;<br>        m_Num--;<br>        <span class="hljs-keyword">return</span> temp;<br><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_Num;<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger Myint) &#123;<br>    cout &lt;&lt; Myint.m_Num;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    MyInteger myint;<br>    cout &lt;&lt; --(--myint) &lt;&lt; endl;<br>    cout &lt;&lt; myint&lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    MyInteger myint;<br>    cout &lt;&lt; myint-- &lt;&lt; endl;<br>    cout &lt;&lt; myint &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-赋值运算符重载"><a href="#5-4-赋值运算符重载" class="headerlink" title="5.4 赋值运算符重载"></a>5.4 赋值运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<br>        m_age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(age);<br>    &#125;<br><br>    <span class="hljs-comment">//赋值运算符重载</span><br>    Person&amp; <span class="hljs-keyword">operator</span>=(Person&amp; p) &#123;<br>        <span class="hljs-comment">//不为空则释放堆区</span><br>        <span class="hljs-keyword">if</span> (m_age != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_age;<br>            m_age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//再开辟堆区深拷贝</span><br>        m_age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_age);<br>        <span class="hljs-comment">//返回本身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//析构在结束时释放堆区</span><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br>        <span class="hljs-keyword">if</span> (m_age != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_age;<br>            m_age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义年龄指针</span><br>    <span class="hljs-type">int</span>* m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">19</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br>    p3 = p2 = p1;  <span class="hljs-comment">//测试</span><br>    cout &lt;&lt; *p<span class="hljs-number">1.</span>m_age &lt;&lt; endl;<br>    cout &lt;&lt; *p<span class="hljs-number">2.</span>m_age &lt;&lt; endl;<br>    cout &lt;&lt; *p<span class="hljs-number">3.</span>m_age &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-关系运算符重载"><a href="#5-5-关系运算符重载" class="headerlink" title="5.5 关系运算符重载"></a>5.5 关系运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//关系运算符重载</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) &#123;<br>        m_name = name;<br>        m_age = age;<br>    &#125;<br>    <span class="hljs-comment">//==重载</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Person&amp; p) &#123;<br>        <span class="hljs-keyword">if</span> (p.m_age == <span class="hljs-keyword">this</span>-&gt;m_age &amp;&amp; p.m_name == <span class="hljs-keyword">this</span>-&gt;m_name) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//！=重载</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(Person&amp; p) &#123;<br>        <span class="hljs-keyword">if</span> (p.m_age == <span class="hljs-keyword">this</span>-&gt;m_age &amp;&amp; p.m_name == <span class="hljs-keyword">this</span>-&gt;m_name) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-type">int</span> m_age;<br>    string m_name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (p1 == p2) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;它们是相等的&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;它们是不相等的&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (p1 != p2) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;它们是不相等的&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;它们是相等的&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-6-函数调用运算符重载"><a href="#5-6-函数调用运算符重载" class="headerlink" title="5.6 函数调用运算符重载"></a>5.6 函数调用运算符重载</h3><ol><li>函数调用运算符（）也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//函数重载</span><br><span class="hljs-comment">//即重载()，也叫仿函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myadd</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myself</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string str1)</span> </span>&#123;<br>        cout &lt;&lt; str1&lt;&lt;endl;<br><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Myadd myadd;<br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">myadd</span>(<span class="hljs-number">15</span>, <span class="hljs-number">55</span>);<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">Myadd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">250</span>) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    Myself myself;<br>    <span class="hljs-built_in">myself</span>(<span class="hljs-string">&quot;hello!&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-继承"><a href="#6-继承" class="headerlink" title="6. 继承"></a>6. 继承</h2><p>下一级成员有上级别的共性，也有自己的特点</p><h3 id="6-1-继承的基本语法"><a href="#6-1-继承的基本语法" class="headerlink" title="6.1 继承的基本语法"></a>6.1 继承的基本语法</h3><p>继承减少重复的代码</p><p>语法   class 子类：继承方式  父类</p><p>子类：派生类</p><p>父类：基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basepage</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;首页：C++、Java、python&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;帮助中心，支持，联系我们，合作伙伴&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++、Java、python&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> :<span class="hljs-keyword">public</span> Basepage &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;下载Java视频！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> :<span class="hljs-keyword">public</span> Basepage &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;下载CPP视频！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">python</span> :<span class="hljs-keyword">public</span> Basepage &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;下载python视频！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">footer</span>();<br>    ja.<span class="hljs-built_in">left</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;_____________________&quot;</span> &lt;&lt; endl;<br><br>    python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">footer</span>();<br>    py.<span class="hljs-built_in">left</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;_____________________&quot;</span> &lt;&lt; endl;<br><br>    CPP cpp;<br>    cpp.<span class="hljs-built_in">header</span>();<br>    cpp.<span class="hljs-built_in">footer</span>();<br>    cpp.<span class="hljs-built_in">left</span>();<br>    cpp.<span class="hljs-built_in">content</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;_____________________&quot;</span> &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-继承方式"><a href="#6-2-继承方式" class="headerlink" title="6.2 继承方式"></a>6.2 继承方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">100</span>;<br>        b = <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">//c = 100;  //私有权限不可访问</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> :<span class="hljs-keyword">protected</span> Base1 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">100</span>;<br>        b = <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">//c = 100;  //私有权限不可访问</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son3</span> :<span class="hljs-keyword">private</span> Base1 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">100</span>;<br>        b = <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">//c = 100;  //私有权限不可访问</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Grandson1</span> :<span class="hljs-keyword">public</span> Son1 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">10</span>;<br>        b = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//c = 10;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Grandson2</span> :<span class="hljs-keyword">public</span> Son2 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">10</span>;<br>        b = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//c = 10;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Grandson3</span> :<span class="hljs-keyword">public</span> Son3 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//a = 10;//不可访问</span><br>        <span class="hljs-comment">//b = 10;//不可访问</span><br>        <span class="hljs-comment">//c = 10;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Son1 son1;<br>    son<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//公有继承 公有还是公有 类外可以访问</span><br>    <span class="hljs-comment">//son1.b = 10; //公有继承 保护依旧是保护 类外不可访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    Son2 son2;    <br>    <span class="hljs-comment">//son2.a = 10;  //保护继承 ，公有变成保护，类外不可以访问</span><br>    <span class="hljs-comment">//son2.b = 10;  //保护继承 ，保护还是保护，类外不可以访问</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    Son3 son3;<br>    <span class="hljs-comment">//son3.a = 10;  //私有继承 ，公有变成私有，类外不可以访问</span><br>    <span class="hljs-comment">//son3.b = 10;  //私有继承 ，保护变成私有，类外不可以访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//test01();</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-继承中的对象模型"><a href="#6-3-继承中的对象模型" class="headerlink" title="6.3 继承中的对象模型"></a>6.3 继承中的对象模型</h3><p>开发人员命令提示符</p><ol><li><p>转到改cpp目录中</p></li><li><p>输入  cl &#x2F;d1 reportSingleLayout类名 文件名</p></li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">cl /d1 reportSingleClassLayoutSon1 text22.cpp<br></code></pre></td></tr></table></figure><p>儿子的占用内存为基类和该派生类对象的总和</p><p>也就是说私有属性被继承了，但是编译器不显示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> d;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base1) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son1) &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-继承中构造和析构顺序"><a href="#6-4-继承中构造和析构顺序" class="headerlink" title="6.4 继承中构造和析构顺序"></a>6.4 继承中构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后</p><p>先构造父类，再构造子类，先析构子类，再析构父类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;父类构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base1</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;父类析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son1</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;子类构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son1</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;子类析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Son1 son1;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-5-继承同名成员处理方式"><a href="#6-5-继承同名成员处理方式" class="headerlink" title="6.5 继承同名成员处理方式"></a>6.5 继承同名成员处理方式</h3><p>当父类和子类有同名成员时，通过子类来调用这两个属性</p><ol><li>当通过子类调用子类同名属性时，直接调用即可</li><li>当通过子类调用父类同名属性时，要加上作用域</li></ol><p>同名成员函数处理方式</p><p>如果子类中出现和父类同名的成员函数，子类会隐藏掉父类的<strong>所有</strong>同名成员函数。所调用父类同名成员函数要加作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base1成员函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base1带参数的成员函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_a=<span class="hljs-number">80</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son1成员函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_a=<span class="hljs-number">100</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Son1 son1;<br>    son<span class="hljs-number">1.f</span>unc();<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>m_a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    Son1 son2;<br>    son<span class="hljs-number">2.</span>Base1::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br>    cout &lt;&lt; son<span class="hljs-number">2.</span>Base1::m_a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-6-静态同名静态成员处理方式"><a href="#6-6-静态同名静态成员处理方式" class="headerlink" title="6.6 静态同名静态成员处理方式"></a>6.6 静态同名静态成员处理方式</h3><p>如果子类中出现和父类同名的静态成员函数，子类会隐藏掉父类的<strong>所有</strong>同名静态成员函数。所调用父类同名静态成员函数要加作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base1静态成员函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base1带参数的静态成员函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_a;<br>&#125;;<br><span class="hljs-type">int</span> Base1::m_a = <span class="hljs-number">80</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Son1静态成员函数调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_a;<br>&#125;;<br><span class="hljs-type">int</span> Son1::m_a = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//通过对象访问静态成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问静态成员&quot;</span> &lt;&lt; endl;<br>    Son1 son1;<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>m_a &lt;&lt; endl;<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>Base1::m_a &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//通过类名访问静态成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问静态成员&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; Son1::m_a &lt;&lt; endl;<br>    cout &lt;&lt; Son1::Base1::m_a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//通过对象访问静态方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    Son1 son2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问静态方法&quot;</span> &lt;&lt; endl;<br>    son<span class="hljs-number">2.f</span>unc();<br>    son<span class="hljs-number">2.</span>Base1::<span class="hljs-built_in">func</span>();<br>    son<span class="hljs-number">2.</span>Base1::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><br><span class="hljs-comment">//通过类名访问静态方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问静态方法&quot;</span> &lt;&lt; endl;<br>    Son1::<span class="hljs-built_in">func</span>();<br>    Son1::Base1::<span class="hljs-built_in">func</span>();<br>    Son1::Base1::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);  <span class="hljs-comment">//第一个::时通过类名访问，第二个::是代表父类作用域</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test04</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-7-多继承"><a href="#6-7-多继承" class="headerlink" title="6.7 多继承"></a>6.7 多继承</h3><p>语法      class 子类：继承方式1 父类1，继承方式2 父类2…{}</p><p>缺点：当父类中有重名会导致成员调用不明确，应加上作用域，实际开发中尽量避免多继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a = <span class="hljs-number">100</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a = <span class="hljs-number">88</span>;<br>    <span class="hljs-type">int</span> m_b = <span class="hljs-number">200</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_c = <span class="hljs-number">300</span>;<br>    <span class="hljs-type">int</span> m_d = <span class="hljs-number">400</span>;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Son1 son1;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son1) &lt;&lt; endl;<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>Base1::m_a &lt;&lt; endl;<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>Base2::m_a &lt;&lt; endl;<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>m_b &lt;&lt; endl;<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>m_c &lt;&lt; endl;<br>    cout &lt;&lt; son<span class="hljs-number">1.</span>m_d &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-8-菱形继承"><a href="#6-8-菱形继承" class="headerlink" title="6.8 菱形继承"></a>6.8 菱形继承</h3><p>菱形继承是一个父类，两个派生类继承这个父类，另一个类同时继承这两个派生类</p><p>**问题：**子类继承了两个父类成员属性，造成资源浪费，通过创建虚基类可以解决这个问题</p><p>vbptr(虚基类指针)——vbtable（虚基类表格）</p><p>v——virtual虚</p><p>b——base基类</p><p>ptr——pointer指针</p><p>Sheep类中虚基类指针指向下面的第一个虚基类表，表中记录了偏移量8，即0+8 &#x3D; 8</p><p>Camel类中虚基类指针指向下面的第二个虚基类表，表中记录了偏移量4，即4+4 &#x3D; 8</p><p>最终的地址都是Animal::age ，唯一的一个。</p><p>示例代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//菱形继承</span><br><span class="hljs-comment">//动物类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><span class="hljs-comment">//羊类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> :<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-comment">//驼类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camel</span> :<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-comment">//羊驼类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SC</span> :<span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Camel &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    SC sc1;<br>    <span class="hljs-comment">//sc1.m_age = 18; //不明确</span><br>    sc<span class="hljs-number">1.</span>Sheep::m_age = <span class="hljs-number">18</span>;<br>    sc<span class="hljs-number">1.</span>Camel::m_age = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;羊驼的年龄：&quot;</span> &lt;&lt; sc<span class="hljs-number">1.</span>Sheep::m_age &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;羊驼的年龄：&quot;</span> &lt;&lt; sc<span class="hljs-number">1.</span>Camel::m_age &lt;&lt; endl;<br>    sc<span class="hljs-number">1.</span>m_age = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;羊驼的年龄：&quot;</span> &lt;&lt; sc<span class="hljs-number">1.</span>m_age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-多态"><a href="#7-多态" class="headerlink" title="7. 多态"></a>7. 多态</h2><h3 id="7-1-多态的基本概念"><a href="#7-1-多态的基本概念" class="headerlink" title="7.1 多态的基本概念"></a>7.1 多态的基本概念</h3><p>多态是C++面向对象的三大特性之一</p><p>多态分两类</p><ol><li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ol><p>静态多态和动态多态的区别</p><ol><li>静态多态的函数地址早绑定 - 编译阶段缺点函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//地址早绑定，静态多态</span><br>    <span class="hljs-comment">//void doSpeak() &#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//加上virtual变成动态多态，地址晚绑定</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">(Animal&amp; animal)</span> </span>&#123;<br>    animal.<span class="hljs-built_in">doSpeak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Cat cat;<br>    <span class="hljs-built_in">doSpeak</span>(cat);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>vfptr ——虚函数指针</p><p>v——virtual</p><p>f——function</p><p>ptr——Pointer</p><p>vftable ——虚函数表</p><p>当父类为虚函数时，由于虚函数指针占4个字节，父类若无其他成员和虚函数，也是占4个字节</p><p>发生继承时，子类也是四个字节</p><p>当子类不重写父类虚函数方法时，继承父类虚函数，虚函数指针指向父类方法，为早绑定</p><p>当子类重写父类虚函数方法时，子类继承父类虚函数，虚函数指针指向子类方法，为晚绑定</p><h3 id="7-2-多态案例——计算器类"><a href="#7-2-多态案例——计算器类" class="headerlink" title="7.2 多态案例——计算器类"></a>7.2 多态案例——计算器类</h3><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ol><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的拓展以及维护</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">getResults</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">double</span> m_number1=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> m_number2=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getResults</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_number1 + m_number2;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getResults</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_number1 - m_number2;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getResults</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_number1 * m_number2;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    AbstractCalculator* abs = <span class="hljs-keyword">new</span> AddCalculator;<br>    abs-&gt;m_number1 = <span class="hljs-number">100</span>;<br>    abs-&gt;m_number2 = <span class="hljs-number">99</span>;<br>    cout &lt;&lt; abs-&gt;m_number1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; abs-&gt;m_number2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abs-&gt;<span class="hljs-built_in">getResults</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abs;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>    AbstractCalculator* abs = <span class="hljs-keyword">new</span> SubCalculator;<br>    abs-&gt;m_number1 = <span class="hljs-number">100</span>;<br>    abs-&gt;m_number2 = <span class="hljs-number">99</span>;<br>    cout &lt;&lt; abs-&gt;m_number1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; abs-&gt;m_number2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abs-&gt;<span class="hljs-built_in">getResults</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abs;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>    AbstractCalculator* abs = <span class="hljs-keyword">new</span> MulCalculator;<br>    abs-&gt;m_number1 = <span class="hljs-number">100</span>;<br>    abs-&gt;m_number2 = <span class="hljs-number">99</span>;<br>    cout &lt;&lt; abs-&gt;m_number1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; abs-&gt;m_number2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abs-&gt;<span class="hljs-built_in">getResults</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abs;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">test03</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-3-纯虚函数和抽象类"><a href="#7-3-纯虚函数和抽象类" class="headerlink" title="7.3 纯虚函数和抽象类"></a>7.3 纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为纯虚函数</p><p>纯虚函数语法    virtual 返回值类型  函数名  (参数列表) &#x3D; 0；</p><p>当类中有了纯虚函数，这个类也称为抽象类</p><p>抽象类特点：</p><ol><li>无法实例化对象</li><li>子类必须重写抽象类的纯虚函数，否则也属于抽象类</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象类无法实例化</span><br><span class="hljs-comment">//抽象类的子类要重写纯虚函数，不然也是抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello &quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//Base1 base1; //父类是抽象类不可实例化</span><br>    <span class="hljs-comment">//Son1 son1;   //子类未重写父类纯虚函数子类也是抽象类不可实例化</span><br>    Son1 son1;     <span class="hljs-comment">//子类重写父类函数可实例化</span><br>    <span class="hljs-comment">//多态技术：父类的指针或引用指向子类对象 来调用子类</span><br>    Base1* base = <span class="hljs-keyword">new</span> Son1;<br>    base-&gt;<span class="hljs-built_in">func</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-4-多态案例二—制作饮品"><a href="#7-4-多态案例二—制作饮品" class="headerlink" title="7.4 多态案例二—制作饮品"></a>7.4 多态案例二—制作饮品</h3><p>案例描述：</p><p>制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//煮水-冲泡-倒入杯中-加入辅料</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drink</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brewing</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addAccessories</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">makeDrink</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">boil</span>();<br>        <span class="hljs-built_in">brewing</span>();<br>        <span class="hljs-built_in">pourInCup</span>();<br>        <span class="hljs-built_in">addAccessories</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> :<span class="hljs-keyword">public</span> Drink &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;煮水&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brewing</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;泡入茶叶&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;倒茶入杯子&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addAccessories</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;放入枸杞&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> :<span class="hljs-keyword">public</span> Drink &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;煮水&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brewing</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;泡入咖啡&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;倒咖啡入杯子&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addAccessories</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;放入糖和巧克力&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Drink* drink)</span> </span>&#123;<br>    drink-&gt;<span class="hljs-built_in">makeDrink</span>();<br>    <span class="hljs-keyword">delete</span> drink;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">doWork</span>(<span class="hljs-keyword">new</span> Tea);<br>    <span class="hljs-built_in">doWork</span>(<span class="hljs-keyword">new</span> Coffee);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="7-5-虚析构和纯虚析构"><a href="#7-5-虚析构和纯虚析构" class="headerlink" title="7.5 虚析构和纯虚析构"></a>7.5 虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性：</p><ol><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ol><p>虚析构和纯虚析构的区别：</p><p>  如果是纯虚析构，该类属于抽象类，无法实例化对象</p><p>虚析构语法：</p><p>vrtual ~类名(){}</p><p>纯虚析构语法：</p><p>virtual ~类名() &#x3D; 0;</p><p>类名::~类名(){}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal的构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//~Animal() &#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; &quot;Animal的析构函数&quot; &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;;<br>Animal::~<span class="hljs-built_in">Animal</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Animal的析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> :<span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(string name) &#123;<br>        m_name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat的构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt;*m_name&lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    string* m_name;<br>    ~<span class="hljs-built_in">Cat</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat的析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Animal* animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    animal-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-keyword">delete</span> animal;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-6-多态案例三-电脑组装"><a href="#7-6-多态案例三-电脑组装" class="headerlink" title="7.6 多态案例三-电脑组装"></a>7.6 多态案例三-电脑组装</h3><p>案例描述：</p><p>电脑的主要组成部件为cpu，显卡，内存条</p><p>将每个零件封装出抽象基类，并且提供不同的生产厂商不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//基类cpu ，只有代表功能的纯虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cpu</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculator</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//基类显卡 ，只有代表功能的纯虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vedio</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//基类内存条 ，只有代表功能的纯虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//电脑类，构造电脑，传入三个指针给私有属性，并提供工作函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Computer</span>(Cpu* cpu, Vedio* vedio, Memory* memory) &#123;<br>        m_cpu = cpu;<br>        m_vedio = vedio;<br>        m_memory = memory;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        m_cpu-&gt;<span class="hljs-built_in">calculator</span>();<br>        m_vedio-&gt;<span class="hljs-built_in">display</span>();<br>        m_memory-&gt;<span class="hljs-built_in">storage</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">Computer</span>() &#123;<br>        <span class="hljs-keyword">if</span> (m_cpu != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_cpu;<br>            m_cpu = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (m_vedio != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_vedio;<br>            m_vedio = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (m_memory != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">delete</span> m_memory;<br>            m_memory = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Cpu* m_cpu;<br>    Vedio* m_vedio;<br>    Memory* m_memory;<br>&#125;;<br><br><span class="hljs-comment">//lenovo零件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoCpu</span> :<span class="hljs-keyword">public</span> Cpu &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculator</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;联想中央处理器开始计算了&quot;</span> &lt;&lt; endl;<br>    &#125;  <br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoVedio</span> :<span class="hljs-keyword">public</span> Vedio &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;联想显卡开始显示了&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoMemory</span> :<span class="hljs-keyword">public</span> Memory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;联想内存条开始内存交换了&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//Intel零件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCpu</span> :<span class="hljs-keyword">public</span> Cpu &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculator</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel中央处理器开始计算了&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelVedio</span> :<span class="hljs-keyword">public</span> Vedio &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel显卡开始显示了&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMemory</span> :<span class="hljs-keyword">public</span> Memory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Intel内存条开始内存交换了&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//测试，通过多态创建三个零件，再创建电脑对象传入零件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Cpu* intercpu = <span class="hljs-keyword">new</span> IntelCpu;<br>    Vedio* intervedio = <span class="hljs-keyword">new</span> IntelVedio;<br>    Memory* intelmemory = <span class="hljs-keyword">new</span> IntelMemory;<br>    Computer* computer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(intercpu, intervedio, intelmemory);<br>    computer1-&gt;<span class="hljs-built_in">work</span>();<br>    <span class="hljs-keyword">delete</span> computer1;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
