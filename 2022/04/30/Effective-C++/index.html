

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="liruilong">
  <meta name="keywords" content="study">
  
    <meta name="description" content="56个C++编程风格">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="https://liruilong9999.github.io/2022/04/30/Effective-C++/index.html">
<meta property="og:site_name" content="非酋的博客">
<meta property="og:description" content="56个C++编程风格">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-3-1.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-4-1.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-4-2.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-4-3.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-4-4.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-5-1.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-6-1.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-6-2.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-6-3.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-6-4.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-6-5.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-6-6.png">
<meta property="og:image" content="https://liruilong9999.github.io/images/cppeffective-6-7.png">
<meta property="article:published_time" content="2022-04-29T19:15:16.000Z">
<meta property="article:modified_time" content="2024-11-11T06:28:17.249Z">
<meta property="article:author" content="liruilong">
<meta property="article:tag" content="语言">
<meta property="article:tag" content="Effective C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://liruilong9999.github.io/images/cppeffective-3-1.png">
  
  
  
  <title>Effective C++ - 非酋的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"liruilong9999.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>这是什么?</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Effective C++"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-30 03:15" pubdate>
          星期六, 四月 30日 2022, 3:15 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          247 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Effective C++</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><ol>
<li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li>
<li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li>
<li>尽可能使用 const</li>
<li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li>
<li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li>
<li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li>
<li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li>
<li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li>
<li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li>
<li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li>
<li>在 <code>operator=</code> 中处理 “自我赋值”</li>
<li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li>
<li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li>
<li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li>
<li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li>
<li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li>
<li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li>
<li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li>
<li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li>
<li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li>
<li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li>
<li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li>
<li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li>
<li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li>
<li>考虑写一个不抛异常的 swap 函数</li>
<li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li>
<li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li>
<li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li>
<li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li>
<li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li>
<li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li>
<li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li>
<li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li>
<li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li>
<li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li>
<li>绝不重新定义继承而来的 non-virtual 函数</li>
<li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li>
<li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））</li>
<li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）</li>
<li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）</li>
<li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）</li>
<li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）</li>
<li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-&gt;</code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）</li>
<li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）</li>
<li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）</li>
<li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）</li>
<li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）</li>
<li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）</li>
<li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）</li>
<li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）</li>
<li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）</li>
<li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）</li>
<li>不要轻忽编译器的警告</li>
<li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）</li>
<li>让自己熟悉 Boost（准标准库）</li>
</ol>
<h1 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h1><ol>
<li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）</li>
<li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）</li>
<li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）</li>
<li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）</li>
<li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）</li>
<li>区别 increment&#x2F;decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）</li>
<li>千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&amp;&amp;</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）</li>
<li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）</li>
<li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）</li>
<li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）</li>
<li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）</li>
<li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）</li>
<li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）</li>
<li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）</li>
<li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）</li>
<li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）</li>
<li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）</li>
<li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</li>
</ol>
<h1 id="Effective-C-详解"><a href="#Effective-C-详解" class="headerlink" title="Effective C++详解"></a>Effective C++详解</h1><h1 id="一-让自己习惯C"><a href="#一-让自己习惯C" class="headerlink" title="一. 让自己习惯C++"></a>一. 让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><p>我们可以把C++理解为相关语言组成的联邦而非单一语言。包括</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++ </li>
<li>STL</li>
</ul>
<p>C++刚被推出时是C的加强版，加了一些面向对象的特性。最初的名称为C with Classes。随着时代的进步，C++不断发展，有了各种特性。 现在的C++是一个多重范型编程语言，它支持支持过程形式、支持面向对象形式Object-Oriented C++、函数形式、泛型形式、元编程形式（Template C++，STL)、这些能力使得c++成为一个无可匹敌的工具</p>
<h2 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const,enum,inline替换#define"></a>条款02：尽量以const,enum,inline替换#define</h2><p><strong>这个条款或许改为“宁可以编译器替换预处理器”比较好</strong></p>
<h3 id="1）以const替换-define"><a href="#1）以const替换-define" class="headerlink" title="1）以const替换#define"></a>1）以const替换#define</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br>替换为：<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> AspectRatio = <span class="hljs-number">1.653</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>调试的需要</strong>：#define的记号会被预处理器移走，记号名称可能没进入记号表内。因此当#define的宏名称获得一个编译错误时，会引起困惑，浪费大量时间追踪错误。而AspectRatio肯定会被编译器看到</li>
<li><strong>更小的代码量</strong>：对浮点数而言，使用常量可能比使用#define导致较小量的代码，因为预处理器“盲目地将ASPECT_RATIO替换为1.653”可能导致目标码出现多份1.653</li>
</ul>
<p>但是，以常量替换#define时要注意：</p>
<ul>
<li><p>定义常量指针时：由于常量定义式通常被定义在头文件内，因此有必要将指针声明为const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> authorName = <span class="hljs-string">&quot;Scott Meyers&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>class专属常量：class专属常量需要声明在class内部，并且被class使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>; <span class="hljs-comment">//常量声明式</span><br>    <span class="hljs-type">int</span> scores[NumTurns];          <span class="hljs-comment">//使用该常量</span><br>&#125;;<br><span class="hljs-comment">//通常定义出现在头文件中</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns;    <span class="hljs-comment">//NumTurns的定义</span><br></code></pre></td></tr></table></figure>

<p>对于static修饰的class专属整形常量，如果需要对该常量取地址或编译器坚持要看到一个定义式。那么必须提供类外定义。如果类内声明时提供了初始值，类外定义就不能再设初值。但是某些编译器可能不支持类内初始值，因此需要在类外定义时提供初始值，但是这样就不能像scores成员一样，在类内使用该常量。因此，如果需要使用class专属常量，最好改用“enum hack”</p>
</li>
</ul>
<h3 id="2）以enum替换-define"><a href="#2）以enum替换-define" class="headerlink" title="2）以enum替换#define"></a>2）以enum替换#define</h3><p>正如上面所提到的，编译器可能不支持类内初始值，因此改用”<strong>enum hack</strong>“：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns = <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];   <span class="hljs-comment">//这就没问题了</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>enum hack</strong>的行为比较像#define而不像const。例如取一个const的地址时合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法</p>
<h3 id="3）以inline替换-define"><a href="#3）以inline替换-define" class="headerlink" title="3）以inline替换#define"></a>3）以inline替换#define</h3><p>以#define实现宏看起来像函数，并且不会导致函数调用带来的开销，但是可能引发错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ?  (a) : (b))</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b);       <span class="hljs-comment">//a被累加2次</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b + <span class="hljs-number">10</span>);  <span class="hljs-comment">//a被累加1次</span><br></code></pre></td></tr></table></figure>

<p>使用inline函数可以减轻为参数加上括号以及参数被核算多次等问题。同时，inline可以实现一个“类内的private inline函数”，但一般而言宏无法完成此事</p>
<h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><h3 id="1）const修饰变量"><a href="#1）const修饰变量" class="headerlink" title="1）const修饰变量"></a>1）const修饰变量</h3><p>如果变量本身不应该被修改，应该使用const修饰。这样编译器可以进行保护，确保这个变量不会被修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> *p = greeting;                    <span class="hljs-comment">// non-const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = greeting;              <span class="hljs-comment">// non-const pointer, const data</span><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;             <span class="hljs-comment">// const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;       <span class="hljs-comment">// const pointer, const data </span><br></code></pre></td></tr></table></figure>

<ul>
<li>如果关键字const出现在星号左边，表示被指物是常量</li>
<li>如果出现在星号右边，表示指针自身是常量</li>
</ul>
<h3 id="2）const修饰函数"><a href="#2）const修饰函数" class="headerlink" title="2）const修饰函数"></a>2）const修饰函数</h3><ul>
<li>修饰参数时，和修饰一般变量相同</li>
<li><strong>修饰返回值，可以降低因客户错误而造成的意外</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Rational a, b, c;<br>...<br><span class="hljs-keyword">if</span> (a * b = c)&#123; <span class="hljs-comment">//其实是想做一个比较动作，使用const修饰返回值可以避免这种错误</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果a和b都是内置类型。这样的代码直截了当就是不合法。而一个“良好的用户自定义类型”的特征是他们避免与内置类型不兼容。因此对operator*的定义应该如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure>

<h3 id="3）const修饰成员函数"><a href="#3）const修饰成员函数" class="headerlink" title="3）const修饰成员函数"></a>3）const修饰成员函数</h3><p>const修饰成员函数有2个好处：</p>
<ol>
<li><strong>可读性</strong>：使得接口容易被理解，可以知道哪个函数可以改动对象哪个函数不行</li>
<li><strong>const修饰的成员函数可以作用于const对象</strong></li>
</ol>
<p>但是，使用const修饰成员函数时需要注意，C++对常量性的定义是bitwise constness，即函数const成员函数不应该修改对象的任何成员变量。因此，如果成员变量是一个指针，那么不修改指针而修改指针所指之物，也符合bitwise constness，因此如果不是从bitwise constness的角度，这样也是修改了对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>   <span class="hljs-comment">// bitwise constness声明</span><br>  &#123; <span class="hljs-keyword">return</span> pText[position]; &#125;                    <span class="hljs-comment">// 但其实不恰当</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">char</span>* pText;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> CTextBlock <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>; <span class="hljs-comment">//声明一个常量对象</span><br><span class="hljs-type">char</span> *pc = &amp;cctb[<span class="hljs-number">0</span>];            <span class="hljs-comment">//调用const operator[]取得一个指针，</span><br>                                <span class="hljs-comment">//指向cctb的数据</span><br>*pc = <span class="hljs-string">&#x27;J&#x27;</span>;                      <span class="hljs-comment">//cctb现在有了“Jello”这样的内容</span><br></code></pre></td></tr></table></figure>

<p>还有一种logical constness：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 最近一次计算的文本区块长度</span><br>  <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 目前的长度是否有效</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//错误！在const成员函数内不能复制给</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//textLength和lengthIsValid</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，C++对常量性的定义是bitwise constness的，所以这样的操作非法。解决办法是使用mutable:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 这些成员变量可能总是会被更改</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 即使在const成员函数内</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//现在可以这样</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//也可以这样</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总的来说，上面提到了2种“修改”const成员函数中修改对象（修改const对象）的方法</p>
<p>最后，const和non-const版本的函数可能含有重复的代码，如果抽离出来单独成为一个成员函数还是有重复。如果希望去重，可以使用“运用const成员函数实现出其non-const孪生兄弟”的技术：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)<br>                [pos]   <br>        );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h2><p><strong>读取未初始化对象的后果</strong>：读取未被初始化的值会导致不明确的行为。在某些平台上，仅仅只是读取未初始化的值就可能让程序终止，更可能的情况是读入一些“半随机”bits，污染了正在进行读取动作的那个对象，最终导致不可预知的程序行为，以及许多令人不愉快的调试过程</p>
<p>按对象的类型划分：</p>
<ul>
<li><p><strong>对于内置类型的对象</strong>：永远在使用前初始化</p>
</li>
<li><p>类类型的对象</p>
<p>：初始化责任落在构造函数身上</p>
<ul>
<li><p>效率上的问题</p>
<p>：</p>
<ul>
<li>类类型成员的初始化动作发生在构造函数本体之前。比起先调用default构造函数然后再调用copy assignment操作符，单只调用一次copy构造函数比较高效。因此，善用初始化列表有助于提升效率</li>
<li>内置类型成员的初始化不一定发生在赋值动作的的时间点之前 。对于内置类型成员，一般为了保持一致也在初始化列表中给出初始值</li>
</ul>
</li>
<li><p><strong>初始化顺序</strong>：成员的初始化顺序与类内声明顺序相同</p>
</li>
</ul>
</li>
</ul>
<p>按对象的作用域与生命周期划分</p>
<ul>
<li><p>static对象</p>
<ul>
<li><p>non-local static对象</p>
<p>：C++对“定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确定义</p>
<ul>
<li>global对象</li>
<li>定义于namespace作用域内的对象</li>
<li>classes内、file作用域内被声明为static的对象</li>
</ul>
</li>
<li><p>local static对象</p>
<p>：函数内的local static对象会在“该函数被调用期间、首次遇上该对象的定义式”时被初始化</p>
<ul>
<li>函数内被声明为static的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，如果一个non-local static对象的初始化依赖于另外一个non-local static的初始化，那么可能造成错误。解决方法是使用local static对象替换non-local static对象（参考单例模式）</p>
<h1 id="二-构造-析构-赋值运算"><a href="#二-构造-析构-赋值运算" class="headerlink" title="二.构造&#x2F;析构&#x2F;赋值运算"></a>二.构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><p>一般情况下，编译器会为类合成下列函数：</p>
<ul>
<li><strong>default构造函数</strong></li>
<li><strong>copy构造函数</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li>
<li><strong>copy assignment操作符</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li>
<li><strong>析构函数</strong>：编译器生成的版本是<strong>non-virtual</strong>的</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.md#%E7%AC%AC2%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E6%84%8F%E5%AD%A6">更深层次的理解</a>（对象模型第2章、第5章）</p>
<p>以下情况编译器不会合成<strong>copy assignment操作符</strong>：</p>
<ul>
<li><strong>含有引用成员</strong>：原因在于这种情况下，赋值的目的不明确。是修改引用还是修改引用的对象？如果是修改引用，这是被禁止的。因此编译器干脆拒绝这样的赋值行为</li>
<li><strong>含有const成员</strong>：const对象不应该修改</li>
<li><strong>父类的copy assignment操作符被声明为private</strong>：无法处理基类子对象，因此也就无法合成</li>
</ul>
<h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p><strong>为什么要拒绝</strong>？比如，房产应该是独一无二的，这种情况下应该拒绝对象拷贝动作</p>
<p>一般情况下，不声明相应函数即可拒绝。但是编译器会为类合成一些函数，因此需要显式拒绝</p>
<p>还是以拒绝对象拷贝为例子，拒绝方法包括：</p>
<ol>
<li><p>将copy构造函数或copy assignment操作符声明为private，并且不定义</p>
<p>（这被用于C++ iostream程序库中）</p>
<ul>
<li>这种情况下member函数和friend函数还是可以调用，如果member函数或friend函数中执行了复制，会引发<strong>链接错误</strong>。可以使用一个基类，在基类中将copy构造函数或copy assignment操作符声明为private，并且继承这个基类。这样可以将<strong>链接错误</strong>移至<strong>编译期</strong>，因为尝试拷贝时，编译器会试着生成一个copy构造函数和一个copy assignment操作符，这些函数的“编译器合成版”会尝试调用其基类的对应兄弟，而那些调用会被编译器拒绝，因为private</li>
</ul>
</li>
<li><p><strong>使用delete</strong>（这个在书中没有提到）</p>
</li>
</ol>
<h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><ul>
<li><strong>为基类声明virtual析构函数</strong>：当派生类对象经由一个基类指针被删除，而该基类带有一个non-virtual析构函数，结果未定义——实际执行时通常发生的是对象的derived成分没有销毁，即“局部销毁”，造成资源泄露（因为存在这个问题，所以不要继承一个不被用作基类的类）</li>
<li><strong>class不用作基类时，不要将析构函数声明为virtual</strong>：virtual会引入虚函数指针，这会增加空间开销，使得类无法被C函数使用，从而不再具有移植性</li>
</ul>
<h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><strong>C++并不禁止析构函数吐出异常，但是并不鼓励这样做</strong></p>
<h3 id="1）原因"><a href="#1）原因" class="headerlink" title="1）原因"></a>1）原因</h3><p>如果析构函数吐出异常，程序可能过早结束（比如某个函数调用发生异常，在回溯寻找catch过程中，每离开一个函数，这个函数内的局部对象会被析构，如果此时析构函数又抛出异常，前一个异常还没得到处理又来一个，因此一般会引起程序过早结束）。异常从析构函数中传播出去，可能会导致不明确的行为</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28592504">知乎相关描述</a></p>
<h3 id="2）如何解决"><a href="#2）如何解决" class="headerlink" title="2）如何解决"></a>2）如何解决</h3><ol>
<li><strong>在析构函数中catch异常</strong>，然后调用<strong>abort终止</strong>程序。通过abort抢先置“不明确行为”于死地</li>
<li><strong>在析构函数中catch异常</strong>，然后记录该失败，即<strong>吞掉异常</strong>（通常是个坏主意，因为这样压制了“某些动作失败”的重要信息。但是也比负担“草率结束程序”或”不明确行为带来的风险“好）</li>
<li>重新设计接口，让客户能够在析构前主动调用可能引起异常的函数，然后析构函数中使用一个bool变量，根据用户是否主动调用来决定析构函数中是否应该调用可能引起异常的函数，<strong>让客户拥有主动权</strong>（如果客户没有主动调用，那么当发生异常时也不应该抱怨，因为已经给出了客户自己处理异常的机会）</li>
</ol>
<h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h2><p>如果希望在继承体系中根据类型在构建对象时表现出不同行为，可以会想到在基类的构造函数中调用一个虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                           <span class="hljs-comment">//所有交易的基类</span><br><span class="hljs-keyword">public</span>:                                           <br>    <span class="hljs-built_in">Transaction</span>()&#123;           <br>        ...                           <br>        <span class="hljs-built_in">logTransaction</span>();                         <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//做出一份因类型不同而不同的日志记录</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;        <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br></code></pre></td></tr></table></figure>

<p>但是最终调用的virtual函数都是基类的版本。同时，因为是纯虚函数，除非定义该函数，否则将报链接错误</p>
<p><strong>在子类构造期间，virtual函数绝不会下降到派生类阶层。取而代之的是，对象的作为就像隶属基类类型一样。即派生类对象的基类构造期间，对象的类型是基类而不是派生类；除此之外，若使用运行期类型信息</strong>（如dynamic_cast和typeid），也会把对象视为基类类型（这样对待是合理的：因为子类部分尚未初始化，如果调用的是子类的虚函数，通常会访问子类部分的数据，会引发安全问题）</p>
<p><strong>同样的道理也适用于析构函数。一旦派生类析构函数开始执行，对象内的派生类成员变量便呈现未定义值，所以C++视它们仿佛不再存在。进入基类析构函数后对象就成为一个基类对象</strong></p>
<p>如果希望实现最初的功能，即根据类型产生不同日志记录，那么可以在派生类的成员初始化列表中，向基类传递一些类型相关的信息，基类构造函数根据这些信息生成不同的日志记录，此时日志记录的生成函数不再是virtual函数</p>
<h2 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator&#x3D;返回一个reference to *this"></a>条款10：令operator&#x3D;返回一个reference to *this</h2><p>这是为了实现“连锁赋值”。这个协议除了适用于operator&#x3D;，还适用于+&#x3D;、-&#x3D;、*&#x3D;</p>
<blockquote>
<p>这只是个协议，并无强制性，如果不遵循，代码一样可通过编译</p>
</blockquote>
<h2 id="条款11：在operater-中处理“自我赋值”"><a href="#条款11：在operater-中处理“自我赋值”" class="headerlink" title="条款11：在operater&#x3D;中处理“自我赋值”"></a>条款11：在operater&#x3D;中处理“自我赋值”</h2><p>考虑如下Widget类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Bitmap *pb;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>下面的operator&#x3D;实现是一份不安全的实现，在自赋值时会出现问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; <br>Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>要处理自赋值，可以有以下几种方式：</p>
<ol>
<li><p>在开头添加“证同测试”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样做虽然能处理自赋值，但不是异常安全的，如果new时发生异常，对象的pb将指向一块被删除的内存</p>
</li>
<li><p>通过确保异常安全来获得自赋值的回报</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    Bitmap *pOrig = pb;               <span class="hljs-comment">// remember original pb</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// make pb point to a copy of *pb</span><br>    <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// delete the original pb</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，如果new失败，pb会保持原状。同时也能处理自赋值。如果担心效率可以在开头加上“证同测试”。但是if判断也会引入开销，因此需要权衡自赋值发生的频率</p>
</li>
<li><p>使用copy and swap技术</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参数为pass by reference</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget &amp;rhs)&#123;<br>    Widget <span class="hljs-built_in">temp</span>(rhs);<br>    <span class="hljs-built_in">swap</span>(temp);               <span class="hljs-comment">// swap *this&#x27;s data with</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;             <span class="hljs-comment">// the copy&#x27;s</span><br>&#125;<br><span class="hljs-comment">//参数为pass by value</span><br><span class="hljs-comment">//这种方式的缺点是代码不够清晰，但是将“copying动作“从函数本体内移至”函数参数构造阶段”</span><br><span class="hljs-comment">//却可令编译器有时生成更高效的代码</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget rhs)&#123;<br>    <span class="hljs-built_in">swap</span>(rhs);                <span class="hljs-comment">// swap *this&#x27;s data with</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;             <span class="hljs-comment">// the copy&#x27;s</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><p>如果声明自己的copying函数，意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的，会以一种奇怪的方式回敬：如果你自己写出的copying函数代码不完全，它也不会告诉你</p>
<ul>
<li>copy构造函数<ul>
<li><strong>非继承中</strong>：当为类添加一个新成员时，copy构造函数也需要为新成员添加拷贝代码。否则会调用新成员的默认构造函数初始化新成员</li>
<li><strong>继承中</strong>：在派生类的copy构造函数中，不要忘记调用基类的copy构造函数拷贝基类部分。否则会调用基类的默认构造函数初始化基类部分</li>
</ul>
</li>
<li>copy赋值运算符<ul>
<li><strong>非继承中</strong>：当为类添加一个新成员时，copy赋值运算符中也需要为新成员添加赋值代码，否则新成员会保持不变</li>
<li><strong>继承中</strong>：在派生类的copy赋值运算符中，不要忘记调用基类的copy赋值运算符，否则基类部分会保持不变</li>
</ul>
</li>
</ul>
<h1 id="三-资源管理"><a href="#三-资源管理" class="headerlink" title="三.资源管理"></a>三.资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><p>当申请一块动态内存时，可能会发生泄漏：</p>
<ul>
<li><strong>忘记delete</strong></li>
<li><strong>有delete，但是delete之前跳出控制流</strong>：在代码的维护过程中，动态分配内存和delete之间可能会加入return之类的控制流变更语句，或者是可能引发异常的代码，这样可能会使程序执行不到delete从而造成资源泄露</li>
</ul>
<p><strong>总结起来就是，手工delete一个是需要时刻记住delete，增加编码负担，另一个是即使明确delete，在delete之前控制流可能发生改变从而还是会造成资源泄露</strong></p>
<p>因此，<strong>一个好的办法是使用对象管理资源，包括下列两个关键想法</strong>：</p>
<ul>
<li><strong>获得资源后立刻放进管理对象</strong>：”以对象管理资源“的观念常被称为”资源取得时机便是初始化时机“(<strong>RAII</strong>)</li>
<li><strong>管理对象运用析构函数确保资源被释放</strong></li>
</ul>
<p>一个对象管理资源的例子是auto_ptr:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pIntv</span><span class="hljs-params">(createInvestment())</span></span>;    <br>    ...     <br>&#125;           <span class="hljs-comment">//经由auto_ptr的析构函数自动删除pInv</span><br></code></pre></td></tr></table></figure>

<p>对于<strong>对象管理资源，需要注意对象的复制行为</strong>：例如，复制逻辑可能是多个对象管理相同的资源，那么析构时就会重复delete。因此，如果是这种复制逻辑，那么应该引入引用计数，析构时根据引用计数决定是否delete。否则，一个资源就应该只由一个对象来管理，那么复制时就原来对象管理的资源就应该修改成null，而复制所得的新对象将取得资源的唯一拥有权（如auto_ptr）</p>
<blockquote>
<p>C++没有特别针对”动态分配数组“而设计的类似auto_ptr或tr1::shared_ptr那样的东西，甚至TR1中也没有。那是因为vector和string几乎总是可以取代动态分配而得的数组。因此当需要动态分配数组时，提倡使用vector（<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/C++Primer.md#23-unique_ptr">可以使用unique_ptr管理动态数组</a>）</p>
</blockquote>
<h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p>并非所有资源都是动态内存，除此之外还有锁等资源，也应该通过”对象管理资源“来确保获取资源后能够正确的释放，<strong>根据资源的类型，和不同的需求，可能需要定义不同的copy行为</strong>：</p>
<ol>
<li><strong>禁止复制</strong>：比方说锁资源，管理锁资源的对象复制通常并不合理。因此应该禁止这类对象的复制，可以通过继承一个copying操作被声明为private的基类来禁止复制，这点在条款06中有提到</li>
<li><strong>对底层资源使用”引用计数法“</strong>：如果希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制RAII对象时，应该将资源的”被引用数“递增。tr1::shared_ptr便是如此（当资源引用计数减为0时，如果不希望删除资源，比方说锁资源，可以使用shared_ptr的“删除器”）</li>
<li><strong>复制底部资源</strong>：这种情况下，希望在复制RAII对象时，同时复制其关联的底层资源。展现出一种“深拷贝”的行为</li>
<li><strong>转移底部资源的拥有</strong>：如果希望任一时刻一个资源只由一个RAII对象管理，那么在复制RAII对象时，应该实现拥有权的“转移”，原RAII对象拥有的资源设为null（如auto_ptr）</li>
</ol>
<h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><p><strong>API往往要求访问原始资源（即被RAII对象管理的资源，而不是直接访问RAII对象），所以每一个RAII类应该提供一个“取得其所管理的资源”的办法</strong></p>
<p>取得RAII对象所管理资源的办法可以通过显式转换或隐式转换：</p>
<ul>
<li><strong>显式转换(比较安全，但不易用)</strong>：如shared_ptr的get()方法</li>
<li><strong>隐式转换(比较易用，但不安全)</strong>：如shared_ptr的operator*和operator-&gt;</li>
</ul>
<p>如果通过实现隐式转换（比如，实现operator()）来提供对元素资源的访问，可能不安全：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">//以下，Font是一个RAII对象，FontHandle是一个原始资源</span><br><br><span class="hljs-symbol">Font</span> <span class="hljs-built_in">f1</span>(getFont())<span class="hljs-comment">;  </span><br><span class="hljs-symbol">...</span><br><span class="hljs-symbol">FontHandle</span> <span class="hljs-built_in">f2</span> = <span class="hljs-built_in">f1</span><span class="hljs-comment">; //原意是想使用Font，复制一个RAII对象</span><br></code></pre></td></tr></table></figure>

<p>在上面的例子中，如果实现了隐式转换，底层资源会被复制，如果f1销毁，f2会成为“虚吊的”（dangle）</p>
<p>是否该提供一个显式转换函数将RAII转换为其底层资源，或是应该提供隐式转换，答案主要取决于RAII被设计执行的特定工作，以及它被使用的情况</p>
<h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h2><p>当使用new和delete时，发生2件事</p>
<ul>
<li>new<ul>
<li>内存被分配出来（通过名为operator new的函数）</li>
<li>针对此内存会有一个（或更多）构造函数被调用</li>
</ul>
</li>
<li>delete<ul>
<li>针对此内存会有一个（或更多）析构函数被调用</li>
<li>内存被释放（通过名为operator delete的函数）</li>
</ul>
</li>
</ul>
<p>单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数，布局可能像下面这个样子：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-3-1.png"><img src="/../images/cppeffective-3-1.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>当使用delete时，唯一能够让delete知道内存中是否存在一个“数组大小记录”的办法是，由你来告诉它。即加上[]，delete便认为指针指向一个数组，否则它便认为指针指向单一对象</strong></p>
<p>因此，应该像这样使用new和delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string* stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string* stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;<br><span class="hljs-keyword">delete</span> [] stringPtr2;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果对stringPtr1使用“delete []”形式，结果未定义，但不太可能让人愉快。假设内存布局上，delete会读取若干内存并将它解释为“数组大小”，然后开始多次调用析构函数，浑然不知它所处理的那块内存不但不是个数组，也或许并未持有它正忙着销毁的那种类型的对象</li>
<li>如果没有对stringPtr2使用“delete []”形式，结果亦未定义，但可以猜想可能导致太少的析构函数被调用。犹有进者，这对内置类型如int者亦未定义，即使这类类型并没有析构函数</li>
</ul>
<p>因此，<strong>如果调用new时使用了[]，必须在对应调用delete时也使用[]；如果调用new时没使用[]，那么也不该在对应调用delete时使用[]</strong></p>
<p>这点在typedef中尤其需要注意：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> std::string AddressLines[<span class="hljs-number">4</span>];        <span class="hljs-comment">//每个人的地址有4行，每行是一个string</span><br><br>std::string *pa1 = <span class="hljs-keyword">new</span> AddressLines;        <span class="hljs-comment">//就像new string[4]一样</span><br><br><span class="hljs-keyword">delete</span> pa1;             <span class="hljs-comment">//错误！行为未定义</span><br><span class="hljs-keyword">delete</span> [] pa1;          <span class="hljs-comment">//很好</span><br></code></pre></td></tr></table></figure>

<p>为避免这类错误，最好尽量不要对数组形式做typedef动作</p>
<h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><p>考虑如下情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">func1</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类),<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure>

<p>在调用func1之前，编译器必须创建代码，做以下3件事</p>
<ul>
<li>执行func2</li>
<li>执行”new 原始资源类”创建一个原始资源</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>但是执行顺序弹性很大。如果执行顺序如下；</p>
<ol>
<li>执行”new 原始资源类”创建一个原始资源</li>
<li>执行func2</li>
<li>调用tr1::shared_ptr构造函数</li>
</ol>
<p>现在，如果2发生异常，那么因为1创建的资源未被置入tr1::shared_ptr内，因此会发生内存泄露。也就是说，在“资源被创建”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰。因此，应该使用独立语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类) p;<br><br><span class="hljs-built_in">func1</span>(p,<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure>





<h1 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四.设计与声明"></a>四.设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><ol>
<li><p>通过引入新类型来防止误用</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span></span>&#123;<br>public:<br>    Date(<span class="hljs-keyword">int</span> month,<span class="hljs-keyword">int</span> day,<span class="hljs-keyword">int</span> year);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面日期类的构造函数中，年月日都是int，那么很容易传入顺序错误的参数。因此，可以因为3个表示年月日的新类：Year、Month、Day。从而防止这种问题。更进一步，为了使得传入的数据有效，比如月份，可以设计生成12个月份对象的static成员函数，并将构造函数声明为explicit强制要求通过调用static成员函数得到月份对象。使用enums没有那么安全，enums可被拿来当作一个ints使用</p>
</li>
<li><p><strong>除非有好的理由，否则应该尽量让你的type的行为与内置类型一致</strong>：如<code>if(a * b = c)</code>对内置类型来说不合法，那么你的type在实现operator*时就应该返回一个const对象</p>
</li>
<li><p><strong>提供一致的接口</strong>：如C++ STL容器都提供size()返回容器大小，但是Java和.Net对于不同容器大小接口可能不同，这会增加使用负担</p>
</li>
<li><p><strong>返回“资源管理对象”而不是原始资源</strong>：如用shared_ptr管理资源时，客户可能会忘记使用智能指针，从而开启了忘记释放和重复释放的大门。通过修改接口的返回类型为智能指针，从而确保元素资源处于“资源管理对象”的掌控之中</p>
</li>
</ol>
<h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><p>在设计class时，下列问题将导致class你的设计规范：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新type的对象如果被passed by value，意味着什么？</li>
<li>什么是新type的“合法值”？</li>
<li>你的新type需要配合某个继承体系吗？</li>
<li>你的新type需要什么样的转换？</li>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新type的成员？</li>
<li>什么是新type的“未声明接口”？</li>
<li>你的新type有多么一般化？</li>
<li>你真的需要一个新type吗？</li>
</ul>
<h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><p>pass-by-reference-to-const有下列好处：</p>
<ul>
<li><strong>更高的效率</strong>：如果一个类处于继承体系的底部，并且包含大量成员，pass-by-value会导致大量的构造函数被调用，在函数调用完成后，又有大量的析构函数被调用</li>
<li><strong>防止继承中的对象切割</strong>：如果是pass-by-value，并且传入一个子类对象时，传入的子类对象会被切割，只保有基类对象的部分，从而无法表现多态</li>
</ul>
<p>references往往以指针实现出来，因此pass by reference通常意味真正传递的是指针。因此，对于<strong>内置类型</strong>，pass by value往往比pass by reference的效率更高。pass by value同样适用于<strong>STL的迭代器</strong>和<strong>函数对象</strong></p>
<p>并不是所有小型对象都是pass-by-value的合格候选者：</p>
<ul>
<li>对象小并不意味着copy构造函数不昂贵。许多对象——包括大多数STL容器——内含的东西比一个指针多一些，但是复制这种对象却需承担“复制那些指针所指的每一样东西”。那将非常昂贵</li>
<li>即使copy构造函数不昂贵，还是可能有效率上的争议。某些编译器对待“内置类型”和“用户自定义类型”的态度截然不同，纵使两者拥有相同的底层表述，“用户自定义类型”也不会被编译器放入缓存器，因此pass by reference更适合</li>
</ul>
<blockquote>
<p>可以合理假设“pass-by-value并不昂贵”的唯一对象就是内置类型和STL的迭代器和函数对象。其它任何时候，宁以pass-by-reference-to-const替换pass-by-value</p>
</blockquote>
<h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p>必须返回对象的最常见例子是运算符函数：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs);<br></code></pre></td></tr></table></figure>

<p>在必须返回对象时，不要企图返回reference，可以通过反面来说，也就是如果返回reference会是什么情况？</p>
<ul>
<li><p>使用stack构造一个局部对象，返回局部对象的reference</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span>&amp; operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs)<br>&#123;<br>    <span class="hljs-built_in">Rational</span> result(lhs.n * rhs.n,lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意！使用reference的本意是避免构造新对象，但是一个新的对象result还是经由构造函数构造。更严重的是，这个局部对象在函数调用完成后就被销毁了，reference将指向一个被销毁的对象</p>
</li>
<li><p>使用heap构造一个局部对象，返回这个对象的reference</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span>&amp; operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs)<br>&#123;<br>    <span class="hljs-built_in">Rational</span> *result = new <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> *result;<br>&#125;<br><span class="hljs-built_in">Rational</span> w,x,y,z;<br>w = x * y *z;<br></code></pre></td></tr></table></figure>

<p>这样虽然reference不再引用一个被销毁的对象，但是因为了动态内存分配的开销，而且谁该为delete负责也成为问题。同时，在上面的连乘例子中，会多次动态分配内存，但是只返回最后一次的指针，因此会造成资源泄露</p>
</li>
<li><p>构造一个static局部对象，每次计算结果保存在这个对象中，返回其reference</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-type">Rational</span>&amp; operator*(<span class="hljs-keyword">const</span> <span class="hljs-type">Rational</span> &amp;lhs,<span class="hljs-keyword">const</span> <span class="hljs-type">Rational</span> &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Rational</span> <span class="hljs-built_in">result</span><br>    <span class="hljs-built_in">result</span> = ...;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br><span class="hljs-type">Rational</span> w,x,y,z;<br><span class="hljs-keyword">if</span>((w * x) == (y * z))<span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure>

<p>首先，显而易见的问题是这个函数在多线程情况下是不安全的，多个线程会修改相同的static对象；除此之外，在上面的if判断中，不管传入的w,x,y,z是什么，由于operator*传回的reference都指向同一个static对象，因此上面的判断永远都会为true</p>
</li>
</ul>
<h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><h3 id="1）为什么不能是public"><a href="#1）为什么不能是public" class="headerlink" title="1）为什么不能是public"></a>1）为什么不能是public</h3><p>3个原因：</p>
<ol>
<li><p><strong>语法一致性</strong>：如果成员变量和成员函数一样，都是public，那么调用时会困惑于该不该使用括号。如果想获取大小时使用size，但是这到底是一个成员变量还是一个成员函数？</p>
</li>
<li><p>更精准的控制</p>
<p>：通过将成员变量声明为private，通过成员函数提供访问，可以实现更精准的访问控制</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessLevels</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getReadOnly</span>() <span class="hljs-keyword">const</span></span>   &#123;<span class="hljs-keyword">return</span> readOnly;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setReadWrite</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span>    &#123;readWrite = <span class="hljs-keyword">value</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getReadWrite</span>() <span class="hljs-keyword">const</span></span>    &#123;<span class="hljs-keyword">return</span> readWrite;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setWriteOnly</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span>    &#123;writeOnly = <span class="hljs-keyword">value</span>;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">int</span> noAccess;   <span class="hljs-comment">//对此int无访问动作</span><br>    <span class="hljs-built_in">int</span> readOnly;   <span class="hljs-comment">//对此int做只读访问</span><br>    <span class="hljs-built_in">int</span> readWrite;  <span class="hljs-comment">//对此int做读写访问</span><br>    <span class="hljs-built_in">int</span> writeOnly;  <span class="hljs-comment">//对此int做只写访问</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>封装(主要)</strong>：private将成员变量封装，如果通过public暴露，在需要改成员变量的大量实现代码中，会直接使用当这个成员变量被修改或删除时，所有直接访问该成员变量的代码将会变得不可用</p>
</li>
</ol>
<h3 id="2）那么protected行不行"><a href="#2）那么protected行不行" class="headerlink" title="2）那么protected行不行"></a>2）那么protected行不行</h3><p>protected成员变量和public成员变量的论点十分相同。“语法一致性”和“细微划分的访问控制”等理由也适用于protected数据。同时，protected也并不具备良好的封装性</p>
<p>假设有一个public成员变量，而我们最终取消了它。所以使用它的客户代码都会被破坏。因此，public成员变量完全没有封装性。假设有一个protected变量，而我们最终取消了它，所有使用它的派生类都会被破坏。因此，protected成员变量也缺乏封装性</p>
<p>因此，从封装的角度看，只有private能提供封装性</p>
<h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p>假设有个浏览器类，包含一些功能用来清除下载元素高速缓冲区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearCache</span>()</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearCookies</span>()</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearHistory</span>()</span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>此时，如果想整个执行所有这些动作，那么有两种选择，一种实现成member函数，一种实现成non-member函数：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">class WebBrowser&#123;<br>public:<br>  //实现成成员函数，能访问private成员<br>  void <span class="hljs-built_in">clearEverything</span>()&#123;<br>    <span class="hljs-built_in">clearCache</span>();<br>    <span class="hljs-built_in">clearCookies</span>();<br>    <span class="hljs-built_in">clearHistory</span>();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//或者实现成非成员函数，不能访问private成员</span><br>void <span class="hljs-built_in">clearEverything</span>(WebBrowser&amp; wb)&#123;<br>  wb<span class="hljs-selector-class">.clearCache</span>();<br>  wb<span class="hljs-selector-class">.clearCookies</span>();<br>  wb<span class="hljs-selector-class">.clearHistory</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题是应该如何选择？这个问题主要在于<strong>封装性</strong></p>
<p>如果某些东西被封装，它就不再可见。越多东西被封装，越少人可以看到它。越少人看到它，就有越大的弹性去变化它，因为我们的改变仅仅直接影响看到改变的那些人事物</p>
<p>因此，对于对象内的代码。越少代码可以看到数据（也就是访问它），越多的数据可被封装，我们也就越能自由地改变对象数据。作为一种粗糙的测量，越多函数可访问它，数据的封装性就越低</p>
<p>条款22所说，成员变量应该是private。能够访问private成员变量的函数只有class的member函数加上friend函数而已。<strong>如果要在一个member函数和一个non-member，non-friend函数之间做选择，而且两者提供相同机能，那么，导致较大封装性的是non-member，non-friend函数</strong>，也就是本条款这样选择的原因</p>
<p>一个扩展性的问题是——这些non-member，non-friend函数应该实现于何处?</p>
<p>一个像WebBrowser这样的class可能拥有大量便利函数，某些与书签有关，某些与打印有关，还有一些与cookie的管理有关…通常客户只对其中某些感兴趣。没道理一个只对书签相关便利函数感兴趣的客户却与一个cookie相关便利函数发生编译相依关系。分离它们的最直接做法就是将书签相关便利函数声明于一个头文件，将cookie相关便利函数声明于另一个头文件，再将打印相关…以此类推：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-1.png"><img src="/../images/cppeffective-4-1.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这正是C++标准库的组织方式。标准库并不是拥有单一、整体、庞大的&lt;C++StandardLibrary&gt;头文件并在其中内含std命名空间内的每一样东西，而是有数十个头文件（<vector>,<algorithm>,…），每个头文件声明std的某些机能。客户可以根据需要使用的机能选择性的包含头文件</p>
<h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>为class支持隐式类型转换不是个好主意，但是在数值类型之间颇为合理。考虑有理数和内置整形之间的相乘运算。具有如下有理数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>); <span class="hljs-comment">//构造函数刻意不为explicit，提供了Int-to-Rational的隐式转换</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">//分子的访问函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//分母的访问函数</span><br><span class="hljs-keyword">private</span>:<br>...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在，有理数提供了Int-to-Rational的隐式转换方式，那么operator*应该实现成member，还是non-member？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-comment">//实现为member</span><br>    <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span>;<br>&#125;<br><br><span class="hljs-comment">//实现为non-member</span><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure>

<p>问题发生在混合运算上。如果实现成member，那么下面的混合运算只有一半行得通：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">result = oneHalf * <span class="hljs-number">2</span>;                  <span class="hljs-comment">// OK</span><br>result = <span class="hljs-number">2</span> * oneHalf;                  <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure>

<p>因为内置类型int并没有相应的class，也就没有operator*成员函数。所以后者会出错。但是当实现为non-member时，具有2个参数，都能通过int转换为Rational，所以上面2行代码都能运行。因此，若所有参数皆需类型转换，请为此采用non-member函数</p>
<h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p>”以指针指向一个对象，内含真正数据“。这种设计的常见表现形式是所谓的”pimpl手法“。如下，WidgetImpl包含了Widget的真正数据，而Widget只包含一个WidgetImpl类型的指针，指向一个WidgetImpl对象。这种设计特点，决定了Widget的copying行为应该表现出一种”深拷贝“的行为：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-2.png"><img src="/../images/cppeffective-4-2.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>因此，如果使用标准库的swap交换2个Widget对象，会引起WidgetImpl对象的拷贝，由于其内含有Widget的大量数据，因此效率可能十分低。实际上这种情况下，交换2个指针就可以了。为此，我们可能实现出下图右边中间的swap特化版来提升效率，但是由于其内直接访问Widget的private成员，因此无法通过编译。所以我们采用下图右下角的方案，在Widget类内实现一个public的swap函数，然后特化版的swap调用这个public的swap函数：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-3.png"><img src="/../images/cppeffective-4-3.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>当问题更进一步发展时，即Widget和WidgetImpl为class template时，可能会将相同的思想迁移过来，实现出下图右边左上角的偏特化版本。但是问题是：<strong>C++只允许偏特化class template，而不允许偏特化function template</strong>。所以行不通，因此可以使用下图右下角的重载方式，但是<strong>客户可以全特化std内的模板，但是不能添加新的模板到std内</strong>，因此正确的做法是下图左下角</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-4-4.png"><img src="/../images/cppeffective-4-4.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>总结起来就是：</p>
<ul>
<li>首先，如果swap的缺省实现对你的class或class template提供可接受的效率，那不需要做额外的事</li>
<li>否则，如果swap的缺省实现效率不足（那几乎总是意味着你的class或template使用了某种pimpl手法），试着做以下事情：<ul>
<li>提供一个public swap成员函数，让它高效地置换你的类型的两个对象的值（<strong>这个public swap成员函数绝不应该抛出异常。这个约束不可施行于非成员版，因为swap缺省版是以copy构造函数和copy assignment操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定义版本的swap，往往提供的不只是高效置换对象值的方法，而且不抛出异常。一般而言这两个swap特性是连在一起的，因为高效的swap几乎总是基于对内置类型的操作，而内置类型上的操作绝对不会抛出异常</strong>）</li>
<li>在你的class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数</li>
<li>如果你正编写一个class（而非class template），为你的class特化std::swap。并令它先调用你的swap成员函数</li>
</ul>
</li>
<li>最后，如果你调用swap，请确定包含一个using声明，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符地调用swap</li>
</ul>
<h1 id="五-实现"><a href="#五-实现" class="headerlink" title="五.实现"></a>五.实现</h1><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>只要定义了一个变量而其类型带有一个构造函数或析构函数，那么</p>
<ul>
<li>当程序的控制流到达这个变量定义式时，你便得承受构造成本</li>
<li>当这个变量离开作用域时，你便得承受析构成本</li>
</ul>
<p>即使这个变量最终并未被使用，仍需耗费这些成本，所以你应尽可能避免这种情形，即延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止</p>
<p>当考虑循环时，有下列2种情况：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-5-1.png"><img src="/../images/cppeffective-5-1.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>2种写法的成本如下；</p>
<ul>
<li>做法A：1个构造函数 + 1个析构函数 + n个赋值操作</li>
<li>做法B：n个构造函数 + n个析构函数</li>
</ul>
<p><strong>从效率上看</strong>：如果class的一个赋值成本低于一组构成+析构成本，做法A大体而言比较高效，尤其当n比较大时。否则做法B或许更好</p>
<p><strong>从可理解性和维护性上看</strong>：A造成名称w的作用域比做法B更大，可理解性和维护性相对较差</p>
<p>因此，除非</p>
<ol>
<li>你知道赋值成本比”构造 + 析构“成本低</li>
<li>你正在处理代码中效率高度敏感的部分</li>
</ol>
<p>否则，应该使用做法B</p>
<h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>转型分类：</p>
<ul>
<li><p>C风格的转型</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-punctuation">(</span><span class="hljs-built_in">T</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">expression</span>   <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将<span class="hljs-built_in">expression</span>转型为<span class="hljs-built_in">T</span><br><span class="hljs-built_in">T</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span>   <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将<span class="hljs-built_in">expression</span>转型为<span class="hljs-built_in">T</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>C++提供的新式转型</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs r">const_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br>dynamic_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br>reinterpret_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br>static_cast<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">expression</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>static_cast</strong>：只要不包含底层const，都可以使用。适合将较大算术类型转换成较小算术类型</li>
<li><strong>const_cast</strong>：只能改变底层const，例如指向const的指针(指向的对象不一定是常量，但是无法通过指针修改)，如果指向的对象是常量，则这种转换在修改对象时，结果未定义</li>
<li><strong>reinterpret_cast</strong>：通常为算术对象的位模式提供较低层次上的重新解释。如将int<em>转换成char</em>。很危险！</li>
<li><strong>dynamic_cast</strong>：一种动态类型识别。转换的目标类型，即type，是指针或者左右值引用，主要用于基类指针转换成派生类类型的指针(或引用)，通常需要知道转换源和转换目标的类型。如果转换失败，返回0（转换目标类型为指针类型时）或抛出bad_cast异常（转换目标类型为引用类型时）</li>
</ul>
</li>
</ul>
<p>应该尽可能使用新式转型：</p>
<ol>
<li>它们很容易在代码中被辨别出来（无论是人工还是使用工具如grep），因而得以简化”找出类型系统在哪个地点被破坏“的过程</li>
<li>各转型动作的目标越窄化，编译器越可能诊断出错误的运用</li>
</ol>
<p><strong>尽量少做转型</strong>：</p>
<ol>
<li><p>转型不只是告诉编译器把某种类型视为另一种类型这么简单。任何一个转型动作往往令编译器编译出运行期间执行的代码</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim">//示例一<br><span class="hljs-type">int</span> x,y;<br>...<br>double d = static_cast&lt;double&gt;(x)/y;<br>//示例二<br>class <span class="hljs-type">Base</span> <span class="hljs-meta">&#123;...&#125;</span>;<br>class <span class="hljs-type">Derived</span> : public <span class="hljs-type">Base</span> <span class="hljs-meta">&#123;...&#125;</span>;<br><span class="hljs-type">Derived</span> d;<br><span class="hljs-type">Base</span> *pd = &amp;d;  //隐式地将<span class="hljs-type">Derived</span>*转换为<span class="hljs-type">Base</span>*<br></code></pre></td></tr></table></figure>

<ul>
<li>在示例一中：int转型为double几乎肯定会产生一些代码，因为在大部分体系结构中，int的底层表述不同于double的底层表述</li>
<li>在示例二中：会有个偏移量在运行期被实施于Derived<em>指针身上，用以取得正确的Base</em>地址</li>
</ul>
</li>
<li><p>很容易写出似是而非的代码</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    virtual <span class="hljs-built_in">void</span> onResize() &#123;...&#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//错误的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">SpecialWindow: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    virtual <span class="hljs-built_in">void</span> onResize()&#123;<br>        static_cast&lt;Window&gt;(*<span class="hljs-keyword">this</span>).onResize();  <br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//正确的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">SpecialWindow: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    virtual <span class="hljs-built_in">void</span> onResize()&#123;<br>        Window::onResize();  <span class="hljs-comment">//调用Window::onResize作用于*this身上</span><br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的例子中，派生类的虚函数可能希望调用基类虚函数的版本执行一些固定操作，然后再执行一些专属行为。在前面的做法中，转型并非在当前对象身上调用Window::onResize之后又在该对象身上执行SpecialWindow专属动作。而是在”当前对象的base class成分“的副本上调用Window::onResize，然后在当前对象身上执行SpecialWindow专属动作。如果Window::onResize修改了对象内容，当前对象其实没被改的，改的是副本。如果专属动作也修改对象，那么当前对象会进入一种”伤残“状态：其base class成分的更改没有落实，derived class成分的更改倒是落实了</p>
</li>
<li><p>继承中的类型转换效率低</p>
<ul>
<li>C++通过dynamic_cast实现继承中的类型转换，dynamic_cast的大多数实现效率都是相当慢的。因此，应该避免继承中的类型转换。一般需要dynamic_cast，通常是因为想在一个认定为derived class对象身上执行derived class操作，但是拥有的是一个”指向base“的指针或引用。这种情况下有2种办法可以避免转型：<ul>
<li><strong>使用容器并在其中存储直接指向derived class对象的指针</strong>：这种做法无法在同一个容器内存储指针”指向所有可能的各种派生类“。如果真要处理多种类型，可能需要多个容器，它们都必须具备类型安全性</li>
<li><strong>将derived class中的操作上升到base class内，成为virtual函数，base class提供一份缺省实现</strong>：缺省实现代码可能是个馊主意，条款34中有分析，但是也比使用dynamic_cast来转型要好</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h2><blockquote>
<p>References、指针和迭代器统统都是所谓的handles</p>
</blockquote>
<h3 id="1）增加封装性"><a href="#1）增加封装性" class="headerlink" title="1）增加封装性"></a>1）增加封装性</h3><p>如果成员函数返回handles，那么相当于成员变量的封装性从private上升到public。这与<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE22%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate">条款22</a>相悖</p>
<h3 id="2）使得“通过const修改对象的数据”成为可能"><a href="#2）使得“通过const修改对象的数据”成为可能" class="headerlink" title="2）使得“通过const修改对象的数据”成为可能"></a>2）使得“通过const修改对象的数据”成为可能</h3><p>在<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>提到过”pimpl手法“，即：“以指针指向一个对象，内含真正数据”，也就是对象只包含指针成员，实际数据通过这个指针指向。而在<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE03%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const">条款3</a>中也提到，C++对const成员函数的要求是，符合bitwise constness。因此，const成员函数返回一个这个指针所指对象的引用，并不会造成指针被修改，也就符合bitwise constness，但是通过这个引用却可以改变对象实际的数据</p>
<h3 id="3）防止“虚吊”-dangle-发生"><a href="#3）防止“虚吊”-dangle-发生" class="headerlink" title="3）防止“虚吊”(dangle)发生"></a>3）防止“虚吊”(dangle)发生</h3><p>如果返回的handles指向一个临时对象，那么返回后临时对象销毁，handles会成为“虚吊的”。只要handle被传出去，就会面临“handle比其所指对象更长寿”的风险</p>
<h2 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h2><p>考虑下面例子，有一个菜单类，changeBg函数可以改变它的背景，切换背景计数，同时提供线程安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    Mutex mutex;            <span class="hljs-comment">//提供多线程互斥访问</span><br>    Image *bg;          <span class="hljs-comment">//背景图片</span><br>    <span class="hljs-type">int</span> changeCount;    <span class="hljs-comment">//切换背景计数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBg</span><span class="hljs-params">(istream&amp; sr)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-built_in">lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">delete</span> bg;<br>    ++changeCount;<br>    bg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src);<br>    <span class="hljs-built_in">unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1）异常安全的2个条件"><a href="#1）异常安全的2个条件" class="headerlink" title="1）异常安全的2个条件"></a>1）异常安全的2个条件</h3><p><strong>异常安全有2个条件</strong>：</p>
<ol>
<li><strong>不泄露任何资源</strong>：即发生异常时，异常发生之前获得的资源都应该释放，不会因为异常而泄露。在上面的例子中，如果new Image发生异常，那么unlock就不会调用，因此锁资源会泄露</li>
<li><strong>不允许数据败坏</strong>：上面的例子也不符合，如果new Image异常，背景图片会被删除，计数也会改变。但是新背景并未设置成功</li>
</ol>
<p><strong>对于资源泄露</strong>，<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B">条款13</a>讨论过以对象管理资源。锁资源也可以为shared_ptr指定“删除器”，当引用为0时，即异常发生，管理所资源的对象被销毁后，删除器会调用unlock</p>
<p><strong>对于数据败坏</strong>：见下文</p>
<h3 id="2）异常安全函数的3个保证"><a href="#2）异常安全函数的3个保证" class="headerlink" title="2）异常安全函数的3个保证"></a>2）异常安全函数的3个保证</h3><ol>
<li><strong>基本承诺</strong>：抛出异常后，对象仍然处于合法（valid）的状态。但不确定处于哪个状态（对于前面的例子，如果发生异常，PrettyMenu可以继续拥有原背景图像，或是令它拥有某个“缺省”的背景图像，但客户无法确定）</li>
<li><strong>强烈保证</strong>：如果抛出了异常，状态并不会发生发生任何改变。就像没调用这个函数一样</li>
<li><strong>不抛掷保证</strong>：这是最强的保证，函数总是能完成它所承诺的事情（作用于内置类型身上的所有操作都提供nothrow保证。这是异常安全代码中一个必不可少的关键基础）</li>
</ol>
<p>对于前面的PrettyMenu对象，可以通过使用智能指针，以及重排changeBg的语句顺序来满足“强烈保证”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    shared_ptr&lt;Image&gt; bg;<br>    ...<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;    <span class="hljs-comment">//Lock以对象管理资源</span><br>    bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src));<br>    ++changeCount;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，上述实现只能为PrettyMenu对象提供“强烈保证”，不能提供完美（即全局状态）的“强烈保证”。比如Image构造函数中移动了istream&amp; src的读指针然后再抛出异常，那么系统还是处于一个被改变的状态。 这是一种对整个系统的副作用，类似的副作用还包括数据库操作，因为没有通用的办法可以撤销数据库操作。 不过这一点可以忽略，我们暂且认为它提供了完美的强烈保证</p>
<p><strong>copy and swap策略</strong></p>
<p>“copy and swap”设计策略通常能够<strong>为对象</strong>提供异常安全的“强烈保证”。当我们要改变一个对象时，先把它复制一份，然后去修改它的副本，改好了再与原对象交换。关于swap的详细讨论可以参见<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>。这种策略用在前面的例子中会像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Mutex mutex;<br>    std::shared_ptr&lt;MenuImpl&gt; pImpl;<br>&#125;;<br>Menu::<span class="hljs-built_in">changeBg</span>(std::istream&amp; src)&#123;<br>    <span class="hljs-keyword">using</span> std::swap;            <span class="hljs-comment">// 见 Item 25</span><br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;            <span class="hljs-comment">// 获得mutex的副本数据</span><br><br>    <span class="hljs-function">std::shared_ptr&lt;MenuImpl&gt; <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MenuImpl(*pImpl))</span></span>;<br>    copy-&gt;bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src)); <span class="hljs-comment">//修改副本数据</span><br>    ++copy-&gt;changeCount;<br><br>    <span class="hljs-built_in">swap</span>(pImpl, copy);              <span class="hljs-comment">//置换数据，释放mutex</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>copy and swap策略能够<strong>为对象</strong>提供异常安全的“强烈保证”。但是一般而言，它并不保证整个函数有“强烈保证”。也就是说，如果某个函数使用copy and swap策略为某个对象提供了异常安全的“强烈保证”。但是这个函数可能调用其它函数，而这些函数可能改变一些全局状态（如数据库状态），那么”整个函数“就不是”强烈保证“</p>
<blockquote>
<p>函数提供的”异常安全保证“通常最高只等于其所调用的各个函数的”异常安全保证“中的最弱者</p>
</blockquote>
<p>除此之外，copy and swap必须为每一个即将被改动的对象作出一个副本，从而可能造成时间和空间上的问题</p>
<h3 id="3）最终目标是什么"><a href="#3）最终目标是什么" class="headerlink" title="3）最终目标是什么"></a>3）最终目标是什么</h3><p>当”强烈保证“不切实际时（比如前面提到的全局状态改变难以保证，或者效率问题），就必须提供”基本保证“。现实中你或许会发现，可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。只要你曾经付出适当的心力试图提供强烈保证，万一实际不可行，使你退而求其次地只提供基本保证，任何人都不该因此责难你。对许多函数而言，”异常安全性的基本保证“是一个绝对同情达理的选择</p>
<p>总的来说就是，应该为自己的函数努力实现尽可能高级别的异常安全，但是由于种种原因并不是说一定需要实现最高级别的异常安全，而是应该以此为目标而努力</p>
<h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><strong>inline的优劣</strong>：</p>
<ul>
<li><p>优</p>
<p>：</p>
<ul>
<li><strong>较少函数调用的开销</strong></li>
<li><strong>编译器对inline的优化</strong></li>
</ul>
</li>
<li><p>劣</p>
<p>：</p>
<ul>
<li><strong>目标代码的增加，程序体积增大，导致额外的换页行为，降低指令高速缓存装置的命中率</strong></li>
</ul>
</li>
</ul>
<p>inline提出方式包括2种：1）显式提出；2）隐式提出（类内实现成员函数）</p>
<p>inline在大多数C++程序中是<strong>编译期行为</strong>。inline只是对编译器的一个申请，不是强制命令。大多数编译器提供了一个诊断级别：如果它们无法将你要求的函数inline化，会给出一个警告</p>
<p><strong>对virtual函数的调用也都会使inlining落空。因为virtual意味着”等待，直到运行期才确定调用哪个函数“，而inline意味着”执行前，先将调用动作替换为被调用函数的本体</strong>“</p>
<p>如果程序要取某个inline函数的地址，编译器通常必须为此函数生成一个outlined函数本体。毕竟编译器没有能力提出一个指针指向并不存在的函数</p>
<p><strong>构造函数和析构函数往往是inlining的糟糕候选人</strong>。C++对于”对象被创建和被销毁时发生什么事“做了各式各样的保证。在对象构造期间如果抛出异常，该对象已经构造好的部分会被自动销毁…，因此，对于下列代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string bm1,bm2;    <span class="hljs-comment">//base成员1和2</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()  &#123;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string dm1,dm2,dm3; <span class="hljs-comment">//derived成员1-3</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>虽然看上去Derived的构造函数为空，符合一个函数成为inline的的特性。但是为了确保C++对于”对象被创建和被销毁时发生什么事“做出的各式各样的保证，编译器会在其中安插代码，因此实际的Derived构造函数可能是这个样子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">Derived::<span class="hljs-built_in">Derived</span>()<br>&#123;<br>    Base::<span class="hljs-built_in">Base</span>();<br>    <span class="hljs-keyword">try</span>&#123;dm<span class="hljs-number">1.</span>std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm<span class="hljs-number">2.</span>std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm<span class="hljs-number">1.</span>std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm<span class="hljs-number">3.</span>std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm<span class="hljs-number">2.</span>std::string::~<span class="hljs-built_in">string</span>();<br>        dm<span class="hljs-number">1.</span>std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大部分的调试器面对inline函数都束手无策。因为无法在一个不存在的函数内设立断点。因此，一个合乎逻辑的策略是，一开始先不要将任何函数声明为inline，或至少将inlining施行范围局限在那些“一定称为inline”或“十分平淡无奇”的函数身上</p>
<h2 id="条款31：将文件间的编译依存关系将至最低"><a href="#条款31：将文件间的编译依存关系将至最低" class="headerlink" title="条款31：将文件间的编译依存关系将至最低"></a>条款31：将文件间的编译依存关系将至最低</h2><p>C++并没有把“将接口从实现中分离”这件事做得很好。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string theName;    <span class="hljs-comment">//实现细目</span><br>    Date    theBirthDate;   <span class="hljs-comment">//实现细目</span><br>    Address theAddress;     <span class="hljs-comment">//实现细目</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果没有前面3行引入头文件，那么编译无法通过。但是如此却<strong>会在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些文件所依赖的其它头文件有任何改变。那么每个含入Person class的文件就得重新编译，任何使用Person class的文件也必须重新编译</strong>。这样的连串编译依存关系会对许多项目造成难以形容的灾难</p>
<p>你可能会想着将实现细目分开：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>;   <span class="hljs-comment">//前置声明，但不正确</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;         <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;      <span class="hljs-comment">//前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果可以这么做，Person的客户就只需要在Person接口被修改过时才重新编译。但是这种想法存在2个问题：</p>
<ul>
<li><p>string并不是个class，它是个typedef，上述前置声明不正确，正确的前置声明比较复杂</p>
</li>
<li><p>重点是，</p>
<p>编译器必须在编译期间知道对象的大小</p>
<p>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;           <span class="hljs-comment">//定义一个int</span><br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(...)</span></span>;   <span class="hljs-comment">//定义一个Person</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这和Java，Smalltalk中不同，因为它们在定义对象时，编译器只分配足够空间给一个指针使用。也就是说，它们将上述代码视为这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;          <span class="hljs-comment">//定义一个int</span><br>    Person* p;      <span class="hljs-comment">//定义一个指针指向Person对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>1）一个办法是，可以把Person分割为两个类：1）一个只提供接口(Person)；2）一个负责实现接口(PersonImpl)；就是使用<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>中的”pimpl手法“：接口class中只包含一个负责实现接口的class的指针，因此任何改变都只是在负责实现接口的class中进行。那么Person的客户就完全与Date,Address,以及Person的实现细目分离了。那些classes的任何实现修改都不需要Person客户端重新编译。此外，由于客户无法看到Person的实现细目，也就不可能写出什么“取决于那些细目的代码”。这正是接口与实现分类。这种情况下，像Person这样使用pimpl的classes往往被称为handle classes</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string&amp; name);<br>    <span class="hljs-function">string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;;<br>Person::<span class="hljs-built_in">Person</span>(string&amp; name): <span class="hljs-built_in">pImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PersonImpl</span>(name))&#123;&#125;<br><span class="hljs-function">string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2）另一种制作Handle class的办法是，令Person成为一种特殊的abstract base class，称为interface class</strong>。其目的是详细描述derived classes的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">birthday</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>客户不能实例化它，只能使用它的引用和指针。然而客户一定需要某种方法来获得一个实例，比如工厂方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> shared_ptr&lt;Person&gt; <span class="hljs-title">create</span><span class="hljs-params">(string&amp; name)</span></span>;<br>&#125;;<br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">Person::create</span><span class="hljs-params">(string&amp; name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;Person&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealPerson</span>(name));<br>&#125;<br>...<br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">p</span><span class="hljs-params">(Person::create(<span class="hljs-string">&quot;alice&quot;</span>))</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>应该让头文件自我满足</strong>，万一做不到，则让它与其他头文件内的声明式相依。其他每一件事都源自于这个简单的设计策略：</p>
<ul>
<li><p><strong>如果使用object references或object pointers可以完成任务，就不要使用objects</strong></p>
</li>
<li><p>如果能够，尽量以class声明式替换class定义式</p>
<p>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>为声明式和定义式提供不同的头文件</p>
<p>。为了促使这个准则，需要两个头文件：一个用于声明式，一个用于定义式。因此，上面的例子应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;datefwd.h&quot;</span>    <span class="hljs-comment">//包含了class Date的声明</span></span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="六-继承与面向对象设计"><a href="#六-继承与面向对象设计" class="headerlink" title="六.继承与面向对象设计"></a>六.继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h2><p><strong>public隐含的寓意</strong>：每个派生类对象同时也是一个基类对象(反之不成立)，只不过基类比派生类表现出更一般化的概念，派生类比基类表现出更特殊化的概念。</p>
<p>可以举一个例子验证一下上面的说法。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;...&#125;;<br></code></pre></td></tr></table></figure>

<p>显然，每个学生都是人，但并非每个人都是学生。对人可以成立的每一件事对学生也都成立（例如每个人都有生日），但对学生都成立的每件事并不一定对每个人也成立(例如注册于某个学校)</p>
<p>因此，C++中，任何函数如果期望获得一个类型为基类的实参，都也愿意接收一个派生类对象。但是反之不成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student &amp;s)</span></span>;<br>Person p;<br>Student s;<br><span class="hljs-built_in">eat</span>(p);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">eat</span>(s);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(s);   <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(p);   <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure>

<p>谨记这种is-a关系以及背后隐藏的规则可以防止因为“经验主义”而使用不合理的继承：</p>
<ul>
<li>从“经验主义”上看，企鹅也是鸟，如果为鸟定义了虚拟(virtual)的飞的方法，然后企鹅类以public继承鸟类，那么是不合理的方式。这种情况下，可以设计一个会飞的鸟的类，虚拟(virtual)的飞的方法声明在这个类中，而鸟类里面没有声明飞的方法。或者根本不声明飞的方法</li>
<li>从“经验主义”上看，正方形也是长方形，如果长方形有成员方法会修改长或宽，那么正方形以public继承长方形就显得不合理</li>
</ul>
<p>软件世界不同于现实世界。对于上面的鸟的设计，某些软件系统可能不需要区分会飞的鸟和不会飞的鸟。那么即使鸟类声明了飞的方法，然后企鹅类以public继承，也不会有多大问题。也就是说，不存在一个适用于所有软件的设计。最佳的设计取决于系统希望做什么事。如果程序对飞行一无所知，而且也不打算未来对飞行有所知，那么不去区分会飞的鸟和不会飞的鸟不失为一个完美而有效的设计。实际上可能比对两者做出隔离的设计更受欢迎，因为这样的区隔在你企图塑模的世界中并不存在。因此，<strong>应该根据实际软件需求，合理使用public</strong></p>
<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><h3 id="1）继承中的作用域嵌套"><a href="#1）继承中的作用域嵌套" class="headerlink" title="1）继承中的作用域嵌套"></a>1）继承中的作用域嵌套</h3><p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-1.png"><img src="/../images/cppeffective-6-1.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>名字查找会从内层作用域向外层作用域延伸</p>
<h3 id="2）名称遮掩会遮掩基类所有重载版本"><a href="#2）名称遮掩会遮掩基类所有重载版本" class="headerlink" title="2）名称遮掩会遮掩基类所有重载版本"></a>2）名称遮掩会遮掩基类所有重载版本</h3><p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-2.png"><img src="/../images/cppeffective-6-2.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>派生类中同名的名称会遮掩基类中相同的名称，如果基类包含重载函数，所有重载函数都会被遮掩</p>
<p>解决办法是使用using引入被遮掩的名字：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-3.png"><img src="/../images/cppeffective-6-3.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>如果只想引入基类被遮掩函数中某个版本（注意，这种需求一般只在private继承中出现，因为如果只继承基类的部分操作，违背了<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE32%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB">条款32</a>），可以直接定义一个同名同参的函数，然后在这个函数内调用基类的版本，做一个转调用。这实际上称为一种实现技术(而不是引入)更为恰当：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-4.png"><img src="/../images/cppeffective-6-4.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><blockquote>
<p>纯虚函数一般作为接口，基类一般不提供定义，但是基类可以为纯虚函数提供定义。派生类必须声明纯虚函数，如果想要使用纯虚函数，派生类必须提供一份定义，即使基类已经为该纯虚函数提供了定义。如果派生类不提供定义，仍然是一个抽象基类</p>
</blockquote>
<ol>
<li><strong>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口</strong></li>
<li><strong>声明(非纯)impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现</strong></li>
<li><strong>声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现</strong></li>
</ol>
<h3 id="1）pure-virtual函数"><a href="#1）pure-virtual函数" class="headerlink" title="1）pure virtual函数"></a>1）pure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且没有相同的缺省实现，那么应该使用pure virtual函数，此时派生类只继承接口</p>
<h3 id="2）impure-virtual函数"><a href="#2）impure-virtual函数" class="headerlink" title="2）impure virtual函数"></a>2）impure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且具有相同的缺省实现，那么应该使用impure virtual函数，此时派生类继承接口和缺省实现</p>
<p><strong>但是，允许impure virtual函数同时指定函数声明和缺省行为，却可能造成危险：假设引入了一个新的派生类，但是缺省行为并不适用于新的派生类，而新的派生类忘记重新定义新的行为，那么调用该操作将表现出缺省行为，这是不合理的</strong></p>
<p>例如，某个航空公司有A,B两种类型的飞机，他们有相同的fly行为，这个fly行为在基类Airplane中声明为impure virtual函数，并且具有缺省的飞行实现。现在引入了一种新机型C，但是这个缺省的fly行为并不适合C，如果C忘记重新定义fly，那么它将按照A,B缺省的行为飞行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 缺省的fly代码</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br>Airplane* p = <span class="hljs-keyword">new</span> ModelC;<br>p-&gt;<span class="hljs-built_in">fly</span>();   <span class="hljs-comment">//调用Airplane::fly</span><br></code></pre></td></tr></table></figure>

<p>a）要避免这种错误，可以将fly改为pure virtual函数，并且将缺省的飞行行为实现为一个protected函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//这是合理的，因为它是Airplane及其derived classes的实现细目。乘客应该只在意飞机能不能飞，不在意它怎么飞</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">//non-virtual函数，因为没有任何一个派生类应该重新定义缺省行为</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFly</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，fly变成了pure virtual函数，首先，飞机C必须声明fly函数，如果需要使用，必须为其定义。那么就可以防止因为忘记重新定义而引起的错误</p>
<p>b）有些人反对以不同函数分别提供接口和缺省实现，像上面的fly和defaultFly。因为他们关心因过渡雷同函数名称而引起的class命名空间污染问题。那么可以将缺省的行为定义在fly中，即为fly实现一份缺省的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 缺省的fly代码</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        Airplane::<span class="hljs-built_in">fly</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由于任何派生类想要使用pure virtual函数都必须提供一份定义，那么如果想要使用缺省行为，可以直接在定义中转调用基类的实现。否则，可以定制特殊的行为。因为是纯虚函数，只要不定义就无法使用，因此也可以避免前面的问题</p>
<h3 id="3）non-virtual函数"><a href="#3）non-virtual函数" class="headerlink" title="3）non-virtual函数"></a>3）non-virtual函数</h3><p>如果某个操作在整个体系中，应该表现出一致的行为，那么应该使用non-virtual函数。此时派生类继承接口和一份强制性实现</p>
<h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><blockquote>
<p>在面向对象中，如果希望某个操作存在缺省算法，并且各派生类可以定制适合自己的操作。可以使用public virtual函数，这是最简单直白且容易想到的方法，但是除此之外，也存在其它可替代的方案。它们有各自的优缺点，应该将所有方案全部列入考入</p>
</blockquote>
<p>以一个例子来介绍其它几种可替代方案。在一个游戏人物的类中，存在一个健康值计算的函数，不同的角色可以提供不同的健康值计算方法，并且存在一个缺省实现。以传统的public virtual函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//健康值计算函数，派生类可以重新定义</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1）藉由Non-Virtual-Interface手法实现Template-Method模式"><a href="#1）藉由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="1）藉由Non-Virtual Interface手法实现Template Method模式"></a>1）藉由Non-Virtual Interface手法实现Template Method模式</h3><p>这种方案的主要思想是：保留healthValue为public成员，但是让其成为non-virtual，并调用一个private(也可以是protected) virtual函数进行实际工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...                             <span class="hljs-comment">//做一些事前工作</span><br>        <span class="hljs-type">int</span> retVal = <span class="hljs-built_in">doHealthValue</span>();   <span class="hljs-comment">//负责真正的健康值计算</span><br>        ...                             <span class="hljs-comment">//做一些事后工作</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">doHealthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-comment">//派生类可以重新定义</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...     <span class="hljs-comment">//缺省的健康值计算方法</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>NVI手法的一个优点是可以在真正操作进行的前后保证一些“事前”和“事后”工作一定会进行。如“事前”进行一些锁的分配，日志记录。“事后”进行解锁等操作</p>
<h3 id="2）藉由Function-Pointers实现Strategy模式"><a href="#2）藉由Function-Pointers实现Strategy模式" class="headerlink" title="2）藉由Function Pointers实现Strategy模式"></a>2）藉由Function Pointers实现Strategy模式</h3><p>上面的方案本质还是使用virtual函数，人物的健康值计算(操作)还是与人物(类)相关。后面这几种方案，都是将任务的健康值计算(操作)与具体的每个人(对象)相关，并且可以每个人(对象)的健康值计算(操作)可以修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*HealthCalcFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个人物(类)包含一个计算健康值的函数指针，每创建一个人(对象)时，可以为其指定不同的健康值计算函数。因此将操作和类分离。同时，如果提供修改函数指针成员的方法，每个对象还能使用不同的计算方法</p>
<h3 id="3）藉由tr1-function完成Strategy模式"><a href="#3）藉由tr1-function完成Strategy模式" class="headerlink" title="3）藉由tr1::function完成Strategy模式"></a>3）藉由tr1::function完成Strategy模式</h3><p>这种方案是前一种的加强，将函数指针改成任何可调用对象。因此允许任何与可调用声明相兼容(即可以通过类型转换与声明相符)的可调用物</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//现在，类型HealthCalcFunc从函数指针变成了可调用物</span><br>    <span class="hljs-keyword">typedef</span> std::tr1::function&lt;<span class="hljs-type">int</span> (<span class="hljs-type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="4）传统的Stategy模式"><a href="#4）传统的Stategy模式" class="headerlink" title="4）传统的Stategy模式"></a>4）传统的Stategy模式</h3><p>传统的Stategy模式做法会将健康计算函数做成一个分离的继承体系中的virtual成员函数，设计结果看起来像这样:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-5.png"><img src="/../images/cppeffective-6-5.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthCalcFunc</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">cacl</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span> <span class="hljs-type">const</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br><span class="hljs-comment">//创建一个HealthCalcFunc对象，可以通过它调用缺省的健康值计算方法</span><br>HealthCalcFunc defaultHealthCalc;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span> : pHealthCalc(phcf) &#123;</span>&#125;<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pHealthCalc-&gt;<span class="hljs-built_in">cacl</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc *pHealthCalc;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这个方案的吸引力在于，熟悉标准Strategy模式的人很容易辨认它，而且它还提供“将一个既有的健康算法纳入使用”的可能性——只要为HealthCalcFunc继承体系添加一个derived class即可</p>
<h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p>从规范上说，<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE34%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">条款34</a>提到，如果某个操作在整个继承体系应该是不变的，那么使用non-virtual函数，此时派生类从基类继承接口以及一份强制实现。如果派生类希望表现出不同行为，那么应该使用virtual函数</p>
<p>另一方面，假设真的重新定义了继承而来的non-virtual函数，会表现出下列令人困惑的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//重新定义了继承而来的non-virtual函数</span><br>&#125;;<br><br>D x;<br>B *pB = &amp;x;<br>D *pD = &amp;x;<br><br>pB-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用B::mf</span><br>pD-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用D::mf</span><br></code></pre></td></tr></table></figure>

<p>你可能会觉得因为pB和pD指向的是相同的对象，因此调用的non-virtual函数也应该相同，但是事实并非如此。因为<strong>non-virtual函数是静态绑定</strong>，因此实际上调用的函数由指针或引用决定</p>
<h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE36%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0">条款36</a>论述了non-virtual函数不应该被重新定义，那么non-virtual函数中的参数也就不存在被重新定义的机会。因此这里主要针对的是virtual函数</p>
<p><strong>原因就在于，virtual函数是动态绑定，而缺省参数值却是静态绑定</strong>。所以你可能调用了一个派生类的virtual函数，但是使用到的缺省参数，却是基类的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br>Rectangle r;<br>Circle c;<br><br>r.<span class="hljs-built_in">draw</span>();           <span class="hljs-comment">//调用Rectangle::draw，静态类型为Rectangle，所以缺省参数为Shape::Green</span><br><span class="hljs-comment">//c.draw();         //调用Circle::draw，静态类型为Circle，没有缺省参数，因此错误，必须显式指定！</span><br><br>Shape *pr = &amp;r;<br>Shape *pc = &amp;c;<br><br><span class="hljs-comment">//以下为容易引起困惑的地方，函数与参数不一致</span><br>pr-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Rectangle::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br>pc-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Shape::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br></code></pre></td></tr></table></figure>

<p>但是，即使派生类严格遵循基类的缺省参数，也存在问题：当基类的缺省参数发生变化时，派生类的所有缺省参数也需要跟着修改。因此，<strong>本质在于，不应该在virtual函数中使用缺省参数</strong>，如果有这样的需求，那么这种场景就适合使用<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#">条款35</a>中，public virtual函数的几种替代方案，比如NVI手法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-comment">//此时，带缺省参数的已经不是virtual函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">doDraw</span>(color);  <span class="hljs-comment">//调用一个virtual</span><br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//完成真正的工作</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h2><blockquote>
<p>复合是类型间的一种关系，当某种类型的对象含有另一种类型的对象，便是这种关系</p>
</blockquote>
<p>复合意味着has-a(有一个)或is-implemented-in-terms-of(根据某物实现出)</p>
<ul>
<li><p>has-a：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>    Address address;<br>    PhoneNumber voiceNumber;<br>    PhoneNumber faxNumber;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据某物实现出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> stack &#123;<br>...<br><span class="hljs-keyword">protected</span>:<br>  Sequence c;   <span class="hljs-comment">//底层容器</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>上面两者情况都应该使用复合，而不是public继承。在has-a中，每个人肯定不是一个地址，或者电话。显然不能是is-a的关系。而对于后者，由于每个栈只能从栈顶压入弹出元素，而队列不同，is-a的性质是所有对基类为true的操作，对派生类也应该为true。所以stack也不应该通过public继承deque来实现，因此使用复合</p>
<h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><p><strong>private继承和public继承的不同之处</strong>：</p>
<ul>
<li><p>编译器不会把子类对象转换为父类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">private</span> Person &#123; ... &#125;;     <span class="hljs-comment">// private继承</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span></span>;                 <span class="hljs-comment">// 任何人都会吃</span><br>Person p;                                  <span class="hljs-comment">// p是人</span><br>Student s;                                 <span class="hljs-comment">// s是学生</span><br><span class="hljs-built_in">eat</span>(p);                                    <span class="hljs-comment">// 没问题，p是人，会吃</span><br><span class="hljs-built_in">eat</span>(s);                                    <span class="hljs-comment">// 错误！难道学生不是人？！</span><br></code></pre></td></tr></table></figure>

<p>如果使用public继承，编译器在必要的时候可以将Student隐式转换成Person，但是private继承时不会，所以eat(s)调用失败。从这个例子中表达了，private继承并不表现出is-a的关系。实际上</p>
<p>private表现出的是”is-implemented-in-terms-of”的关系</p>
</li>
<li><p><strong>父类成员（即使是public、protected）都变成了private</strong></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE38%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA">条款38</a>提到，复合也是可以表现出”is-implemented-in-terms-of”的关系，那么两者有什么区别？</p>
<h3 id="1）private继承"><a href="#1）private继承" class="headerlink" title="1）private继承"></a>1）private继承</h3><p>假设Widget类需要执行周期性任务，于是希望继承Timer的实现。 因为Widget不是一个Timer，所以选择了private继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> tickFrequency)</span></span>;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <span class="hljs-comment">// 每滴答一次，该函数就被自动调用一次</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">private</span> Timer &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 查看Widget的数据...等等</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在Widget中重写虚函数onTick，使得Widget可以周期性地执行某个任务</p>
<p>通过private继承来表现”is-implemented-in-terms-of”关系实现非常简单，而且下列情况也只能使用这种方式：</p>
<ul>
<li>当Widget需要访问Timer的protected成员时。因为对象组合后只能访问public成员，而private继承后可以访问protected成员。</li>
<li>当Widget需要重写Timer的虚函数时。比如上面的例子中，需要重写onTick。单纯的复合是做不到的</li>
</ul>
<h3 id="2）复合"><a href="#2）复合" class="headerlink" title="2）复合"></a>2）复合</h3><p>如果使用复合，上面的例子可以这样实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetTimer</span>: <span class="hljs-keyword">public</span> Timer &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    &#125;;<br>    WidgetTimer timer;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>通过复合来表现”is-implemented-in-terms-of”关系，实现较为复杂，但是具有下列优点：</p>
<ul>
<li>如果希望禁止Widget的子类重定义onTick。因为派生类无法访问私有的WidgetTimer类</li>
<li>可以减小Widget和Timer的编译依赖。如果是private继承，在定义Widget的文件中势必需要引入#include”timer.h”。 但如果采用复合的方式，可以把WidgetTimer放到另一个文件中，在Widget中使用WidgetTimer*并声明WidgetTimer即可</li>
</ul>
<p>总的来说，在需要表现”is-implemented-in-terms-of”关系时。如果一个类需要访问基类的protected成员，或需要重新定义其一个或多个virtual函数，那么使用private继承。否则，在考虑过所有其它方案后，仍然认为private继承是最佳办法，才使用它</p>
<h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><p>使用多继承时，一个问题是不同基类可能具有相同名称，产生歧义（即使一个名字可访问，另一个不可访问）</p>
<p>一般有两种方式使用多继承：</p>
<ul>
<li><p>一般的多重继承</p>
<ul>
<li>如果某个基类到派生类之间存在多条路径，那么派生类会包含重复的基类成员</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-6.png"><img src="/../images/cppeffective-6-6.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>虚继承（此时基类是虚基类）</p>
<ul>
<li>如果某个基类到派生类之间存在多条路径，派生类只包含一份基类成员，但是这会带来额外开销<ul>
<li>为避免重复，编译器必须提供一些机制，后果就是virtual继承的那些classes所产生的对象往往比non-virtual继承的体积大，访问virtual base classes的成员变量时，速度也更慢</li>
<li>virtual base的初始化由继承体系中的最底层class负责，这会带来开销<ul>
<li>classes若派生自virtual bases而需要初始化，必须认知其virtual bases——无论那些bases距离多远</li>
<li>当一个新derived class加入继承体系中，它必须承担其virtual bases的初始化责任</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/pic/cppeffective-6-7.png"><img src="/../images/cppeffective-6-7.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
<p>如果你有一个单一继承的设计方案，而它大约等价于一个多重继承方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候是完成任务的最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。只要确定，你的确是在明智而审慎的情况下使用它</p>
<h1 id="七-模板与泛型编程"><a href="#七-模板与泛型编程" class="headerlink" title="七.模板与泛型编程"></a>七.模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译器多态"><a href="#条款41：了解隐式接口和编译器多态" class="headerlink" title="条款41：了解隐式接口和编译器多态"></a>条款41：了解隐式接口和编译器多态</h2><p>面向对象设计中的类（class）考虑的是显式接口（explicit interface）和运行时多态， 而模板编程中的<strong>模板（template）考虑的是隐式接口（implicit interface）和编译期多态</strong>。</p>
<ul>
<li>对类而言，显式接口是由函数签名表征的，运行时多态由虚函数实现</li>
<li>对模板而言，隐式接口是由表达式的合法性表征的，编译期多态由模板初始化和函数重载的解析实现</li>
</ul>
<h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p>以下代码中，typename和class等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br></code></pre></td></tr></table></figure>

<p>但是如果在template中，遇到嵌套从属名称，需要明确声明是一种类型时，必须使用typename。考虑如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们认为C::const_iterator表示容器C的迭代器类型，因此上述代码定义一个该迭代器类型的指针。但是这是一种先入为主的思想。如果C::const_iterator不是一个类型呢？比如恰巧有个static成员变量被命名为const_iterator，或如果x碰巧是个global变量名称？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作</p>
<p>因此，C++有个规则解决这种歧义：如果解析器在template中遭遇一个嵌套从属名称，它便假设这个名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。那么怎么告诉它是一个类型，当然就是typename了，所以上述代码应该像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typename</span> C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，<strong>规则是：除了下面2个例外，任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename：</strong></p>
<ol>
<li><strong>typename不可出现在base classes list内的嵌套从属名称之前</strong></li>
<li><strong>typename也不可出现在成员初始值列表中作为base class修饰符</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested&#123; <span class="hljs-comment">//typename不可出现在此</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">explict <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : Base&lt;T&gt;::Nested(x) //typename也不可出现在此</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;  <span class="hljs-comment">//这里必须使用typename</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>typename相关规则在不同的编译器上有不同的实践。某些编译器接收的代码原本该有typename却遗漏了；原本不该有typename却出现了；还有少数编译器（通常是较旧版本）根本就拒绝typename。这意味typename和“嵌套从属名称”之间的互动，也会在移植性方面给你带来一些麻烦</p>
<h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p>假设以下MsgSender类可以通过两种方式发送信息到各个公司：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//1.发送原始文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...<br>        Company c;<br>        c.<span class="hljs-built_in">sendCleartext</span>(...);   <br>    &#125;<br>    <span class="hljs-comment">//2.发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>假设我们有时候想要在每次送出信息时志记(log)某些信息。因此有了以下派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);             <span class="hljs-comment">//调用base class函数，无法通过编译</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在问题是，如果有一个公司CompanyZ只支持加密传送，那么泛化的MsgSender就不适合，因此需要为其产生一个特化版的MsgSender：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&lt;CompanyZ&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//只支持发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>因此，当base class被指定为MsgSender时，其内不包含sendClear方法，那么derived class LoggingMsgSender的sendClearMsg方法就会调用不存在sendClear</p>
<p><strong>因此，正是因为知道base class templates有可能被特化，而那么特化版本可能不提供和一般性template相同的接口。因此C++往往拒绝在templatized base classes（模板化基类，本例的MsgSender<Company>）内寻找继承而来的名称（本例的SendClear）</strong></p>
<p><strong>解决办法有3个，它们会通知编译器:进入base class作用域查找继承而来的名称</strong>：</p>
<ol>
<li><p>使用this-&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用using</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//告诉编译器，请它假设sendClear位于base class内</span><br>    <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通过作用域符明确指出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(...);  <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这种方法往往最不让人满意，因为如果被调用的是virtual函数，这样会关闭”virtual绑定行为“</p>
</li>
</ol>
<p>要注意的是，它们只是通知编译器进去查找。如果找到了自然是没问题。但是如同上面的CompanyZ，如果基类还是不存在相应名称，编译器还是会报错</p>
<h2 id="条款44：将与参数无关的代码抽离templates"><a href="#条款44：将与参数无关的代码抽离templates" class="headerlink" title="条款44：将与参数无关的代码抽离templates"></a>条款44：将与参数无关的代码抽离templates</h2><p>模板提供的是编译期的多态， 即使你的代码看起来非常简洁短小，生成的二进制文件也可能包含大量的冗余代码。 因为模板每次实例化都会生成一个完整的副本，所以其中与模板参数无关的部分会造成代码膨胀</p>
<p>把模板中参数无关的代码重构到模板外便可以有效地控制模板产生的代码膨胀：</p>
<ul>
<li><p>对于非类型模板参数产生的代码膨胀，用函数参数或成员变量来替换模板参数即可消除冗余</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//非类型模板参数造成代码膨胀</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//求逆矩阵</span><br>&#125;;<br><span class="hljs-comment">//以下会实例化两个类：Square&lt;double, 5&gt;和Square&lt;double, 10&gt;</span><br><span class="hljs-comment">//会具现化两份invert。除了常量5和10，两个函数的其它部分完全相同</span><br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">5</span>&gt; s1;<br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10</span>&gt; s2;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">invert</span>();<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">invert</span>();<br><span class="hljs-comment">//以下，使用函数参数消除重复</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareBase</span>&#123;<br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-comment">//以下函数只是作为避免代码重复的方法，并不应该被外界调用，</span><br>    <span class="hljs-comment">//同时，该函数希望被子类调用，因此使用protected</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>:<span class="hljs-keyword">private</span> SquareBase&lt;T&gt;&#123;<span class="hljs-comment">//只要T相同，都会使用同一份父类实例，</span><br><span class="hljs-keyword">private</span>:                           <span class="hljs-comment">//因此，只有一份invert(int size)</span><br>    <span class="hljs-keyword">using</span> SquareBase&lt;T&gt;::invert;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//调用父类invert的代价为零，因为Square::invert是隐式的inline函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后是父类如何访问矩阵数据。原本这些数据在派生类中，但是因为invert核心代码转移到了父类，那么父类必须有办法访问这些数据。可以在调用SquareBase::invert时把内存地址也一起告知父类，但如果矩阵类中有很多函数都需要这些信息就需要为每个函数添加一个这样的参数。因此，可以把数据地址直接放在父类中</p>
</li>
<li><p>对于类型模板参数产生的代码膨胀，可以让不同实例化的模板类共用同样的二进制表示</p>
<ul>
<li>int和long在多数平台都是一样的底层实现，然而模板却会实例化为两份，因为它们类型不同</li>
<li>List&lt;int <em>&gt;, List&lt;const int *&gt;, List&lt;double *&gt;的底层实现也是一样的。但因为指针类型不同，也会实例化为多份模板类 如果某些成员函数操作强型指针(T</em>)，应该令它们调用另一个操作无类型指针(void*)的函数，后者完成实际工作</li>
</ul>
</li>
</ul>
<h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>需要使用成员函数模板的一个例子是构造函数和copying赋值运算符。例如，假设SmartPtr是一种智能指针，并且它是一个template class。现在有一个继承体系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Top</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span> : <span class="hljs-keyword">public</span> Top &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span> : <span class="hljs-keyword">public</span> Middle &#123;...&#125;;<br></code></pre></td></tr></table></figure>

<p>现在希望通过一个SmartPtr<Bottom>或SmartPtr<Middle>来初始化一个SmartPtr<Top>。如果是指针，即Middle<em>和Bottom</em>可以隐式转换成Top*，问题是：<strong>同一个template的不同具现体之间不存在什么与生俱来的固有关系，即使具现体之间具有继承关系</strong>。因此，SmartPtr<Bottom>或SmartPtr<Middle>并不能隐式转化成SmartPtr<Top>。因此，我们需要一个构造函数模板，来实现这种转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数模板</span><br>    <span class="hljs-comment">//意思是：对任何类型T和任何类型U，可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt; &amp;other)</span></span><br><span class="hljs-function">     : heldPtr(other.get()) &#123;</span>...&#125;<br>    <span class="hljs-comment">//原始指针为private成员，需要一个接口来获取</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> heldPtr;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    T* heldPtr;   <span class="hljs-comment">//智能指针所持有的原始指针</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们当然不希望一个SmartPtr<Top>可以转化成SmartPtr<Bottom>或SmartPtr<Middle>， <code>heldPtr(other.get())</code>为次提供了保证。这个行为只有当“存在某个隐式转换可将一个U<em>指针转为一个T</em>指针”时才能通过编译</p>
<p>最后需要指明的是：<strong>member templates并不改变语言规则</strong>，而语言规则说，如果程序需要一个copy构造函数，你却没声明它，编译器会为你暗自生成一个。因此，使用member templates实现一个泛化版的copy构造函数时，编译器也会合成一个“正常的”copy构造函数</p>
<h2 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h2><p><strong>template实参推导过程中从不将隐式类型转换函数纳入考虑</strong>，下列将<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C%2B%2B/EffectiveC%2B%2B.md#%E6%9D%A1%E6%AC%BE24%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0">条款24</a>中的Rational和operator*改成了template，混合运算会编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">const</span> T &amp;numerator = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> T &amp;denominator = <span class="hljs-number">1</span>);<br>    <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt; &amp;lhs,<span class="hljs-type">const</span> Rational&lt;T&gt; &amp;rhs)<br>&#123; ... &#125;<br><br><span class="hljs-function">Rational&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">oneHalt</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>Rational&lt;<span class="hljs-type">int</span>&gt; result = oneHalf * <span class="hljs-number">2</span>   <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure>

<p>将oneHalf传递给operator*时，它将T推断为int，因此期待第二个参数也为Rational，但是第二个参数为int，前面我们说了，template实参推导过程中从不将隐式类型转换函数纳入考虑。因此编译错误</p>
<p>那么解决办法是什么？在class template将其声明为friend，从而具现化一个operator*，具现化后就可以不受template的限制了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//也可以是Rational&lt;T&gt;，但是省去&lt;T&gt;更简洁</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.numerator,<br>                         lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果上面只有函数声明，而函数定义在类外，那么会报链接错误。当传入第一个参数oneHalt时，会具现化Rational<int>，编译器也就知道了我们要调用传入两个Rational<int>的版本，但是那个函数只在类中进行了声明，并没有定义，不能依赖类外的operator* template提供定义，我们必须自己定义，所以会出现链接错误。解决方法就是像上面一样定义与类内</p>
<p>这样看起来有点像是member函数，但是因为friend关键字，所以实际是non-member函数，如果去掉friend关键字，就成了member函数，但是此时参数也只能有1个，就不能实现所有参数的隐式转换</p>
<p>上面的代码可能还有一个问题，虽然有friend，上述函数仍是隐式的inline。如果函数实体代码量较大，可以令operator*不做任何事，只调用一个定义与class外部的辅助函数（当然这里没必要，因为本身只有1行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>;<br><br><span class="hljs-comment">//helper template</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">doMultiply</span>(lhs, rhs);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h2><ul>
<li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现</li>
<li>整合重载技术后，traits classes有可能在编译期对类型执行if…else测试</li>
</ul>
<p>详细可参考<a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/C++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md#2traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95">STL源码分析中对traits的介绍</a></p>
<h2 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款48：认识template元编程</h2><ul>
<li>Template metaprogramming(TMP)是编写template-based C++程序并执行于编译期的过程</li>
<li>Template metaprogram(模板元程序)是以C++写成、执行于C++编译器内的程序</li>
</ul>
<p><strong>TMP的两个重要特点：1）基于template；2）编译期执行</strong></p>
<p>TMP有2个伟大的效力：</p>
<ol>
<li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的</li>
<li>执行于编译期，因此可将工作从运行期转移到编译期。会导致以下几个结果<ul>
<li>某些原本在运行期才能侦测到的错误现在可在编译期找出来</li>
<li>使用TMP的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求</li>
<li>编译时间变长了</li>
</ul>
</li>
</ol>
<p>traits解法就是TMP，traits引发“编译器发生于类型身上的if…else计算”</p>
<p>另一个TMP的例子是循环，TMP并没有真正的循环构件，所以循环效果藉由递归完成。TMP的递归甚至不是正常种类，因为TMP循环并不涉及递归函数调用，而是涉及“递归模板具现化”。以计算阶乘为例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&#123;    <span class="hljs-comment">//一般情况，Factorial&lt;n&gt;的值是n乘以Factorial&lt;n-1&gt;</span><br>    <span class="hljs-keyword">enum</span> &#123;value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value&#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt;&#123;    <span class="hljs-comment">//特殊情况：Factorial&lt;0&gt;的值是1</span><br>    <span class="hljs-keyword">enum</span> &#123;value = <span class="hljs-number">1</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value;    <span class="hljs-comment">//打印120</span><br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">10</span>&gt;::value;   <span class="hljs-comment">//打印3628800</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>TMP能够达到以下目标（这部分可以等有实际需求了再去详细了解）：</p>
<ul>
<li>确保量度单位正确</li>
<li>优化矩阵运算</li>
<li>可以生成客户定制的设计模式实现品</li>
</ul>
<h1 id="八-定制new和delete"><a href="#八-定制new和delete" class="headerlink" title="八.定制new和delete"></a>八.定制new和delete</h1><ul>
<li>operator new 和 operator delete用来分配单一对象</li>
<li>Arrays所用的内存由operator new[]分配出来，并由operator delete[]归还</li>
<li>STL容器使用的heap内存由容器所拥有的分配器对象管理</li>
</ul>
<h2 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h2><p>operator new抛出异常以反映一个未获满足的内存需求之前，会先调用一个客户指定的错误处理函数，new-handler，可以通过调用<code>std::set_new_handler()</code>来设置，<code>std::set_new_handler()</code>定义在<new>中：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">namespace std&#123;<br>    typedef void (*new_handler)();<br>    new_handler <span class="hljs-built_in">set_new_handler</span>(new_handler p) <span class="hljs-built_in">throw</span>(); <br>    <span class="hljs-comment">//以上，throw()是一个异常声明，括号内无任何内容，表示不抛任何异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当operator new无法满足内存申请时，它会不断调用new-handler函数，直到找到足够内存。一个设计良好的new-handler函数必须做以下事情；</p>
<ul>
<li><strong>让更多内存可被使用</strong>：一个做法是程序一开始执行就分配一大块内存，而后当new-handler第一次被调用，将它们还给程序使用。这便造成operator new内的下一次内存分配动作可能成功</li>
<li><strong>安装另一个new-handler</strong>：如果当前new-handler无法取得更多可用内存，可用安装另一个，下次operator new时会调用新的new-handler</li>
<li><strong>卸除new-handler</strong>：将null指针传给set_new_handler</li>
<li><strong>抛出bad_alloc(或派生自bad_alloc)的异常</strong>：这样的异常不会被operator new捕获，因此会被传播到内存索求处</li>
<li><strong>不返回</strong>：通常调用abort或exit（abort会设置程序非正常退出，exit会设置程序正常退出，当存在未处理异常时C++会调用terminate， 它会回调由std::set_terminate设置的处理函数，默认会调用abort）</li>
</ul>
<h3 id="实现class专属的new-handlers"><a href="#实现class专属的new-handlers" class="headerlink" title="实现class专属的new-handlers"></a>实现class专属的new-handlers</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerHolder</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NewHandlerHolder</span><span class="hljs-params">(std::new_handler nh)</span>: handler(nh)&#123;</span>&#125;<br>    ~<span class="hljs-built_in">NewHandlerHolder</span>()&#123; std::<span class="hljs-built_in">set_new_handler</span>(handler); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::new_handler handler;<br>    <span class="hljs-built_in">NewHandlerHolder</span>(<span class="hljs-type">const</span> HandlerHolder&amp;);     <span class="hljs-comment">// 禁用拷贝构造函数</span><br>    <span class="hljs-type">const</span> NewHandlerHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NewHandlerHolder&amp;); <span class="hljs-comment">// 禁用赋值运算符</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerSupport</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> std::new_handler current;   <span class="hljs-comment">//class专属的new-handlers</span><br>&#125;;<br><br><span class="hljs-comment">//class专属的new-handlers初始化为null</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::current = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::<span class="hljs-built_in">set_new_handler</span>(std::new_handler p) <span class="hljs-keyword">throw</span>()&#123;<br>    std::new_handler old = current;<br>    current = p;    <span class="hljs-comment">//将class专属的new-handlers设置为新的new_handler</span><br>    <span class="hljs-keyword">return</span> old;     <span class="hljs-comment">//返回旧的class专属的new-handlers</span><br>&#125;<br><br><span class="hljs-comment">//new时会调用该operator new</span><br><span class="hljs-comment">//它会设置全局的new-handlers为该class专属的new-handlers，然后调用全局operator new申请内存</span><br><span class="hljs-comment">//h对象销毁后，其析构函数会将全局new-handlers恢复为调用前的状态</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> * NewHandlerSupport&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>&#123;<br>    <span class="hljs-function">NewHandlerHolder <span class="hljs-title">h</span><span class="hljs-params">(std::set_new_handler(current))</span></span>;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有了<code>NewHandlerSupport</code>这个模板基类后，给Widget添加”new-handler”支持只需要public继承即可:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Widget: <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">NewHandlerSupport</span>&lt;<span class="hljs-symbol">Widget</span>&gt;&#123; ... &#125;;<br></code></pre></td></tr></table></figure>

<p><code>NewHandlerSupport</code>的实现和模板参数T完全无关，添加模板参数是因为handler是静态成员，这样编译器才能为每个类型生成一个handler实例</p>
<h3 id="nothrow-new"><a href="#nothrow-new" class="headerlink" title="nothrow new"></a>nothrow new</h3><p>1993年之前C++的operator new在失败时会返回null而不是抛出异常。如今的C++仍然支持这种nothrow的operator new</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget *p1 = <span class="hljs-keyword">new</span> Widget;    <span class="hljs-comment">// 失败时抛出 bad_alloc 异常</span><br><span class="hljs-keyword">if</span>(p1 == <span class="hljs-number">0</span>) ...             <span class="hljs-comment">// 这个测试一定失败</span><br><br>Widget *p2 = <span class="hljs-built_in">new</span> (std::nothrow) Widget;<br><span class="hljs-keyword">if</span>(p2 == <span class="hljs-number">0</span>) ...             <span class="hljs-comment">// 这个测试可能成功</span><br></code></pre></td></tr></table></figure>

<p>nothrow new只能保证所调用的nothrow版的operator new不抛出异常，但是构造也属于new的一个步骤，而它没法强制构造函数不抛出异常，所以并不能保证<code>new (std::nothrow) Widget</code>这样的表达式绝不导致异常</p>
<h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><p>一般出于下列原因可能想要替换编译器提供的operator new或operator delete：</p>
<ul>
<li>为了检测运用错误</li>
<li>为了收集动态分配内存的使用统计信息</li>
<li>为了增加分配和归还的速度</li>
<li>为了降低缺省内存管理器带来的空间额外开销</li>
<li>为了弥补缺省分配器中的非最佳齐位</li>
<li>为了将相关对象成簇集中</li>
<li>为了获得非传统的行为</li>
</ul>
<p>下面是一个”为了检测运用错误“而实现的简单的operator new的例子，通过在首部和尾部插入一个签名，返回中间内存块给程序使用，如果程序在使用内存时发生过在区块前或区块后写入的行为，那么签名就会被修改，因此可以检测这种行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> signature = <span class="hljs-number">0xDEADBEEF</span>;    <span class="hljs-comment">// 边界符</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Byte; <br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span> </span>&#123;<br>    <span class="hljs-comment">// 多申请一些内存来存放占位符 </span><br>    <span class="hljs-type">size_t</span> realSize = size + <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>); <br><br>    <span class="hljs-comment">// 申请内存</span><br>    <span class="hljs-type">void</span> *pMem = <span class="hljs-built_in">malloc</span>(realSize);<br>    <span class="hljs-keyword">if</span> (!pMem) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>(); <br><br>    <span class="hljs-comment">// 写入边界符</span><br>    *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>))) <br>        = *(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pMem)) = signature;<br><br>    <span class="hljs-comment">// 返回真正的内存区域</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个例子主要是展示，它存在很多错误：</p>
<ol>
<li>所有的operator new都应该内含一个循环，反复调用某个new-handling函数，这里却没有</li>
<li>C++要求所有operator new返回的指针都有适当的对齐。这里malloc返回的指针是满足要求的，但是因为上述实现并不是直接返回malloc的结果，而是返回一个int偏移后的地址，因此无法保证它的安全</li>
</ol>
<h2 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h2><p>前一条款是解释什么时候会想实现自己的 operator new 和 operator delete，这个条款是解释当实现自己的 operator new 和 operator delete 时，必须遵守的规则</p>
<h3 id="1）operator-new"><a href="#1）operator-new" class="headerlink" title="1）operator new"></a>1）operator new</h3><p>实现一致性的operator new必得返回正确的值，内存不足时必得调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new</p>
<p>下面是non-member operator new的伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;          <span class="hljs-comment">//处理0-byte申请</span><br>        size = <span class="hljs-number">1</span>;           <span class="hljs-comment">//将它视为1-byte</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        尝试分配<span class="hljs-function">size bytes</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(分配成功)</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-params">(一个指针，指向分配得来的内存)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-comment">//分配失败：找出目前的new-handling函数</span></span><br><span class="hljs-function">        new_handler globalHandler </span>= <span class="hljs-built_in">set_new_handler</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">set_new_handler</span>(globalHandler);<br>        <br>        <span class="hljs-keyword">if</span>(globalHandler) (*globalHandler)();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在继承中定制member operator new时，一般是针对某特定class的对象分配行为提供最优化，此时，并不是为了该class的任何derived classes。也就是说，针对class X而设计的operator new，其行为很典型地只为大小刚好为sizeof(X)的对象而设计。然而一旦被继承下去，有可能base class的operator new被调用用以分配derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base  <span class="hljs-comment">//假设Derived未声明operator new</span><br>&#123;...&#125;;<br><br>Derived *p = <span class="hljs-keyword">new</span> Derived;    <span class="hljs-comment">//这里调用的是Base::operator new</span><br></code></pre></td></tr></table></figure>

<p>如果Base class专属的operator new并没有设计上述问题的处理方法，那么最佳做法是将“内存申请量错误”的调用行为改采标准operator new，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))            <span class="hljs-comment">//如果大小错误</span><br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    <span class="hljs-comment">//交给标准的operator new处理</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2）operator-delete"><a href="#2）operator-delete" class="headerlink" title="2）operator delete"></a>2）operator delete</h3><p>operator delete比起operator new更简单，需要记住的唯一事情就是C++保证“删除null指针永远安全”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//如果将被删除的是个null指针，那就什么都不做</span><br>    现在，归还rawMemory所指的内存；<br>&#125;<br></code></pre></td></tr></table></figure>

<p>member版本也很简单，只需要多一个动作检查删除数量。万一class专属的operator new将大小有误的分配行为转交::operator new执行，你也必须将大小有误的删除行为转交::operator delete执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory,std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;         <span class="hljs-comment">//检查null指针</span><br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))&#123;           <span class="hljs-comment">//如果大小错误，令标准版</span><br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMemory)</span></span>;   <span class="hljs-comment">//operator delete处理此一申请</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    现在，归还rawMemory所指的内存<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果即将被删除的对象派生自某个base class，而后者欠缺virtual析构函数，那么C++传给operator delete的size_t数值可能不正确。这是“让你的base classes拥有virtual析构函数”的一个够好的理由</p>
<h2 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了placement new也要写placement delete</h2><p>placement new是带有额外参数的operator new，但是通常都指“接受一个指针指向对象该被构造之处”的operator new。这个版本被纳入了C++标准程序库，只要#include<new>\就可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>new会先调用operator new，然后构造对象。如果对象构造过程中发生异常，那么需要调用相应的operator delete，否则会发生内存泄露。而operator delete必须和相应的operator new匹配</p>
<ul>
<li>对于正常版本的operator new，匹配的operator delete就是不带额外参数的版本</li>
<li>对于非正常版本的operator new(placement new)，匹配的operator delete是带相应参数的版本(placement delete)</li>
</ul>
<p><strong>placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针施行delete绝不会导致调用placement delete</strong></p>
<p>这意味着如果要对所有与placement new相关的内存泄露宣战，我们必须同时提供一个正常的operator delete（用于构造期间无任何异常被抛出）和一个placement版本（用于构造期间有异常被抛出）。后者的额外参数必须和operator new一样。只要这样做，就再也不会因为难以察觉的内存泄露而失眠</p>
<p>还需要注意名称掩盖的问题：</p>
<ul>
<li>成员函数的名称会掩盖外围作用域中的相同名称</li>
<li>子类的名称会掩盖所有父类相同的名称</li>
</ul>
<p>一个比较好的方法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardNewDeleteForms</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//正常的 new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);&#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;&#125;<br><br>    <span class="hljs-comment">//placement new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, ptr); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(pMemory, ptr); &#125;<br><br>    <span class="hljs-comment">// nothrow new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, nt); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> StandardNewDeleteForms &#123;      <span class="hljs-comment">//继承标准形式</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;     <span class="hljs-comment">//让这些形式可见</span><br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;<br><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; log)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;    <span class="hljs-comment">// 自定义 placement new</span><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, std::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 对应的 placement delete</span><br>&#125;;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C/" class="category-chain-item">C++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AF%AD%E8%A8%80/" class="print-no-link">#语言</a>
      
        <a href="/tags/Effective-C/" class="print-no-link">#Effective C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Effective C++</div>
      <div>https://liruilong9999.github.io/2022/04/30/Effective-C++/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>liruilong</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年4月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/30/C++parallel/" title="C++ 并发">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++ 并发</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/30/docker%E5%AD%A6%E4%B9%A0/" title="dockers学习笔记">
                        <span class="hidden-mobile">dockers学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
